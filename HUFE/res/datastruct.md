微 课 版 (教学视频 ' 教学 资源, 练习与上机 “' 考研讲解)

(第多版)
& 灼后纪 爸 元 各

李 春 式 ”主编

清华大学出版社

“十二五?普通 高 等 教育本科 国 家 级规划教材

高 等 学 校 数 据结构 课 程 系列教材

数据 结构 教程(第 $ 版 )

李 春葆 主 编

尹 为 民

薪 晶 王 喻 丹丹 蒋 林 编著

清华大学出版社
北京

内 容 简 介

本 书 在 前 4 版的基础上针对 教育部 新 的 考研 大纲和 大 量 读者来信 提 出的要 求 进行了修订。本 书 共 13

章 ,内 容 包 括 绪论 .线性 表 、 栈 和 队列 . 串 . 递 归 、 数组和 广义 表 、 树和 二 叉 树 ` 图 ,查找 ,内 排序.外 排序和 文

件 等,书 中 给 出了大 量 练习 题和各 类 上 机 实验题。

本 书 是 全 视频 教程,提供 了 涵盖所有 知识 点 的微课 视频 ,部 分 视频 提供 了 更 多 示例 的 讲解,附录 下 中

还 包括 2015年一2017 年 全 国 计 算 机 专业 研究生人 学 联 考 数据 结构 部 分 试题的讲解视频 。

本 书 内 容 全 面,知识 点 羯 实,条 理 清 晰 ,讲解 透彻,实例 丰富 ,实用 性强, 适 合 高 等 院校计算机和 相关 专

业 的 本 科 生 及 研究 生 使用 。

本 书 封面 贴有清华大 学 出 版社防伪 标签 ,无 标签 者不得 销售 。

版权所 有 ,侵权必究。侵 权 举报电话 : 0I0-62782989

13701121933

图 书 在 版 编目(CIP) 数 据

数据 结构 教程/李 春葆主编. 一 5 版. 一 北京: 清华大 学 出 版 社 ,2017(2017.8 重印)

(高 等 学 校数据 结构 课程 系列 教材)

ISBN 978-7-302-45588-2

工 . @ 数 ... 工. @李... 焉. @ 数 据 结构一 教材 . DTP311.12

中 国 版本图 书馆 CIP数据核字(2016)第 283892 号

责任 编辑: 魏 江 江 王 冰 飞

封面 设计 :

杨 今

责任 校对: 李 建庄

责任 印 制: 杨 艳

出 版 发 行:清华大学出版社

网 址 : http://www. tup. com. cn,http://www. wqbook. com

地 , 址: 北京 清华大 学 学研大 厦 A 座

邮编: 100084

社 总 机: 010-62770175

邮购: 010-62786544

投稿与读者 服务: 010-62776969,c-service@tup. tsinghua. edu. cn

质量 反馈 : 010-62772015,zhiliang@tup. tsinghua. edu. cn

课件 下 载: http://www. tup. com. cn,010-62795954

印 刷 者: 北京 富 博 印 刷有限 公司

装 订 者: 北京市密云县京 文制本装订 厂

经 销: 全 国 新 华 书店

开 本: 185mmX260mm

印 张: 30

字 数: 729 千字

版

次:2005年1月第1版 2017年5月第5版

印 “次 :2017年8月第3 次印刷

印 数: 177501一187500

定 价: 59.50元

产品 编号: 072421-02

曾

数据结构 是 研究计算机科学 和 工程的基础,数据 结构 课程 是计算 机

科学 与技术 专业 及 相关 专业 的 核心 课程 之一,学 好 该 课程 不仅对 后 续 课

程 的 学习有很大帮助 ,而且 对 开发有效利 用计算 机 资源 的 程序 极为有益 。

计算 机 是 进行 数据处理 的工具 ,数据结构主要 研究 数据的各 种组织

形式以 及 建立在这 些结构之上 的 各 种 运算 算法 的 实现 , 它 不 仅 为 用计算

机语言 进行 程序设计 提供 了 方法 性 的 理论 指导 ,还 在 更 高 的 层次上总 结

了 程序 设计 的 常用方法和 常用 技巧 。

本 教程 是作者 针对 数据结构 课程 概念多、 算 法 灵活 和 抽象 性 强 等 特

点 ,在 总 结 长 期教学经验 的 基础上编写 的。全 书 分为13 章 和 5 个附录 ,

第 1 章为绪论 ,介绍 数据 结构 的 基本 概念,特别强调 算法分析 的 方法; 第

2 章 为 线性 表 , 介 绍 线性 表 的 两种存储 结构 一 一顺序表和 链表 ,以 及 基本

运算算法的实现过程; 第 3 章 为 栈 和 队列 ,介绍 这 两种特殊 的 线性结构 的

概念与应用; 第 4 章 为串, 介 绍 串 的 概念 与模式匹配 算法 ; 第 5 章 为 递

归 ,讨论计算机 学科 中 递归 算法 的设计 方法; 第 6 章 为 数组和 广义表,介

绍数组 ,稀疏 矩 阵 和 广义 表 的 概念与相关 运算 算法 的 实现过 程; 第 7 章为

树和二又树,介绍 树 和 二 又树 的 概念与各 种 运算 算法 的 实现过 程 , 其中 特

别 介绍 二 又树的各 种 递归 算法 方法; 第 8 章为图,介绍图的概念和图的各

种运算 算法 的实现 过 程; 第 9 章为查找 ,介绍 各 种查找 算法 的 实现 过 程 ;

第 10 章 为 内 排序,介绍 各 种 内 排序算法 的 实现 过 程; 第 11 章 为 外 排序,

介绍 各 种 外 排序 算法 的 实现 过 程; 第 12 章 为 文件,介绍 各 类 文件 的组织

结构; 第 13 章为采用 面向对 象的方法描述 算法 ,介绍 面向对 象 的 概念和

采用 C++ 语言 描述数据 结构 算法 的 方法 。

附录 A 给出了 实验报告格式,附录 B 是引用 型 参数和指针引用 型 参

数 的说 明 , 附 录 C 给出了 书 中 全 部 算法 的 索引 ,附录 D 给 出 了 书 中 相关 名

词 的索引 ,附录 E 为 教育部颁布的2018 年全 国计 算机 专业 硕士研究生 入

学 考试专业 课 中 的 数据结构 部 分 考试大纲 。

数据结构是一门应用实践性非常强的 课程,学 生 在 掌握各种数据结

构 ( 特 别 是存储结构) 的 基础上一 定 要 尽 可 能 多 地 上 机 实习 ,通过 较 多 的

实验 把 难以 理解的抽象 概念转化 为实实在 在的能 够 在计算 机 上 执行 的程

序 , 这 样 才 能 将所 学 知识和实际应用 结合 起 来,吸取 算法 的设计 思想 和 精

甸 ,提 高运用 这 些 知识 解决实际问题 的 能 力 。因此 ,本 教程 突出上机 实习 内

容 , 书 中 给 出了大 量 的上机 实验题( 分为验证 性实验 .设计 性 实验和 综合 性

实验 ) 供 教师 和 学 生选用 。

为了便于 学 生 学习和 上 机 实验 ,我们 还 编写了 与 本 教程配套 的《数据 结

构 教程学习 指导 》 和 《数据结构 教程上机 实验指导 》 两书, 构 成 一个完整的教

学 系列 。本 系列 教程 中 的所 有 程序 均 在 Visual C++ 6.0 和 Dev C++ 5 环境

(程序 文件 为* ,cpp)下调试通过。

本 教程和配套 的上机 实验 指导 ,学 习 指导 的编写 得 到 武汉大 学“弘 妆 学

堂” 数 据 结构 荣誉课程 教学 项目和 湖北 省“计算机 科学 与技术专业 课程体系

改革 ”项目的 支 助 , 聚集了 课程 组许多教师 多 年 来 在数据结构 课程教学 研究

和 教学 改革 中 的 经 验 与 成 果。本 书 在 编写过 程中得 到 王丽娜 、 黄 传河和 吴

黎 兵 等多位 教授,博导的大 力 支持,陈 国良院 士提供 了 富有 建设 性 的 指导 ,

很 多 使用本 书 的 老师和 同学 给 予了热心 帮助 ,清华 大 学 出 版 社 的魏江 江 主

任 和 王 冰 飞 编辑 给 予了愉快 的 合作 ,作者在此 一 并 表示 衷心 的感谢 。

为 了 方便 教师 教学 和 学 生 学 习 , 本 书 提供了全 面而丰富 的教学 资源,其

吕

h 包 括 教学 PPT、 教学视频 、 源 程序 代码和练习题参考 答案 等 。可以 扫描封

底 课件二 维 码 免费下 载 。

本 书是全 视频 教程,提供 了 涵盖所 有 知识 点 的微课 视频 ,部 分视频 提供

了 更 多 示例 的 讲解,附录 E 中还包括 2015 年~2017 年全国计 算 机 专业 研究

生 入 学 联 考 数据 结构 部 分 试题 的讲解视频 。

由 于 水平所 限 ,尽管 作者 不 遗 余力,本 书 仍 可 能 存在 错误和 不 足 之处,

敬请 读者 批评 指正 ,特别 希望 使用本 书 的教师 与作者 探讨 ,共同 提高 我 国计

算 机 专业 数据 结构 课程 的 教学 水平 。

作 者

2017年1月

第1章 绪论 /1

1.1

什么是数据结构 /2

1.1.1 数据 结构 的 定义 /2

1.1.2 逻辑 结构 /3

1.1.3 存储 结构 /6

1.1.4 数据 运算 /8

1.1.5 数据 类 型和抽象数据 类 型

/9

1.2

算法及其描述

/14

1.2.1 什么是算法

/14

1.2.2 算法 设计 的 目标 /15

1.2.3 算法 描述 /16

1.3

算法 分析

/18

1.3.1 算法分析概述

/18

1.3.2 算法时间性能分析 /18

1.3.3 算法空间性能分析 /22

1.4

数据 结构+ 算法= 程序 /24

1.4.1 程序和数据结构 /24

1.4.2 算法和程序

/24

1.4.3 算法和数据结构 /24

1.4.4 数据 结构 的 发展 /25

本 章小结 /26

练习 题 1

/26

上 机 实验 题 1

/28

惟 验 证 性 实验

惟 设计性实验

/28

/29

第 2 章 线性表 /30

2.1 线性 表 及 其 逻辑 结构 /31

2.1.1

线性表的定义 /31

2.1.2

线性 表 的 抽象数据 类 型 描述 /31

2.2 线性 表 的 顺序存储 结构 /33

2.2.1

线性 表 的 顺序 存储 结构 一一顺序 表

/33

2.2.2

顺序 表 基 本 运算 的 实现 /35

2.3 线性 表 的 链 式存储 结构 /43

2.3.1

线性 表 的 链 式存储 结构 一一链表

/143

2.3.2

单链表

2.3.3

双 链 表

/45

/154

2.3.4

循环链表

/59

2.4 线性表的应用

/61

2.5 有 序 表

/65

2.5.1

有 序 表 的 抽象数据 类 型 描述 /65

2.5.2

2.5.3

2.5.4

有 序 表 的存储 结构 及 其 基本 运算 算法 /66
有 序 表 的归并算法 /66
有 序 表 的 应用 /69

本 章 小 结

练习题 2

/71

/71

上 机实验题 2

/74

慌 验证性实验

慌 设计性实验

民 综合性实验

/74

/76

/77

第 3 章 栈和队列 /78

3.1 材

/179

3.1.1

栈 的 定义 /79

3.1.2

栈 的 顺序 存储 结构 及 其 基本 运算 的 实现 /80

3.1.3

栈 的 链 式存储 结构 及 其 基本 运算 的 实现 /83

3.1.4

栈 的 应用 /87

3.2 队列

/97

3.2.1

队列的定义

/97

3.2.2

3.2.3

队列 的 顺序存储 结构 及 其 基本 运算 的 实现 /98
队列 的 链 式存储 结构 及 其 基本 运算 的 实现 /103

3.2.4

队列的应用举例 /108

TV

3.2.5 双 端 队列

/113

本 章 小结 /115

练习 题3

/115

上 机实验题3

/117

慌 验证性实验

慌 设计性实验

惟 综合性实验

/117

/119

/119

第 4 章 串 /121

4.1 串的基本 概念

/122

4.2 串 的 存储 结构 /122

4.2.1

4.2.2

串 的 顺序 存储 结构 一 一 顺序串 /123

串 的 链 式存储 结构 一 一 链串 /128

4.3 串 的 模式匹配

/134

4.3.1 Brute-Force算法

/134

4.3.2 KMP 算法 /136

本 章 小结 /143

练习 题4

/143

上 机实验题4

/144

怜 验证性实验 /144

展 设计性实验 /145

惟 综合性实验 /145

第 5 章 递归 /146

5.1 什么是递归

/147

5.1.1 递归的定义

/147

5.1.2 何 时 使 用 递归

/148

5.1.3 递归 模型 /149

5.1.4 递归与数学归纳法 /152

5.2

栈 和 递归 /152

5.2.1 函数调用栈 /152

5.2.2 递归 调用 的 实现 /153

5.2.3 递归 到 非递归 的 转换 /155

5.3 递归 算法 的 设计

/156

5.3.1 递归算法设计的步骤 /156

5.3.2 基于 递归 数据结构 的递归 算法 设计 /158

5.3.3 基于递归 求解 方法的递归 算法 设计 /159

本 章 小结 /161

练习题 5

/162

上 机实验题5

/162

慌 验证性实验

愉 设计性实验

惟 综合性实验

/162

/163

/163

第6章 数组和广义表 /164

6.1 数组

/165

6.1.1 数组的基本概念 /165

6.1.2 数组的存储结构 /166

6.1.3 特殊矩阵的压缩存储 /168

6.2, 稀疏和矩阵

/171

6.2.1 稀 玻 矩阵 的 三 元 组 表示

/172

6.2.2 稀疏 矩阵的十 字 链 表 表 示

/175

6.3 广义表 /177

6.3.1 广义表的定义 /177

6.3.2 广义表的存储结构 /179

6.3.3 广义表的运算

/180

本 章 小结 /185

练习 题6

/186

上 机实验题6

/186

慌 验证性实验 /186

民 设计性实验 /187

慌 综合性实验 /187

第 7 章

树 和 二 叉树 /189

7.1

树 的 基本 概念

/1190

站了HH

.1 树 的 定义 /190

2 树 的逻辑表示方法 /190

.3 树的基本 术语

/191

4

5

树 的 性质 /192

树 的 基本 运算 /194

.6 树 的存储 结构 /195

7.2 , 二叉树的概念和性质 /198

7.2.1 二 又 树 的 定义 /198

7.2.2 二 又 树 的 性质 /199

7.2.3 二 又 树 与树、 森 林 之 间 的 转换 /200

7.3 二 叉 树 的 存储结构 /203

7.3.1 二 叉 树 的 顺序存储 结构 /204

7.3.2 二 又 树的链 式存储 结构 /205

7.4 二 叉 树的基本 运算 及 其 实现

/206

7.4.1 二 又 树的基本 运算 概述 /206

7.4.2 二 叉 树的基本 运算 算法 实现 /207

7.5 二 叉 树 的 遍历

/211

7.5.1 二 叉 树遍历的概念 /211

7.5.2 先 序.中序和 后 序 遍 历递归 算法 /212

7.5.3 先 序.中序和 后 序 遍 历非递归 算法 /218

7.5.4 层次 遍历 算法

/226

7.6 二 叉 树 的 构造 /228

7.7 线索二叉树 /233

7.7.1 线索二又树的概念 /233

7.7.2 线索化二又树 /233

7.7.3 遍历 线索化二 又树 /236

7.8 哈 夫 曼树 /237

7.8.1 哈 夫 曼 树 概述 /237

7.8.2 哈 夫 曼 树 的 构造 算法 /238

7.8.3

了哈夫 曼 编码 /239

7.9 用 并 查 集 求解 等 价问题 /241

7.9.1 什么叫并查集

/241

7.9.2 并 查 集 的算法实现 /243

本 章 小结 /245
练习题7
/245

上 机实验题7

/247

劲 验证性实验 /247

瞧 设计性实验 /248

瞧 综 合 性 实验 /249

第 8 章 图 /252

8.1 图 的 基本 概念 /253

8.1.1

图 的 定义 /253

8.1.2

图 的 基本 术语

/254

8.2 图 的 存储 结构和 基本 运算 算法 /256

本 国

8.2.1 邻接矩阵存储 方法 /256

8.2.2 邻接表存储方法 /258

8.2.3

图 基本 运算 算法 设计

/260

8.2.4 其 他 存储 方法 /262

8.3 图 的 遍历

/264

8.3.1

图 的遍历的概念 /264

8.3.2 深度 优先 遍历 /265

8.3.3 广度 优先 遍历 /266

8.3.4 非连通图的遍历 /267

8.3.5

图 遍历 算法 的 应用 /269

8.4 生成树和最小生成树 /279

8.4.1 生成树的概念 /279

8.4.2 无 向 图 的连通 分量和 生成树 /280

8.4.3 普 里姆算法

/281

8.4.4 克 鲁 斯卡尔算法 /285

8.5 最短路径 /290

8.5.1 路 径 的 概念

/290

8.5.2 从 一 个 顶点 到 其 余 各 顶点的最 短路径 。 /290

8.5.3 每对顶点 之 间 的 最 短路径 /296

8.6 拓扑排序 /301

8.7 AOE 网与关键路径 /303

8.7.1 相关 概念 /303

8.7.2 求AOE 网 的 关键 活动 /306

本 章 小结 /307
/308
练习题8

上 机实验题8

/310

慌 验证性实验 /310

上参 设计性实验 /311

展 综合性实验 /313

9.1 查找的基本概念 /315

9.2 线性表的查找

/316

9.2.1 顺序 查找 /316

9.2.2 折 半 查找

/317

9.2.3 索引 存储 结构和 分 块 查找 /321

9.3 树 表 的 查找

/324

9.3.1 二又排序树 /324

9.3.2 平衡二又树 /333

9.3.3 B-树 /339

9.3.4 B+树 /345

9.4 哈 希 表 的 查找 /346

9.4.1 哈 希 表 的基本概念 /346

9.4.2 了哈 希 函数的构造 方法 /348

9.4.3 哈 希 冲突 的解决 方法 /350

9.4.4 哈 希 表 的运算算法 /352

本 章 小结 /360

练习题 9

/360

上 机实验题9

/362

慌 验证性实验 /362

瞧 设计性实验 /363

惟 综合性实验 /364

第 10 章 内排序 /365

10.1 排序的基本概念 /366

10.2 插入 排序 /368

10.2.1 直接插入 排序 /368

10.2.2 折 半 插入 排序 /370

10.2.3 和希 尔 排序 /371

10.3 交换 排序 /374

10.3.1

冒 泡 排序 /374

10.3.2 快速排序 /376

10.4 选择排序 /380

10.4.1 简单 选择排序 /380

10.4.2 推排序 /382

10.5 归并 排序 /386

10.6 基数 排序 /389

10.7 各 种 内 排序 方法 的 比较和 选择 /392

本 章 小结 /394

练习题 10

/394

上 机实验题 10

/396

惟 验证性实验 /396

慌 设计性实验 /397

惟 综合性实验 /397

第 11 章 外排序 /399

11.1 外 排序 概述 /400

11.2 磁盘 排序

/400

11.2.1 磁盘 排序 概述 /400

11.2.2 生成 初始归并段 /402

11.2.3 多 路 平衡归并

/404

11.2.4 最佳归并树 /407

11.3 ”磁带 排序

/409

11.3.1 多 路 平衡归并 排序 /409

11.3.2 多 阶段 归并 排序 /411

本 章 小结 /412
/412
练习题 1

上 机实验题11

/413

慌 验证性实验 /413

戏 设计性实验 /413

12.1 文件的基本概念 /415

12.1.1 什么是文件

/415

12.1.2 文件 的逻辑结构 及 操作 /415

12.1.3 文件的存储结构 /416

12.2 顺序 文件 /416

12.3 索引 文件

/417

12.3.1

JISAM 文件 /418

12.3.2 VSAM 文件

/421

12.4 了哈 希 文件 /422

12.5 多关键字文件 /423

12.5.1 多 重 表文件 /423

12.5.2 倒 排 文件 /424

本 章 小结 /425

练习题 12

/425

上 机实验题 12

/425

懂 验证性实验 /425
大 设计性实验 /426

第 13章 采用 面向对 象的方法 描述 算法 /427

13.1 面向对象的概念 /428

13.2

用 C++ 描述 面向对象 的 程序 /429

13.2.1 类

/429

13.2.2 类 对象 /432

13.2.3 构造机数和析构函数 /433

13.2.4 模板类 /436

13.3 用 C++ 描述 数据结构 算法 /438

13. 3.1 顺序表类模板

/439

13. 3.2 链 栈 类 模板

/441

13.4 使用 STL 设计 数据结构 算法 /443

附录A 实验 报告 格式 /450
/450

一、设计人 员 相关 信息

二 、 程序设计 相关 信息

/450

三、实验提交内容 。 /450

附录B 引用 型 参数和 指针 引用 型 参数的 说明 /451

附录C 算法 索引 /453

附录D 名 词索引

/457

附录E 全 国 计 算 机 专业 数据 结构 2018 年

联 考 大纲 “/461

参考 文献 “/463

数据结构"是计算 机 及 相关 专业 的专业 基础 课 之一, 是 一 门十

分 重要 的 核心 课程,主要学习 用计算 机 实现 数据 组织和 数据处理 的

方法。它 也 为计算 机 专业 的 后 续 课程(如 操作 系统 、 编译 原理 、 数据

库 原理和 软件 工程 等)的 学 习打下了 坚实 的 基础 。

另外, 随 着计算机 应 用 领域 的不断扩 大 , 非 数 值计算问题占 据

了 当今计算机 应 用 的 绝大多 数 , 简单的数据 类 型 已经远 远 不 能 满足

需要, 各 数据 元 素 之间 的 复杂 联系 已 经 不是普通 数学 方程 式所 能 表

达 的了 , 无 论设计 系统 软件 还 是应用 软件 都 会用到 各 种 复杂 的 数据

结构, 因此 掌握好 数据 结构 课程 的 知识 对 于 提高 解决 实际 问题的 能

力将 会 有 很大的 帮助 。实际上, 一个 好 ”的 程序 无 非 是 选择一 个

合理 的 数据 结构和 好 的 算法 , 而 好 的 算法 的 选择 在 很 大 程度上取决

于 描述 实际问题所采用 的 数据 结构, 所 以 要 想 编写出 好 ”的 程序 ,

学生仅仅学习计算 机语言 是 不 够 的, 必须扎实地 掌握 数据 结构 的 基

本 知识 和 基本 技能 。

数据 结构教程

[第! 5版

什么是 数据 结构

米

在 了 解数 据 结构 的重要 性 之 后开始讨论 数据结构 的 概念,本 节 先给出 数据 结构 的严格

定义 ,再 从 一 个 简单 的学生 表 例 子人手 ,展示 数据 结构包含 的 三 个方面的内 容 , 接 着 分 析 数 据

巡 辑 结构和 存储 结构 的 儿 种 类 型 ,最后 给出了 数据 类 型和抽象 数据 类 型 之间 的 区 别与联系。

111 数据 结构 的 定义

用 计算 机 解决 一个具体 的 问题 大 致需要经 过 以下几 个步骤 :

(1) 分 析问 题,确定数据 模型。

(2) 设计 相应 的 算法 。

人

视频讲解

(3) 编写 程序,运行 并 调试 程序,直至 得 到 正确 的结果 。

寻求 数学 模型 的实质是分 析 问 题 ,从中 提取 操作 的 对 象 ,并 找出这 些 操 作对 象 之间 的 关

系 , 然 后 用 数学 语言加 以 描述 。有 些 问 题 的数据 模型 可以用 具体 的 数学 方程 等 来表示 ,但 更

多 的 实际 问题 是 无法用 数学 方程 来表示 的 ,这 就需要 从 数据人手 来分析 并 得 到 解决问题 的

方法。

数据(data) 是描述 客观事物的 数和 字符的 集合 。例 如 ,人们在日 常生活中 使用的 各 种

文字 数字 和 特定 符号 都是数据。从 计算 机 的 角度看,数据 是所有 能 被 输入到 计算 机 中 , 且

能 被 计算 机 处 理 的 符号 的 集合 , 它 是 计算 机 操作 的对 象 的 总称 ,也 是 计算 机 所 处 理 信息 的 某

种 特定 的 符号 表示 形式 (例如,200902 班 学生数 据 就 是 该班全 体学生记 录 的 集合 ) 。

人们 通常以数据 元 素(data element)

作为数据的基本单位(例如,200902 班 中 的 每个学

生 记 录 都 是 一个数据 元 素 ) 。在 有 些 情况下 ,数据 元 素 也 称 为 元 素 、 结点、 顶 点 或 者记录 等 。

一 个 数据 元 素 可 以 由 若干个数据 项 组 成 。

数据项(data item)是具有 独立 含义 的数据最小单位,也 称 为 字段或域。例 如 ,200902

班中的 每个数据 元 素 ( 即 学 生 记 录 ) 是 由 学 号`姓名.性别 和 班 号 等数据 项 组 成的。

数据对象Cdata object)

是指性质相同 的数据 元 素的 集合 , 它 是 数据 的 一个子 集 。在数

据 结构 课程 中讨论 的 数据 通常指的 是数据对 象 。

数据 结构 (data structure)

是指所有数据元 素以 及数据元素之间的 关系 ,可 以 看 作 是 相

互 之 间 存 在 着 某 种特定 关系的 数据 元 素的 集合,如 图 1. 1 所示 。 因 此 ,我们 可 以 把 数据 结构

看 成是带 结构 的 数据 元 素 的 集合 。

数据结构

+

结构 数据结构通常包括 以下几 个方面。

“= 数据
全
ee 元 素 之问 的 逻辑 关系构成 。

和 人 (1) 数据的 逻辑 结构 (logical structure): 由 数据

图 1.1 数据 结构由 数据和 结构 组 成

(2) 数据的 存储 结构 (storage structure): 数据元

素 及 其 关系 在计算 机 存储 器 中 的 存储 表示 ,也 称 为 数

据的 物理结构 (physical structure) 。

(3) 数据 的 运算Coperation): 施加在该数据上 的 操作 。

因此 ,数据 结构 是 一 门 讨论* 描 述 现实 世界 实体 的 数学 模型(通常 为非 数值计算 ) 及 其 之

PASS人论 |

上 的 运算 在 计算 机 中 如 何 表示 和 实现 的 学科 。

那么学 习 数 据 结构有什么 意义呢? 以 盖 一 栋 房 屋 为 例,如 图 1.

2 所 示 ,房屋由 很多构件

组 成 ,如 窗户 就 是重要 的 构件 。这 里 可 以 将 窗户 看 成 一

个 数据结构 ,窗户 的 元 素 包括 铝 合 金 框、玻 璃.拉手和滑

轮等,这 些 元素构成的窗户 的 模型 就是旭 辑结构 ,其 运算

包括 它 所 提供 的 各 种 功能。若 把 窗户 模型 设计 好 ,在 建

房屋时 就 可 以 直接 使用它 。

软件 开发 也是如 此 ,如 果 提 炼 出其中 的一个个数据

结构 ,并 加以"好 ?的 设计 ,不仅可 以 提高 开发效率 ,而 且

会 提高 软件 的 可 靠 性 。

112 逻辑 结构

系 的 整体 ,通常是从求解 问题中提炼出来的。数 据 巡 辑 结构 与 数据的存储 无关, 是 独立于计

算 机 的 ,因此 数据 的 逻辑 结构可 以 看 作 是从具体 问题抽象 出来的 数学 模型 。

在 现实 世界 中 ,数据元 素的旭 辑 关系 是 多 种 多 样的,但 在 数据 结构中 主要讨论数据 运算

之 间 的 相 邻 关 系 或 者邻接 关系 。

数据 的 逻辑 结构 可 以 采用 多 种 方式表示 ,常见 的有图 表 和 二 元 组 等 。

1) 图 表 表示

逻辑 结构 的 图 表 表 示 就是采用 表格 或者图 形 直接 描述数据 的逻辑 关系 。例 如,有一个

学 生 表 ( 数 据 ) 如 表 1.1 所 示。这 个 表 中 的 数据 元 素 是学生 记 录 , 每个数据 元 素 由 4 个 数据

项 ( 即 学号、 姓名,性别 和 班号) 组 成 。从逻辑上看,学号 1 的 元素和 学 号 8 的 元 素 是 相 邻的,

而 学 号 12 的 元素和 学 号 5 的 元 素 是 不相邻 的 。这 7 个 学 生 记 录 和 它们 之间 的 相 邻关系 就

构成了 该数据 的逻辑 结构 。

表 1.1 学生表

学

号

姓

名

性

别

班

号

1

8

34

20

12

26

5

张 斌

刘 丽

李 英

陈 华

王 奇

董 强

王 萍

男

女

女

男

男

男

女

9901

9902

9901

9902

9901

9902

9901

ES

在 用 图 形 表 示 巡 辑 结构时 ,图 形 中 的 每个结 点 对 应 着 一 个 数据 元 素 , 两 结 点 之间 带 箭头

的 连 线 表 示 它们 之 间 的 相 邻 关系。假设用 "学 号?数据 项 唯一标识 数据 元 素 ,学生 表 的 旭 辑

结构图形表示如图1. 3 所 示 。

数据结构教程 SEASARR

OO GCCGRIG

图 1.3

学 生 表 的 图 形 表示

2) 二 元 组 表示

二 无组是 一 种通用 的 数据逮辑结构 表示 方式。一个二 元组 表示 如 下 :

了B=(CD,R)

其中,已 是一种 数据 逻辑 结构, 它 由数据元素的集合 D 以 及盖 上 二 元 关系 的 集合尺所组

成 。 即:

了 = (dl 过过wz二0}
玉一{ 方|1 和过) 过mm三0)

其中,di; 表示 集合 D 中 的 第 ;个数据元素,” 为了 中 数据 元 素 的个数 ,若 x 一0,则 是 一 个

空集,因而也 也 就 无结构 可 言,'有 时 把 这 种情况 认为是县有任意结构 。

方 表示 集合尺 中的第7) 个关系,z 为尺 中关系的个数,若记 =0,则尺 是 一 个 空 集,表明

集合 D 中 的 数据 元 素 间 不 存在任何逻辑 关系 ,彼此 是独立 的,这 和 数学中 集合 的 概念是一

致的。

尽 中 的 一 个 关系 ~ 是 序偶 的 集合,对

于 中 的任 一 序 偶 <z,y>(Cz,yED), 表 示 元 素 工

和>y 之 间 是 相 邻 的 , 即 工在> 之前,>在z 之后,z 称 为 该 序 偶 的 第 一 元 素 ,y 称 为 该 序偶 的

第 二 元 素 , 而且z 为 y 的 直接 前 驱 元 素(predecessor),y 为 的 直接 后 继 元 素(successor)。

为了简便 ,后 面将直接 前 驱 元素和 直接 后 继 元 素 分 别 简称 为前驱 元素和 后 继 元 素 。

若 某 个 元 素 没有前 驱 元 素 , 则 称 该 元 素 为开始 元 素 (first element); 若 某 个 元 素 没有后

_继元素 , 则 称 该元素 为终端 元 素(terminal element)。

可用圆括号代替尖括号,即
对 于 对 称 序 偶 ,即 <z,y>Er,'则 <y,z>ErCz,yED),

(zy)Er。 在 用 图 形 表 示 逮 辑 关系时 ,对 称 序偶 用 不 带 箭头 的 连 线 表 示 。

【例 1. 1〗 有 一 个 如 表 1. 2 所 示 的 城市表 , 假设区 号 是 唯一的,给出其逻辑 结构 的 二 元

组 表示 。

PE

区 号

010

021
027

029

025

表 1.2 城市表

城市 名

Beijing

Shanghai
Wuhan

Xian

Nanjing

说

明

北京,首都

上 海 ,直辖市
武汉 ,湖北 省 省 会

西安 ,陕西省省 会

南京,江苏 省 省 会

城市表中共有 5 个记录 ,其 逻辑 结构的二 元 组 表示 如 下 。

City一(CD,R)

一 {010,021,027,029,025》}

PASS人论 |

下一 {}

7 一 {<010,021 >,<021,027>,<027,029>,<029,025>}

客观 世界 中 数据 的 逻辑 结构 是 纷繁复杂 的 ,归纳 起 来 主要有以下几 类 。

1) 集合

集合 (set) 是 指数 据 元 素 之 间 除 了 ”同属于 一 个 集合 ?的 关系以外 别 无其他 关系 。

2) 线性 结构

线性结构(linear structure) 是 指 该 结构中 的 数据 元 素 之 间 存 在 一对 一 的 关系。其 特点

是 开始 元素和 终端 元 素 都 是 唯一 的 ,除了 开始 元素和 终端 元 素以外 ,其 余 元 素 都有且仅有 一

个 前 驱 元 素,有 且仅有 一 个 后继元 素。线 性 表 就 是一种 典型 的 线性结构 。

例如 ,对 于 前 面 的学生 表 数据 ,学 号 1 的 元 素 为开始 元素, 学 号 5 的 元 素 为终端元素。

其 余 每个数据 元 素有且 仅有一 个 前 驱 结点和 一 个后继 结 点 ,因此 它 是 一 种 线性 结构 。

3) 树 形 结构

树 形 结构 是 指 该 结构中 的 数据 元 素 之 间 存 在 一 对 多 的 关系。其 特点 是除了 开始 元 素 以

外 ,每 个 元 素有且 仅 有 一 个 前 驱 元 素 ,除了 终端元素以 外 ,每 个 元素有 一 个 或 多 个后继 元 素 。

二 又 树 就 是一种 典型的树 形结构 。

【例 1. 2〗 有 一 种数据结构 B,= 王CD,R),其中:

一 {a,b,c,de,fg,h,ij

玉一 {r}

7 一 {<a,b>,<ac>,<a,d>,<b,e>,<c,f>,<c,g>,<dh>,<d,i>,<d,j>}

画 出其逻辑 结构 图 形 表示 ,指出 是 什么类 型 的

使

逻辑 结构 。

对 应 的 图 形 表示 如 图 1.4 所示。

从 该例中 可以 看 出 ,每 个 结 点有且 仅 有 一 个 前

纪/ 忆

避

驱 结点( 除树根 结点 。 以外) ,但有 多 个后继 结 点 ( 桂
叶 结 点 可 看作具 有 有 零 个 后继结 点), 因 此 B,
树 形 结构 。

是 -种 (se) (人) 人)

CD GD GD

图 1.4

Bi 的 逻辑结构 图 示

【例 1.3】 有 一 种数据结构 B, 一(D,R),其中:

万一{48,25,64,57,82,36,75}

尺 一 人 六,疡}
方二{<25,36>,<36,48>,<48,57>,<57,64>,<64,75>,<75,82>}

疡 一{<48,25>,<48,64>,<64,57>,<64,82>,<25,36>,<82,75>}

aa

画 出 其 逻辑 结构 图 形 表 示 ,指出 是什么 类 型 的迎辑 结构 。

对 应 的 图 形如 图 1.5 所示。其中广 ( 对 应 图 中 的 虚线 部 分 ) 为线性 结构 ,王 ( 对 应 图

中 的 实 线 部 分 ) 为 树 形 结构 ,因此 在 同一 数据 集合上可以 有 多 种 届 辑 关 系 。

4) 图 形 结构

图 形结构 是 指 该 结构中 的 数据 元 素 之 间 存 在 多

对 多 的关系。其特点 是 每个元 素 的 前 驱 元素和 后 继

元 素 的个数 可 以 是任意 的,因此 图 形 结构 可 能 没有

开始 元素和 终端 元 素,也 可能有 多 个开始 元 素 、 多 个

终端元素。

树 形结构和 图 形 结构 统称 为非线性 结构 ,该结

构 中 的 元 素 之间 存 在 一对 多 或多对 多 的 关系 。由图

形 结构 、 树 形 结构和 线性 结构 的 定义 可 知 ,线性 结构

图 1.5

了B: 的 逻辑结构 图 示

是 树 形 结构 的 特殊 情况 ,而 树 形 结构 又 是图形 结构 的特殊 情况 。

【例1.4〗 有 一 种数据结构 B: 一(D,R),其中:

三一{a,b,c,d,e}

玉 一 (Try)

7 一{ (ab),(a,c),(b,c),(c,d), (ce),Cde) }

画 出其逻辑 结构 图 形 表 示 , 指 出 是 什么类 型 的逻辑

本

对 应 的 图 形 表示 如 图 1.6所示。

SR力

@

从 该例中 可 以 看出,每个结 点 可 以有多 个 前 驱结点和 AN

多 个 后继结 点 ,因此 B, 是一种 图 形结构 。

人

9)

113 存储 结构

图 1.6 , B; 的 逻辑 结构 图 示

数据 逻辑结构在计算 存储 器 中 的 存储 表示 称 为数据 的 存储 结构 (也 称为 -日

映像) ,也 就 是 逻辑结构 在计算 机 中 的 存储 实现 。当 把 数据对 象存储 到 计算 机

中 时 ,通常 要 求 既 要 存储 逻辑结构 中 的 每一个 数据 元 素,又 要 存储 数据 元 素 之
间 的 逻辑 关系 。

f

显然数据 的 存储 结构 是 依赖 于计算 机 的。通 常设计数 据 的 存储结构 是 借助 六生

某 种计算 机 语言 来实现 的 ,一 般 只 在 高 级语言 的 层次 上讨论 存储 结构,这 里 采用 C/C++语言。

在实际应用中 ,数据 的 存储 方法是灵活 多 样 的,归纳 起 来,数据 结构中有以下 4 种 常用

的 存储 结构 类 型 。

顺序 存储 结构 (sequential storage structure) 是 采用 一组 连续 的 存储 单元存放 所 有 的数

据 元 素,也 就 是 说 ,所有 数据 元 素 在 存储器中占有 一 整 块存储 空间 ,而 且 两个逻辑 上 相 邻 的

元 素 在 存储 器 中 的 存储 位 置也相 邻 。因 此 ,数据 元 素 之 间 的 逻辑 关系 由 存储 单元地 址 间 的

关系 隐 含 表示 , 即 顺序 存储 结构 将 数据 的 逻辑 结构 直接 映射 到 存储结构 。

顺序 存储 结构 的 主要 优点是存储 效率高,因为分配给 数据 的 存储 单元全 用 于 存放 数据

元 素 ,元 素 之间 的 多 辑 关系 没有占用 额外 的 存储 空间, 另外 ,在 采用 这 种 存储 方法时 可 实现

对 元 素 的随机 存 取 , 即 每 个元素对 应 一个逻辑序号 ,由 该序号 可 直接计算出对 应 元 素 的 存储

地 址,从 而 获取 元 素 值 。顺 序 存储 结构 的 主要 缺点是不便于 数据 修改 ,对 元 素 的插入 或 删除

PASS论 |

操作 可 能 需要 移动 一 系列 的 元 素 。

例如 ,对 应 表 1. 1 的 学生 表 , 可以 采用 C/C++语 言中的 结构 体 数组 来 存储,设计 对 应 的

结构体数组 Stud 并 初始化的过 程如下 :

StTuct

{

int no;

char name[8] ;

char sex[2] ;

char class[4] ;

//存储学号

//存储姓名

//存储性别

//存储班号

} Stud[7] 一 {{1," 张 研"," 男","9901"},...,,{5," 王 萍","女 ","9901"}};

其中 ,数组名称 Stud 作为 数组 的 起始地 址 ,用 于 唯一标识 该存储结构 ,如 图 1.7 所 示 。 在

Stud 数组中 各 元 素在内 存 中 顺序 存放 ,即 Stud[让存放在Stud[Li

十1之前,而StudLi十1存

放在Stud[详之后,所以 Stud 是学生 表 的 一种顺序 存储结构 。

Stud[0]

Stud[1]

Stud[6]

1 张城 | 男|9501|8 | 刘丽|[女 [ggoz]

...

[5 王划[女[99ol

Stud: 起始地 址

1.7

学 生 表 的 顺序 存储 结构

在 链 式 存 储 结 构 (linked storage structure) 中,每个逻辑元 素用 一 个 内 存结 点 存储 ,每

个结 点 是 单独 分 配 的 ,所有 的 结 点 地 址 不 一定是连续 的 ,所以无须 占 用 一 整 块存储 空间。为

了 表示 元 素 之 间 的 逻辑 关系 ,给 每 个结 点 附加指针 域 ,用于 存放 相 邻结 点 的 存储 地 址 ,也 就

是通过 指针 域 将所有 结 点 链接 起 来,这 就是链 式 存储结构名称的由 来 。

链 式 存储 结构 的 主要 优点是便于 数据 修改 ,在 对 元 素 进行插入 或 删除操作 时 仅 需 修改

相应结 点 的指针 域 , 不 必 移 动 结 点。与 顺序 存储 结构 相 比 , 链 式存储 结构 的主要 缺点是存储

空间 的 利用 率 较低 ,因为 分 配给 元 素 的存储 单元有一 部 分被用 来存储结 点 之间 的 迎 辑 关系 ;

另外 ,由 于 逻辑 上 相 邻 的 元 素 在 存储 空间中 不 一 定相邻,所以 不能 对 元 素 进 行随机 存 取 。

例如 ,对 应 表 1. 1 的 学生 表 , 可以 采用 CVC++语言中 的 链表 来存储 ,设计 存放 每个元 素

的结点类型StudType 如 下 ,

typedef struct Studnode

{

int noi

char name[8] ;
char sex[2] ;
char class[4] ;

//存储学号

//存储姓名
// 存 储 性 别
//存储班号

struct Studnode * nexti //存储指向下 一 个学生 结 点 的 指针

} StuadType;

// 结 点 类 型

Ca

学 生 表 中 的 每 个 学生记录 采用 一个 StudType 类 型 的 结 点 单独存储 ,一 个 学生 结 点 的

next 域 指向 迎 辑 结构中 它 的 后继学 生 记录 对 应 的 结 点,从 而 构成 一个链表 ,其 存储 结构 如

图 1.8 所 示 , 首 结 点 的 指针 为 head, 用 它 来标识 整个学生 链表 , 尾结 点 的指针 域 为空。

数据 结构 教程

虹 第 5 【版

head | 1

张 碘

男

9901

| 8 刘丽 | 女 | 9902

人| 34

李 英

女

9901

| 20

陈 华

男

9902

“| 12

| 王奇 | 男

| 9901

| 26 董强

男

9902

| 5

王 萍

女

9901

人

图 1.8 学 生 表 的 链表 存储 结构

由 head 所 指 结 点 的 next 域 得 到 下 一 个 结 点 的地址 ,然后再由它 得 到 下 一 个 结 点 的地

址 ...... 这 样 就 可以找到任何 一 个结 点的地址,所以 head 标识 的 链表 是学生 表 的 一种链 式 存

储结构 。

3 未必依结糙

索引 存储 结构 (indexed storage structure)

是指在存储数据元素信息的同时 还 建立附加

相 存储所有 数据 元 素 信息 的 表 称 为 主数据 表 ,其 中 每个数据 元素有 一 个关键字和

要避 表中 的 得项 称 为 索引项,索引项的一般形式为 “关键字,地 址 ,其 中"关键字?唯

一标识 一 个 元 素 “ 地 址?对 应该关键 字 的 元 素 在 主 数据 表 中 的 存储 地 址

。通 常,索引表中的

所 有 索引 项 是 按 关 键字有 序 排列 的 。

在 按 关 键 字 查 找时 ,首先 在 索引 表 中 利用 关键 字 的有序 性 快速查找 到 该 关键 字的地 址 ,

然后通过该地址 在 主 数据 表 中 找到 对 应 的 元 素 。

索引 存储结Ce 其缺点 是需要 建立索引 表 , 从 而 增加 了空间开销 。

ET storage structure)

的基本思想是根据元素的关键字通

过 哈 希 (或 散 列 ) 函数 直接计算 出 一个值,并 将 这 个值作为该 元素的 存储 地 址 。

哈希存储结构 的 优点 是 查找 速度 快 ,只 要 给 出待 查 元 素 的 关键 字就 可立即计算 出 该 元

素 的存储地址。与前 3 种 存储 方法不同 的是, 哈 希 存储 方法只 存储 元 素 的 数据 ,不 存储 元 素

之 间 的 逻辑关系。哈 希 存 储结构一般 只 适合 要求对 数据能 够 进行 快速 查找和 插入的场合。

上 述 4 种 基本 的 存储 方法既 可以 单独 使 用 ,也 可以组 合 使 用。同一种 逻辑结构 采用 不

同的存储 方法 可以得 到 不 同的 存储结雪构 。选 择 何种存储结构来表示相应的
逻辑结构 视 具体 要求 而定 ,主 要 考虑 的 是运算 方便 及 算法 的时空要 求 。

扫 -时
二

114 数据运算

数据 运算 是 指对 数据 实施 的 操作 。 每种数据结构 都有一 组 相应 的 运

PASS洛论 |

算 ,最 常用 的 运算 有 检索 .插入\ 删 除,更新和 排序 等 。数 据 运算 最 终 需 要 在 对 应 的 存储 结构

上 用 算法 实现 ,所以 数据 运算 分为运算 定义和 运算 实现 两 个层面 。

运算 定义 是 运算 功能 的 描述,是 抽象 的,是 基于 风 辑 结构 的 。运 算 实 现 是 程序 员 完成 运

算 的 实现 算法 ,是 具体 的 ,是 基于 存储 结构 的 。这 种 将 运算 定义和 运算 实现 相互分离 的 做 法

体现了 软件 工程 的 思想 ,更 加 便于 软件 开发 。

逻辑 结构 存储 结构和 运算 三 者 之 间 的 关系如 图 1.9 所 示 。

对 于 学 生 表 这 种 数据结构 可以 进行 一系列

的 运算 ,例如 查找 逻辑 序号为 2 的 学 生 的 姓名、 | 这 站 定义
插入 一 个学生记 录 和 删除一个学生记 录 等 。

这站 现
本

以“查找逻辑序号为 2 的学生 的 姓名”运算

四

定义 为例,其 运算 实现 有以 下 两 种方式 。 | 二| 存傅结风

如 果 采 用 顺序 存储 结构 一 -Stud 数组 ,由
于 逻辑 序号 为 2 的学生记录 存储在Stud[1]数组
元素中 ,可以 直接找到 Stud[1],通过 Stud[1] 之间的关系

图 1.9 逻辑结构 存储 结构和 运算

TI

.name 返回其姓名 , 即 * 刘 丽 ”。

如 果 采 用 链 式 存储 结构一-head 链表 ,需要 遍历 该 链表 ,用 ; 记录 查找 结 点 的 逻辑 序

号 , 思 一 head 首先指向 首 结 点 ,一 1。由于 ; 夭2,一少一> next 移 到 下 一 个结 点 ,同时 守 增 1

变 为2。此时 ;二 2, 记 指向 的 结 点 就是要 找 的 结 点 ,返回 2 一> name,即“刘丽”。

从 中 可以 看出,对 于 一 种 数据结构 ,其迎辑结构 总 是 唯一的,但 它 可 能 对 应 多 种存储 结

构 , 并 且 在 不 同 的 存储结构 中 同一 运算 的 实现 过 程 可 能 不 同 。

115 数据 类 型和 抽象 数据 类 型

数据 类 型和抽象数据 类 型是与 数据结构 密切 相关 的 两个概念 ,容易 引

起混淆 。 本 节 介绍 这 两个概念 。

在 用 CVC++ 语 言 编写的 程序中 必须 对 出 现 的 每 个变量 常量或表达 式

明确 地 说 明 它们 所 属的数据类 型 。

“站膏束油
训帮

不 同 数据 类 型的变量,其 取 值 范围和所 能 进行的运算 可 能 不 同 。例如 ,C/C++语言有一

个 int 数据 类 型 , 它的取 值 范围 为 一 32768一32 767(16 位 系统 ), 可 用 的 运算 有 十 、 一

、* 、/

和 凶 等 。所以 ,以 下语句 是 正确 的 ,

inti 一 2,j 一 5,k;
上 一 计 j;

而以 下 语句 是 不 正确 的 :

int i 一999999999;

/int 类 型 的数据 取 值超界

ix

/Wint 类 型不存在该运算 符

aa

所以,数据类型(data type) 是 一组性质相 同的 值的 集合和 定义在 此 集合 上 的 一组操作的总

数据 结构教程

[第! 5 【版

称 , 是 某 种程序 设计语言中 已空现的数据结构。在 程序 设计 语言 提供 的 数据 类 型 的 支持下 ,

就 可以 根据 从 问题中抽象 出 来的各 种 数据 模型 逐步 构造出描述 这 些 数 据模型的各 种 新 的 数

据 结构 。

1) CVC++语言中常用的数据类型

CVC++语 言的数据 类 型 按照取 值 的不同 分 为原子 类 型和结构 类 型 。原 子 类 型 是不可 以

再 分 解的基本 类 型; 结构 类 型是由 若干数据 类 型组合 而 成 的,是 可以 再 分 解 的 ,如 数组 、 结

构 体 等 。下 面对 CVC++ 语言中 常用 的 数据 类 型 进行 总 结 。

(1) C/VC++ 语言中 的 基本 数据 类 型 。

CVC++ 语 言中的 基本 数据 类 型有 int 型,bool 型 (布尔型) .float 型.double 型和 char

无符号整数) 。
型 。int 型 可以 有 3 个修饰符,即 short(短整数),long(长整数)和 unsigned(

数据 类 型 是 用 来定义 变量 的 ,例如有定义语句:

int n一10;

在 执行 该 语句时 ,系统 自动 为

变量 在计算机存储器
中 分 配 一 个 国定 长 度 (如 4 个 字 节 ) 的 存储 空间,如 图 1. 10

所示 ,程序员可以 通过 变量名交 对 这 个 内 存 空 间 进行存取
操作 , 当 超出其作用 范围时 系统 自动释放 其 内 存 空间 ,所

以 称 之 为 自动变量(automatic variable) 。

内存

“

世

语言中的指针类型 。
(2) CVC++

图 1.10 为变量 ”分 配 存储 空间

CVC++ 语言允许 直接对 存放 变量 的地址 进行操作 。

例如,有以下定义,

int ji 关 Di

其 中 导 是 整 型变量 ,尹是 指针 变量 (它用 于 存放 某 个 整 型 变量 的 地 址 )。表 达 式 &&; 表示变

量; 的 地 址 ,将 户 指向整型变量; 的运算为避一区i。

对 于 指针 变量 刀 ,表达式* 刀 是取刀所 指 变量 的 值 ,例如 ,

int i 一 2,* p一区i;
printf("% dvn" xp)

上 述 语句 执行 后,其 内 存结构 如 图 1. 11 所 示 ,通过 * 祖 输出 变量 ; 的值,即2。

语言中的数组类型 。
(3) CVC++

ee

叶 于

2

数组 是同一 数据 类 型 的一组 数据 元 素 的 集合 ,在 C/C++语

图 1.11 指针 变量 户 指向

整型变量

言 中 定义 数组 时 需要 指定 数组 大小 , 即 数组 中 存放 的 最 多 元 素

个 数。数 组 分 为 一维数组和多 维 数组 等 。数 组名用 于标识 一 个

数组,下标 指 示 一 个 数组 元 素 在 该 数组 中 的 位 置 。

数组 下标的 最小 值 称 为下界 ,在 CVC++语言中总是 为 0。数组下 标的 最 大 值 称 为上界 ,

在 C/C++语 言中数组上 界 为数组的大小减 1。例如,int aL10] 定义了 包含 10 个 整数的数组

a, 数 组 元 素为cL0]一a[9] 。

@ 理

PASS人当论 |

(4) CVC++ 语言中 的结构体类 型 。

结构 体 类 型是由 一 组 被 称为结构 体 成 员 的 数据 项 组 成的,每个结构 体 成 员 都有自己 的

标识 符 , 也 称 为 数据 域 。一 个 结构 体 类 型中所 有 成 员 的 数据 类 型 可以 不 相同。例 如 ,以下声

明了 一 个 Teacher
结构体类型

struct Teacher

int no

// 教 师 结构体类型
// 成 员 编号,占 4 个 字 节

char name[8] ;

//成员姓名 , 占 8 个 字 节

int age;

// 成 员 年 龄,占 4 个 字 节

{

)

以 下 语句 定义了 结构 体 类 型 Teacher 的 一 个结构体变量 : 并 赋值 :

Struct Teacher t;

t.no一85;
strcpy(t. name,"张敏") ;

t.age一42;

结构体变量 : 在 内 存 中 的 存放 方式如 图 1. 12 所示, 了

引用 no 成 员 的 方式是tno, 引 用 name 成员的 方式是

tname,引用 age 成员的 方式是t age,所有成员相 邻 存

85

避

玫光

张 伍

me

四

2]

ae

放。z 变量 所 分 配 的 内 存 空间 大小 为所有 成 员 占 用 的 内 图1 12 结构 体 变量 在 内 存 中 的
存 空间之和 。

存放 方式

(5) CVC++ 语言中 的 共用 体 类 型 。

共用 体 是 把不同 的成员 组 织 为 一 个整体 ,它们 在 内 存 中 共享一段存储 单元,但不同成员

以 不 同 的 方式 被 解释。例如,声明一个共用体类型Tag 如下 :

union Tag

/Tag 共用 体

short int ni

char ch[2] ;

{

)}

// 成员 n,占两个字节

// 成员 ch 数组,占两个字节

以 下 语句 定义了 共用 体 类 型 Tag 的 一 个共用体变量 " 并 赋值 :

union Tag ui
u.n 一0x4142;

这种直接赋值是错误的
// 若为u=0x4142;

共用体变量 x 在 内 存 中 的 存放 方式 如 图 1. 13 所 示 , 引 用 守 成员的 方式是x.2, 引 用 ch

Rssssa

成 员 的 ch[0]元素的方式是x. chL0],” 和 ch 成员共 享 相

2 0 ),
LEE 员 占 用 空间 的 最 大值。

同的内 存 空 间

。x 变量 所 分 配 的 内 存 空间大小 为所有 成

ch

csh[0

(6) C 语言中的自定义 类 型 。

图 1.13 共用体变量 v 在 内 存 中 CVC++语言中允许使用 typedef关键字来指定一个
新 的 数据 类 型名,例如 :

的 存放 方式

数据 结构教程

[第! 5版

typedef char ElemType;

将 char 类 型与ElemType 等同起 来 ,特别 是 将代码 较 长 的 结构体 类 型声明 用 自 定义类

型标识 符 来 代替 ,这 样可以 简化 代码。例如:

typedef struct Student

{

int no

char name[10] ;

char sex;

int cno;

NewType;

//Student 结构体类型

//学号成员

//姓名成员

//性别成员

//班号成员

//用NewType 别名 表示 Student 结构体类型

这 样,NewType 等同于 Student 结构体类 型 ,可 以 使用该类 型定义变量:

NewType sl1,s2;

等同于,

struct Student s1 ,s2;

2) 存储 空间 的 分 配

在 程序 设计中 ,定义 变量 就 是 使 用 内 存 空 间 ,而 存储 空间 的 分配 主要有 两种方式 。

(1) 静态 存储 空间 分 配方式。

所 谓静 态 存储 空间 分 配方式是指 在 程序编译 期 间 分 配 固定 的 存储 空间的 方式 。该 存储

分 配方式通常 是 在变量 定义时 就 分配存储 单元 并 一 直 保持 不变, 直 至 整个 程序 结束 。以定

义 一 个数组为 例 , 如 下语句就采用了 这 种方式,

int a[10] ;

一旦遇 到 该 语句 ,系统就为 c 数组 分配 10 个 int 整数 空间。无 论 程序是否向 ac中放和人

元素, 这 一 片 空间 都 被

占用。它 也 属于 自动 变量, 当超出其作月

日 范围时系统 自动 释放其内存

空间。

(2) 动态存储 空间 分配方 式 。

所 谓 动态存储 空间 分 配方 式是指 在 程序 运行 期 间 根据 需要 动态地 分 配 存 储空间 的 方

式 。C/VC++语言 提供了一套机 制可以 在 程序 执行时 动态 分配存储 空间,如 malloc()Vfree()

函数对。即 使用 malloc() 函数 为一个 指针 变量(如 指针 ) 分配 一 片 连续 的 空间 , 当 不 再 需

PE

要 时 使用 free()表数释放 尹 所指向的空间。例如 :

char 关 pi;

p一(char * )malloc(10 * sizeofCchar));

//动态分配 10 个连续的字符空间

strcpy(p, "China");

printf(" 吧 cn" ,xp);

printf("%sNn",p);

free(p);

// 将"China"存放到 p 所 指向 的空间 中
// 输 出 字符C

// 输 出 字符 串"China"
// 释 放 p 所指向的空间

(2

PASS论 |

上 述 代码 先定义 一 个 字符 指针 变量 ,然后 使用 malloc() 函数 为 其分配长度为 10 个 字

符 的 存储 空间 ,将 该存储 空间 的 首 地 址 赋 给 ,再 将 字符 串 "China"放 到 这 个 存储 空间中 ,如

图 1.14 所 示 。 所 以 第 1 个 printf 语句 输出 的 是 首 地 址 的 字符 ,即'C'" ,而第 2 个 printf 语句

输出 的 是 整个字符 串 ,即"China " 。

转换为字符指针 分 配 的字符个数

加

交

10 个 字符 空间

DP=(char *)malloc(10*#sizeoflchar)):
|
为指针 变量

求每个 字符 占用 的空间 大 小

一>

一上一ChinaW

变 量 空间

]
Z所指向的空间

图 1.14 为指针 变量 请 分 配指向的空间

注意: 在上述 代码 中 ,指针 变量 尹属于 自动变量 , 它自身 的存储 空间 由 系统 自动 分配和

释放 ,但 用 malloc()

函数分配的存储空间(也 就是户 指 向 的 存储 空间 ) 不 会 被系统 自动释

放,所以最后需要加上 free(p)语句用 于 释放 户 所指向的存储空间 。

这 种 动态存储 空间 分 配方 式的优点 是 不 需要 预先 分 配 存储 空间 ,分 配 的 空间 可以 根据

程序 的需要 扩大 或 缩小,如 链 式 存储 结构 通常 采用 动态存储 空间分 配方 式 。其缺点是需要

程序员 简 单 地管理 内 存 空 间 ,也 就 是用 malloc() 丽 数动态分配 的 空间 ,在 后 面 一定要 用 free()

函数 释放 ,和否则 动态 分 配 的 空间对 于 程序 而 言 就 丢失了 ,久而久之可能会造成内存泄露。

2 捕 象数据类型

盾 条 数据 绒 型(Abstract Data Type,ADT)指的是 用 户 进行软件 系统 设计时从问题的

数学 模型中抽象 出 来的逻辑数据 结构和 逮 辑 数据 结构 上 的 运算,而不考虑 计算 机 的 具体 存

储 结构和 运算 的 具体 实现 算法。抽 象数据 类 型中的 数据 对 象和数据 运算 的声明 与 数据 对 象

的 表示 和 数据 运算 的 实现 相互分离 。

一 个 具体 问题的抽象数据 类 型 的定义 通常 采用 简洁 .严谨 的 文字 描述 ,一般包 括 数据 对

象(即 数据 元 素 的 集合) 数据 关系和 基本 运算 三 方面的内 容。一 个 抽象数据 类 型可用

(D,S,P)三 元组表示 。 其 中 ,D 是 数据 对象,S

是 D 上 的 关系 集 , 已是了 中 数据 运算 的 基本

运算集。

抽象 数据类 型的基本 描述格式如下 ,

ADT 抽象 数据 类 型 名
{ 数据 对 象:数据对象的声明
数据 关系 : 数据 关系的声明
基本 运算 : 基本 运算 的声明

)}

其中 ,基本 运算 的 声明 格式 为 :

基本 运算 名 (参数表) : 运算 功能 描述

基本 运算有 两 种 参数 ,其 中 值参数 只 为 运算 提供 输入 值 ,引用 参数以

发 打头 ,除了可提

供输入 值 以外 ,还 将 返回运算 结果 。

ss

数据 结构教程

[第! 5版

例如 ,一 个 复数 的 抽象 数据 类型Complex 的定义如下 :

ADT Complex
{ 数据 对 象 :

万 = {el,ez| el ez 均 为实数 }

// 一 个复数由e 和 e: 两个实数 构成

数据 关系 :

R={<elez> | el 是 复数的实数 部 分,ez

是复数的虚数部分 }

//el 和 ez 在 复数 中 的 逻辑 关系 是 <el ,ez >

基本 运算 :

AssignComplex(& xz,zl,v2): 构造 复数 =, 其 实 部和虚 部 分 别 为 参数zl 和 2 的值。
DestroyComplex( 了&&z) : 销毁 复数>。
GetReal(z, &real): 用 real 返回 复数 的 实部值。

GetImag(z, &imag): 用 imag 返回 复数 > 的 虚部值。

Add(zl,z2,&sum): 用 sum返回两个复数 1 \.z2 相 加 的 结果。

)}

抽象 数据类 型有两 个重要 特征 , 即 数据 抽象和数据 封装。所谓 数据 抽象 ,是 指用ADT

描述 程序处理 的 实体时 强调 的 是其本 质 的 特征.其 所 能 完成 的功能 以 及它和 外 部 用 户 的 接

口 (即外 界 使用它 的 方法) 。 所 谓 数据封装 ,是 指 将 实体 的 外 部 特性和其 内 部 实现 细节 分 离 ,

并 且 对 外 部 用 户 隐 藏其内 部 实现 细节 。

从 数据 结构 的 角度 看 ,一 个 求解问题可以 通过 抽象数据 类 型 来描述,也 就 是说,抽象 数

据 类 型对一 个 求解 问题从 巡 辑 上 进行了准确 的 定义,所 以 抽象 数据 类 型 由 数据 迎 辑 结构和

运算定义两部分组成。抽 象 意 味 着 一 个 抽象 数据类 型 可能有 多 种 实现 方式 ,ADT 和 ADT

的 实现 如 图 1. 15 所示。抽 象 数据类 型需要 通过国有 数据 类 型 (高 级 编程语言中 已 实现 的 数

据 类 型 ) 来实现 。

ADT

ADT的实现

图 1.15 ADT 和 ADT 的 实现

RS

术
算法 及 其 描述

;

|
放

本 节 先 给 出 算法 的 定义 .算法 特性和 算法 设计 的 目标 ,然后讨论 算法 的

描述 方法 。

121 什么是算法

算法 (algorithm)是对特定问题 求解步骤 的 一 种描述 , 它 是指令 的 有 限

4

序列。其 中 每一条指令 表示 计算 机 的 一 个或多 个 操作。例 如 ,以下是 求解 两 个 正整数 盖 和

PASS人论 |

7 的最大 公约 数 的 算法 :

(1) r 一 7 mod 7 。

(2) 若 > 一 0, 输出最大 公约数 ”算法 结束 。

(3) 若 r 径 0, 令 =22一r,转(1)继续。

一 个算法应该具有以下 5 个重要 的特性 。

(1) 有 穷 性 : 一 个 算法 必须 总 是(对任何 合法 的 输入值 ) 在 执行 有 穷 步 之 后结束, 且每

一 步 都可 在 有 穷时间 内 完成 。任 何不 会 终止的 算法 都 是 没有意义 的 。

(2) 确定性: 对 于 每 种情况 下 执行的操作 在 算法 中 都 有 确切 的 规定 ,使 算法 的 执行 者

或 阅读 者 都能明确 其 含义及 如 何 执行,并 且 在任何 条 件 下 算法 都 具有 一 条 执行 路径,即对 于

相同 的 输入只 能得 出相同 的 输出 ,不 能 有 二 义 性 。

(3) 可行性: 算法 中 的所有 操作 都 必须 足够基本 ,算法 可以 通过有 限 次 基本 操作 来 完

成其功能 ,也 就 是说 算法 中 的 每 一 个 动作能 够 被机械 地 执行 。像 前 面 求 最 大 公约 数 的 算法

中 ,每 一 个操作 都是基本 操作 ,都可以 用纸和 笔 在 有 限时间 内 完成 。

(4) 有 输入 : 作为 算法 加 工对 象的量 值,通 常体现 为 算法 中 的 一 组 变量。一 个算法有

零 个 或者多 个输入 。

(5) 有 输出 : 一组与 “输入”有 确定对 应 关系 的 量 值,是 算法 进行信息 加 工后得 到 的结

果 , 这 种确定 关系即 为 算法 的 功能。一 个 算法 有 一 个 或者多 个 输出 。

说明: 算法和 程序 是有区 别的,程序 是指使 用某种计算 机 语言 对 一 个 算法的具体 实现 ,

即 具体 要 怎么 做 ,而 算法侧重 于 对 解决 问题 的 方法描述 ,即 要 做 什么 。算 法 必须 满足有 穷

性 :而程序 不 一定满 足 有穷 性,如 Windows 操作 系统在用 户 没有退出、硬件 不 出 现 故 障 以及

不 断 电 的 条件 下 理论上可以 无限时 运行 ,所 以 严格地 讲 算法和 程序 是 两 个 不同的 概念 。当

然 , 算 法也可以 直接 用 计算 机 程序 来描述,这样 算法和 程序 就是一 回 事了 ,本 书 就是采用这

122 算法设计 的 目标

算法 设计 应满足以 下 几 个 目标 。

(1) 正确性: 要 求 算 法 能 够 正确 地 执行预先 规定的 功能和 性 能 要 求 。

这 是 最 重要 也 是 最 基本 的标准 。

视顺计角

(2) 可使 用性: 要 求 算法 能 够 很 方便地 使 用 。这 个特性 也叫 用 户 友好 性 。

03) 可读 性 : 算法 应 该易于 使人理解,也 就 是可读 性好。为了达到 这 个 要 求 , 算 法 的 逻

辑 必 须 是清晰 的 、 简 单 的和结构 化 的 。

aa

(4) 健壮性: 要 求 算法具有很好 的 容错 性 ,即 提供 异常处理 ,能 够 对 不 合理 的 数据 进行

检查 ,不经 常 出 现 异 常中断 或 死机 现象 。

(5)

高 效率 与 低 存储量需求: 通常 算法 的 效率 主要指 算法 的 执行 时 间。对 于 同一个问

题 ,如 果 有 多 种 算法 可以 求解,执行 时间 短 的 算法 效率 高 。算 法 存储 量 指 的 是 算法 执行 过 程

中 所 需 的 最大存储 空间。效率和 存储 量 都 与 问题的规模有 关 。

数据 结构教程

[第! 5版

123 算法 描述

描述 算法 的 方式 很多,有的 采用 类 Pascal 语言,有的 采用 自然语言伪码 ` 流 程 图 或者表

格 方式 等 ,但对于 计算 机 专业 的学生 应 该 熟练 使用计算 机 语言 来描述 算法。本 书 采用

CVC++语言来描述算法 。

全 和全 法 持 述的二 有 格式 和 有认证 稍 束

通常用CVC++

末数来描述算法。算 法 描述 的一般 格式如 下 :

返回值 算法 对 应的函数 名 ( 形 参列 表 )
{ 临时 变量 的 定义

实现 由 输入参数 到 输出参数 的 操作 。” 函数体

)》

视频讲解

其 中 ,返回 值?通常为 bool 类 型 ,表示 算法 是 和否成功执行;“形 参列表”表 示 算 法 的 参数 ,由

于 算法 包含 输入和 输出 ,所 以 形 参列表 由 输入 型 参数和 输出 型参数 构成 ; 函数体实 现 算法

的 功能 。

一 个 算法 通常完成某个 单一的功能 ,算法 设计 的 一 般步骤 如 下

(1) 分 析 算 法 的 功能 。

(2) 确定 算法 有 哪些输入 ,将 这 些 输入设计 成 输入 型参数 ; 确定 算法有 哪些输出,将 这

些 输出 设计 成输出 型参数 。

(3) 设计 函数 体 ,完成 从 输入到 输出 的 操作 过 程 。

在 设计 算法 时 ,输入 型参数 的 设计 是 十分简单的,那么输出 型 参数 如 何 设计 呢 ? 下 面 通

过 一 个 示例 进行说明 。

例如 设计 一 个 交换 两 个整数 的 算法 ,编写相应 的 函数 swapl(z,y)如下:

void swapl(int x,int y)

int tmp;

tmp二Xi; X一yi; y 一tmp;

{

)》

在 该 函数 中 的 确实现了 两个形参 zx 和 y 的 值 交 换 , 但 调用 该 算法 (也 就是执行 语句

swapl(a,0))时发现 ac 和 2 实 参 值 并 不 会发生交换。出 现 错误 的 原因 是 这 里 的 形参z、y 既

是 输入 型参数,也 是 输出 型参数 ,而 swapl(Cz,y)

中仅仅将形参zy作为输入型参数设计。

改正 方法1: 采用 指针 的 方式来回 传形参 的 值 ,将上 述 函 数 改 为如下 。

void swap2(int <X,int 关 y)

{

int tmp;
tmp一* Xi
闪 X 一 关 y1
< 了 一 tmp;

//将x 所 指 的 值 放 在 tmp 中
//将x 所 指 的 值 改 为了>所指的值
//将了 所 指 的 值 改为tmp

(ie

PASS论 |

这 样调用 该函数的方式改为swap2(&a,&0) ,其中,& ao、&2 分 别 是 实 参w 2 的 地 址 ,

显然改正后的算法 swap2() 比 较 复杂 ,可 读 性 差 。

改正 方法2: 采用 引用 型形参,也 就 是将输出型形 参 设计 为 引用 类 型形参 。

在 C++语言中提供 了 一 种 引用 运算 符“ 攻>”。当 建立 引用 时 ,程序 用 另 一 个 已定义 的 变

量(目标 变量 ) 的名字 初 始 化它, 从那时起 ,引用 变量 作为 目标变量 的别名 使用,对 引用 变量

的 改动 实际 是对 目标 变量 的 改动 。例如 :

int a 一 4;

int &b一ai

// 定 义 整 型 变量 a

// 定 义 整 型 变量 a 的 引用 变量 b

第 2 个语句 定义2 变量是变量 的 引用 变量 也 等于 4, 之后这 两 个变量 同步改变 。

引用 常用 于 天 数形参 中 , 当 采 用 引用 型 形 参时 ,在 函数 调用时 会 将 形 参 的 改变回 传给实

3

。 利 用 引用 运算 符 将 swapl()改为如下

void swap(int &x,int &y)

// 形 参 前 的"&&" 符 号不是 指针 运算 符 ,而 是 引用

int tmp一xi;

X 一 y; y 一tmp;

{1

)}

当 执行 语句swap(a,O) 时 , 形 、 实 参 的 匹配 相当于:

int &x一ai

int &y一b;

//x为a 的 引用

//y为b的引用

这 样,a 与 共享存储 空间,0 与> 共享存储 空间 ,因此 执行函数 后 和 2 的 值 发生了 交

换。这 种 改进 方式 十 分 简单 ,所以 本 书后 面均采用 这 种 方式 设计 算法 。

【例1.5】 设计 一 个 算法 , 求 一元 二 次 方程 cz? 十oz 十 c=0 的根。

该 算法的输入为c.2 和 ,输出 为 根 的 个数和 两 个根, 将 c`.2 和 作为输入型形参,采

用 函数 的 返回值表示 根 的 个 数,用 两 个 引用 型 形参zl 和 z2 表示两个根。对 应 算法 的描述如下

int solution(double a, double b,double c,double &xl1,double &x2)

{

, double d;

d 一 bxb 一 4#axci

于 Cd>0)
{ 对 一 (一 b 十sqrt(d))/(C2xa);
x2 一 (一 b一sqrt(d))/(2* a);
return 2;

// 两个实 根

}

else 让 (d 一一0)

{

, 双 一 (一bDD/(2xa);

Teturn 1 ;

/一个实根

}
else

Teturn 0;

//d<0 的 情况

// 不 存在 实 根 ,返回0

Sa

数据 结构教程

[第! 5人版

算法 分 析

米

在 一 个 算法设计 好 之 后 ,还 需要 对 其 进行分析,确定一个算法的优劣。本 节讨 论算法的

时 间 复 杂 度 和 空间 复杂 度 分 析 。

131 算法分析概述

算法 分析就 是 分析 算法 占用计算机资源的多少。而计算 机 资源主要 是

CPU 时 间 和 内 存空间 , 分 析算法占用 CPU 时 间 的 多 少 称 为 时 间 性 能 分 析 ,

分 析 算 法 占用 内 存 空间 的 多 少 称 为 空间 性 能 分 析 。

算法 分 析 的 目的 是 分 析 算 法 的时 空 性 能以便 改 进 算 法 。

132 算法 时 间 性能 分析

于六时间作作分析方法。

通常有两 种 衡量 算法 时 间 性 能 的 方法 , 即 事后统计法和 事前 估算 法 。

|

季 后统计 法 就 是编写 算法 对 应 程序,统计 其 执行时间。一 个算法用计

算 机 语言实现后,在 计算 机 上 执行 所 消耗 的时 间 与 很多因素 有 关 , 如 计算 机 的 运行 速度、 编

写 程序 采用 的 计算 机 语言 编译产生 的 机 器 语言 代码 质量和 问题 的规模 等 。这 种 方法 存在

的 缺点有两个 ,一 是 必须 执行 程序,二 是 存在 很多因素 掩盖了 算法 本 质 。

由

生前佑 算法 是 抠 开 这 些 与计算 机 硬件 、 软件有 关 的 因素 , 仅考虑 算法 本 身 的 效率 高 低 ,

可 以 认为一个 特定 算法 的 “运行 工作量” 的 大小 只 依赖于问题 的 规模 (通常 用

整数羡表示 ),

或 者 说 算法 的 执行 时间 是 问题 规模 的 函数 ,因此 后 面主要 采用 事前 估算 法 来分析 算 法 的 时

间 性 能 。

2 算法时间复亲度信术

1) 计算 算法 的 频 度 ED

一 个 算法是由 控制结构 (顺序 .分支和 循环 3 种)和 原 操作 ( 指固有 数据 类 型 的操作 ) 构

成的。例 如 ,在以下 算法 中 ,语句四.@ .加 和 加 就是原 操作

void fun(int a[] ,int n)

人

int 让

for (i=0ii<nii十十)

a[ 癌 一 2* 时

for (i 王0;i<nii十十)

printf("%d",a[果);

printf("\n' );

)》

/DO

//@

//@

//@
//@
//@

而 算法 的 执行时间 取决于控制 结构和 原 操作 的 综合效果。显 然,在 一 个 算法 中 执行 原操作

的 次 数 越 少,其 执行时间 也 就 相对 越少; 执行原操作 次 数越多 ,其 执行 时间 也 就相对 越 多 。

(ns】

PMAS 人论 |

也 就 是说,一 个 算法 的 执行 时间 可 以 由 其 中 原 操作 的 执行次数 来计量 。

假设 算法 的 问题规模 为2,如果对 10 个 整数 排序 ,问题规模”就是10。 算 法时 间 分 析

的 就是求 出 算法所有 原 操 作 的 执行次数(也 称 为 频度), 它 是问题 规模盖的 函数,用T(z)

表示。

算法 执行时 间 大 致 等 于 原 操 作 所 需 的时 间 XT(z) ,也 就是说 T(z) 与算法的执行时间

成 正比 ,为此用 T(z) 表 示 算 法 的 执行 时 间 ,比较不同 算法的 T(0z) 大小得 出 算法 执行时间 的

多少。

【例 1.6】 求 两 个 阶 方阵4、B 相加C=4十也 的 算法如 下 ,计算 其 执行时 间 TOz)。

# define MAX 20

// 定 义最大 的 方 阶

void matrixadd(int n,int ALMA [MA芭 ,int BLMA区[MA ,int CLMA[MA)

{

intiji;

for (i=0;i<ni;i十十)

for (=0;j<nj;j十十)

CD中胃 =A呈中十B品中;

)}

// 语 句 @

// 语 句 加

// 语 句 回

如 果 不 考虑 变量 定义语句 ,该 算法 主要 包括 3 个 可 执行 语句四、@ 和 回。其 中 语句

外 循环控制 变量;要从 0 增加到 ”测试 ;一允时 才 会 终止,故它的 频 度是 > 十 1,但 它 的 循环

体 却 只 能执行闻次 。语 句 四 作为语句@ 循 环体内 的 语句 应 该只

执行冯次 ,但 语句@ 本 身 也

要 执行 ?十1 次 ,所以语句 加 的 频 度是zz十1) 。同理可 得 语句 图 的 频 度 为 刀。因此,该算

法 中所有 语句 的 频 度 之和 ( 即 执行时 间 ) 为

TOz) 一 允 十 1十202 十1) 十 于 王 22 十 22 十 1

2) TCn)用"0表示

由 于 算法 分 析 不 是 绝对时 间 的 比较 ,在 求 出 T(z) 后 ,通常进一步采用 时 间 复 杂 度 来 表

示。算 法 时 间 复 杂 度 (time complexity)就是用T(”) 的数量级来表示 ,记作 T(z) 一

OCFCz)) 。

在 上 述 表达 式 中 “0O? 读 作 * 大 O”(是Order 的 简写 , 意指数 量 级),其含义 是为T(z)找

到 一个上界 Foz) ,其 严格 的 数学 定义是T(Cz)
,是指存在 着正常量
< 和 必 ( 为 一 个足够 大 的正整数), 使 得 lim| oo 一<关0 成 立。所 以 算法时间 复杂 度 也称

的数量级表示为OCF(Cz))

为 渐进时间 复 杂 度 , 它 表 示 随问题规模 的增 大 ,算法 执行 时间 的增长 率 和 Foz) 的 增长 率

相同。因 此 算法 时 间 复 杂 度 分 析 实际上 是 一 种 时间 增 长 趋势分析 。

显然,T(z) 的 这种上界 Faz) 可 能 有 多 个 ,通常取 最 紧凑 的 上 界。也 就 是只求 出 TCD)

aa

的 最 高 阶 ,忽略 其低阶 项和 常系数 ,这 样 既 可 简化 T(z) 的计算 ,又 能 比较 客观地反映 出 当 ?

很大时 算法 的时 间 性 能

。例 如 ,对于例1.6 有 T(o) 一 22 十22 十 1 一O02 ) ,也 就 是说 ,该 算

法的时间 复 杂 度 为 OC02) 。

一般情况下 ,一 个 没有 循环 (或 者 有 循环,但 循环次 数 与 问题 规模 无关)的算法中原操

作 执行次数 与问题 规模 无关 ,记作 O(1) ,也 称 为 常数 阶。算 法 中 的每个 简单语句 ,例如定

义 变量 语句 、 赋 值 语句和 输入 输出语句 ,其 执行 时间 都 看 成是O(1)。

数据 结构教程

[第! 5人版

一 个只有 一 重 循环的 算法 中 原 操作 执行次数 与 问题 规模 的 增长 呈 线 性 增 大 关系 , 记

作 OCz) ,也 称 线性 阶 。

其 余 常用的还有 平方阶 OO2 ) 立方阶DG )、 对 数阶OClog:z) 、 指 数阶O(2")等,各种

不 同 的时间 复 杂 度 存在 着以下关系 :

O(1) 二 O(ogsz) 二 OCOD) 二 OOzlogz7) 一 002) 一 002) 一 OC2) 一 OGO2z)

将 O(log:z) .OCD) 、OClogs)、.OG02)和O0s)等称为多 项式时 间 复 杂 度(polynomial

time complexity) ,将 O(2") 和 O(Cz1) 等 称 为 指数时间 复 杂 度(exponential time complexity) 。

一 个问题目前 可以用多 项 式 时间 复 杂 度 的 算法 来 求解 , 称为P 问题; 一 个问题目前 只 能 用

指数 时间 复 杂 度 的 算法 求解 ,称为NP 问题 。NP=了P 是 否 成 立,也 就是说 ,求解NP 问题的

指数 时间 复 杂 度 算法能 否 转换 成用 多 项 式时间 复 杂 度 算法 来 求解,是 目前计算 机 科学 的 难

题之一 。

3) 简化 的 算法 时间 复 杂 度 分析

扫--扫

|

另外 一 种 简化 的 算法时间 复 杂 度 分 析 方 法仅仅 考虑 算法 中 的 基本 操

作。所谓 基 本 操作 是指 算法 中 最 深层 循环内 的 原 操 作。算 法执行时间大致

等于基本 操作 所 需 的时 间 义 其运算次数。所以 在算法分析中,计算 T(z)时

仅仅 考虑 基本 操作 的 运算 次 数 。

对 于 例 1. 6, 采 用 简化 的 算法时间 复 杂 度 分 析 方 法,其 中 的 基本 操作 是 两 重 循环中 最 深

层 的 语句@ ,分 析 它 的 频 度 ,即 :

TOz) 一 姑 一 OGO2)

从 两 种 方法 得 出 算法 的时 间 复 杂 度 均为 0(z) ,而 后 者 的 计算 过 程 简 单 得多,所以后面

主要 采用 简化 的 算法时间 复 杂 度 分 析 方 法 。

【例1.7】 分 析以 下 算法 的时 间 复 杂 度 。

void func(Cint n)

{

int i一 0,s一0;

while (sS<n)

itr+3;
S 一 s 十 让

// 基 本操作

// 基 本操作

{

}

)}

该 算法 的 基本 操作 是 while循环内的语句,设while 循环 执行 的 次 数 为六,变量 从

0 开始 递增1, 直到 和 为止,所以循环结束时 有 一 妈 (十1)7/2 三 2 增加 一 个用 于 修正 的 常

量 &, 则 mm(mz十1)/2十&一2。求出:

BE

册 二 二 1 十 VS 二 1 一 驶

2

所以 ,该算法 的时 间 复 杂 度为OCVn) 。

4) 时 间 复 杂 度 的 求和 、 求积 定理

为 了 计算 算法 的时间 复 杂 度,有以 下 两个定理 。

求和定理: 假设 六 (0 和 T:(z)是程序段 P,、P, 的执行时间,并且 TCD)

一 OCFCz)),

TOO=王OCS8C2))

,那么先执行 Pi ,再 执行 P。 的 总 执行时间是 记 (Cz)十 T(Cz)一

9

PASS论 |

OCMAX(CHFGaD) ,gs(C2o)))。 例如 多 个 并 列 循环 就属于 这 种情况 。

求积定理: 假设 Ti (2z)和 T*(z)是程序段P, 、P, 的执行时间 ,并且 h Co一OCACo)),

屯 (OoD)=OCe0D0),那么下 (OOXX 有 00) 王OCXgGoD))。 例如 多 层 戏 套 循环 就 属于 这 种情况 。

3 算法的最好 必坏 和有平坷时癌复芝 度

扫 一要

设一个 算法 的 输入规模为2%,D, 是所有 输入(实例 ) 的 集合 ,任意输入

TED,,P(CD 是 工出现 的 频率, 有 >)P(D = 1, TCD是算法在 输入工下 所

执行的基本 操作 次 数,则 该算法 的平均时 间 复 杂 度 定义 为

IED,

ECOD) = >)PCD XTCD

TIED,

算法 的 最 好 时 间 复 杂 度 是 指 算法 在 最 好 情况 下 的时间 复 杂 度 ,即 BCz)王MIN{TCz) )。

TIED,

算法 的 最 坏复杂 度 是指 算法 在 最 坏 情况下 的 时间 复 杂 度 , 即 为 页 (=MAX{TCz)}。 算法

TED,

的 最 好 情况和 最坏情况 分 析 是 寻找该算法 的 极端实例 ,然后分析 在 该 极端 实例下 算法 的 执

行时间。

从 中 可以 看出,计算 平均时间 复 杂 度时 需要 考虑所有 的 情况 ,而计算 最好和 最坏时间 复 杂

度时 主要 考虑一种 或几种特殊 的 情况。通 常默认 情况 下 的时间 复 杂 度 是 指 年 均时 间 复 杂 度 。

【例1.8】

以 下算法用于求含”个

整数 元 素 的 序列 中 前 ;1 所 ;过 四 个 元 素 的最大 值 ,

分 析 该 算法 的最好 、 最坏和 平均时间 复 杂 度 。

int fun(int a[] ,int n,int iD

{ intj,max一a[0] ;

for (j王1;j< 一i一1;j 十十)

让 (a[D站> max) max一aD] ;

TeturnCmax) ;

)}

该 算法 中 的整数 序列 用 数组 w 表示 ,前 守 个 元 素 为a[0..i 一I]。;i 的 取 值范围为

1 一 2( 共 寻 种 情况 ) , 当 求前守 个 元 素 的最大 值时 需要 元 素 比 较(i 一1) 一1二 1=;i 一1次。在

等 概率 情况 (每 种情况的概率为1/z)下:

TCD 1 1)

1 > 1) 2 OCD

所 以 该 算法 的 平均时间 复 杂 度为 OCz) 。

最 好 的情况是 ;=1 时 ,没有两个元 素 之 间 的 比较,对 应 的最好 时间 复 杂 度为O(1)。

最 坏 的情况是 ;一双时 ,需要 ”一1 次 两 个元素 之间 的 比较 ,对 应 的 最 坏时间 复 杂 度 为

OGCz)。

东 递 亲 算 法 时间 复 洒 度 信 析

递归 算法 是 指 算法 中 出 现 调用 自己 的 成 分 。递 归 算法 分 析 不 能 采用 前

面 简单的分 析 方 法 ,递归 算法 分析也 称 为 变 长时 空分析 , 非递归 算法 分 析 也

称 为 定 长时 空分析 。

在递归 算法分析 中 首先 写出对 应 的 递 推式, 然 后 求解 递 推 式 得 出 算法

数据 结构教程

[第! 5版

的 执行时间或者空间。下 面通过 一 个 示例讨论递归 算法的时 间 分 析 方法 。

【例 1.9]】 有以 下算法:

void fun(int a[] ,int n,int k)

// 数组 a 共有 nm 个 元 素 ,执行时间为T1Cn,k)

{

inti

迁 (k 一一n 一 1)

{

for (Ci=0;ii<n;i十十)

printf("%dvn",a口 );

// 该 语句 的 执行次数为 n

}
else

{

}

)}

for (Gi=k;ii<nii十十)
a回 一 a[癌 十ix i

funCa,n,k 十 1);

// 该 语句 的 执行 次 数为 n一K
// 执行时 间 为 TICn,k十1)

,求其时间复杂度。
调用上 述 算法 的 语句 为 fun(Ca,z,0)

设 fun(a,z,&)

的执行时间为 Th CazA) ,fun(Cae,z,0)

的执行时间为T(z) ,显然有

To二 Ti,0),由 fun() 算 法 得 到 以下执行 时间 的 递 推式。

了2

TCR) 一

当有& 一 7 一 1 时

(一 A) 十 厂(z 十 1) 其他情况

则 :

T(Oo)

王三(0)一2十 Ti,1)

二 7 十 (2 一1)十 厂 (2 2)

二 7 十 (2 一 1 十 ... 十 2 十研一1)

(2 十 2)(2 一 1)
朵

十 刀

7 37
元 十 沁

1

所以调用 funCa,z,0)

的时间复杂度为OC0z) 。

一 O(Cz2 )

133 算法 空间 性 能 分析

一 个 算法 的 存储 量 包 括 输入数据 所 占 的 空间 、 程序本 身 所 占 的 空间和

临时 变量 所 占 的 空间。这 里 在 对 算法 进行存储 空间 分 析时 只 考察临时 变量

所 占 的 空间 ,例如对 于 如 图 1. 16 所 示 的 算法 ,其 中 临时 空间 为 变量 maxi 占用的空间。

int max(int a[],int m)
[int i,maxi=0;

for (Ci=1;iK=nii+t+)

if (a[i]>a[maxi])

maxi=ii

Teturn a[maxi];

函数 体内 分 配 的 变量 空间
为 临时 空间,不计 形 参 占
用的 空间 ,这里仅计六
maxi变量的空间 , 其窍
复杂度为O()

图 1.16 一 个 算法 的临时 空间

(2

PASS人论 |

所以,算法空间复杂度(space complexity)

是对一个算法在运行过程中临时占用 的 存储

室 间 大小 的 量度。一 般 也作为问题规模?的

函数 ,以 数量 级 形式 给 出 ,记 作

其中 O 的含义与时 间 复 杂 度 中 的 含义相同 。

SC) 一 OCe(C2z))

若 所 需 临时 空间相对 于 问题规模 来 说 是 常数 , 则 称 此 算法 为原地 工作 算法 或 就地工作

算法。

为什么 算法 占用 的 空间 只 需 考 虑 临时空间 ,而不必 考 虑 形 参 的 空间 呢 ? 这 是因为形参

的 空间 会 在调用 该 算法 的 算法 中 考虑 ,例如以下 maxfun 算法 调用 图 1. 16 的 max 算法 :

void maxfun()

intbD

一 (1,2,3,4,5},n一5;

printf("Max一外 dNn",max(b,n));

{

)}

maxfun 算法 中 为2 数组 分配 了 相应 的 内 存 空 间 , 其 空间复杂 度为O(z) ,如 果 在 max算

法 中 再考虑形参 a 的 空间 ,这 样 就重复计算 了 占用的空间。实际上在C/C++语言中,

maxfun 调用 max 时 ,max 算法中形参 o 只 是 一 个 指向 实参2 数组的指针 , 即 形 参 a 只 分 配

一 个 地 址 大小 的 空间 ,并 非 另外 分 配 5 个 整 型单元 的 空间 。

【例 1.10】 分 析 例 1.

6

和 例 1. 7 算法 的 空间 复杂 度 。

在 这 两 个 算法 中 都 仅仅固定 分 配 了 几 个 临时 变量 ,占用 存储 空间 的 大小与问题 规

模 无关, 所以 它们 的 空间 复杂 度 均为 O(1) , 即 这 些 算 法 均 为原地 工作 算法 。

2 递 语 算尖 全癌 复 芝 度 他 入

对 于 递归 算法 ,为了实现递归 过 程用 到 一 个递归 栈 ,所以 需要 根据递归 深度 得 到 算法 的

空间 复杂 度。下 面通过 一 个 示例讨论递归 算法 的 空间 分 析 方法 。

的空间复杂度 。
【例1.11〗 对 于 例 1.9 的 算法 ,分 析 调用语句 funCa,z,0)

设 fun(Ca,z,R)

占用的临时空间为 SCz,) ,fun(Ca,n,0)

占用的临时空间为SCz),显

然有 SGCz)一 Si(z,0),由 fun() 算 法 得 到以下占用 临时 空间 的 递推式 。

1

当 & 二 7 一 1 时 (此 时 仅仅 定义了 一 个 临时 变量 2

SC,) 一

则,

1 十 SiGz十1) 其他情况

SG 一SG,0)一1十SC,1)

二 1十 1 十 Si (2,2)

一 1十 1十 ...十 1 十Si (zz一1)

一 1十 1十 泡十 1一OOD)

1十1二十1

7 个 1

所以 调用 fun(a,z;0)

的空间复杂度为OCz) 。

数据 结构教程

[第! 5 【版

数据结构 二 算法 = 程序 “ 尖

计算 机 软件 的 最 终 成果都是以 程序的 形式 表现 的 ,数据 结构和 算法 分 析 的 目的 是设计

好 的 程序,著名 的 计算 机科学 家 沃 思 CN. Wirth) 专门 出 版了《数据结构 十 算法 = 程序) 一 书 ,

其 中 指出 程序是由 算法和 数据 结构 组 成的,程序 设计 的 本 质 是 对 要 处 理 的 问题 选择好 的 数

据 结构 ,同时 在 此 结构上 施加 一 种 好 的 算法 。

计算机科学家简介

N., Wirth(1934 年 出生 ) ,瑞士计算 机 科学 家 ,1960 年 获 加 利 福

尼 亚大 学伯克利分校博士学位。曾 任 斯 坦福大 学 .苏黎世联邦理工

学 院 教授。发 明 多 种计算机语言 (包括 Pascal、Modula 和 Oberon

等) ,并 在软件 工程 领域 作出 过 开拓 性 的 贡献 。他于 1980 年获得计

算 机科学界最高奖 一 一图灵 奖 (Chttp://en. wikipedia. org/wiki/

Turing_Award) 。

141 程序和数据结构

对 于 一 个 程序 来说,数据是“原料 ”。一 个 程序所 要 进行 的计算 或 处 理 总 是 以 某些数据

为对象的。将松散 、 无 组织的 数据 按 某种要 求 组 成 一种数据 结构,对 于 设计 一 个 简明 ,高效 、

可 靠 的 程序 是大有 益处 的 。沃 思 指出 ,程序 就是在 数据 的某些 特定 的 表示 方法和 结构 的 基

础 上 对 抽象 算法 的 具体 表述,所以说程序 离 不开数 据结构 。

程序 是 通过 某 种 程序设计 语言描述 的 ,程序设计 语言具有 实现 数据 结构和 算法 的 机 制 ,

其 中 类 型声明 与对象 定义用 于 实现 数据结构 ,而语句 实现 算法 ,描述 程序的 行为 。

142 算法和程序

由 程序设计 语言 描述 的 算法 就 是计算 机 程序 。对 于 一 个 求解问题而言 , 算 法 就 是 解题

的 方法 ,没有算法 ,程序 就 成了无 本 之 木,无 源 之 水: 有 了 算法 ,将 它 表 示 成 程序 是不困难

的。算 法 是 程序的“灵魂”, 算 法 在 整个计算 机科学 中 的 地 位 都 是 极其重要 的 。

143 算法和数据结构

ee

求解 的 问题可 以 通过 抽象数据 类 型来描述 , 它 由 数据的逻辑 结构和 抽象运算 两部分 组

成 。一 种 数据的迎 辑结构 可以 映射成多 种 存储 结构 ,抽象运算 在 不同的存储 结构上 实现 可

以 对 应 多 种 算法 ,在 同一种存储 结构上 实现 也 可能有 多 种 算法 ,通过 算法 的 时 间 复 杂 度 和 空

间 复 杂 度 等分析 可 以 得 到 好 的 算法 ,如 图 1.17 所 示 。

注意 ,不 能离开 数据 结构去抽象地考虑 算法 ,也 不 能 脱离 算法去孤立 地讨论 数据 结构 ,

只 能 从 算法 与 数据 结构 的 统一上 去 认识 程序 。

数据 存储 结构 会 影响算法 的 好 坏 , 因 此 大 家 在 选择存储 结构时 也 要 考虑 其 对 算法 的 影

PASS洛论 |

抽象 数据 类 型 =数据 的 逻辑结构 + 抽象 运算 (运算的 功能 描述 )

| 全

数据的存储结构1 ... 数据的存储结构

撞 象 运 筑的 实现

算法1 ... 算法Im。 ... 算法m ... 算法中

岂 算法分析

好 的 算法

图 1.17 设计好算法的过程

响。存 储 结构对 算法 的 影响 主要 在 下 面 两个方面。

生存 依结和 的 存售 能 力

如 果 存储 结构 的 存储 能力强 、 存 储的信息 多 ,算法 将 会较好 设计。反 之 ,对 于 比较 简单

的 存储 结构 可 能 要 设计 一 套比较 复杂 的 算法。在 这 一点上 经 常 体现时间 与 空间 的 矛盾 , 往

往 存储 能 力 是与所 使用的 空间 大小 成 正比 的 。

存储 结构 是 实现 算法 的 基础 ,也 会 影响 算法 的 设计 ,其 选择要 充分 考虑 算法 的 各 种 操

作 ,应 与 算法 的操作 相 适 应 。

所 以 说 设计 算法 与选择 合适 的 数据 结构 是 程序设计 中 相辅相成 的两个 方面 , 缺 一不可 。

数据 结构 的选择一直 是 程序设计 中 的 重点 和 难点 ,正确

地 应 用 数据 结构 往往 能 带来意 想 不

到 的 效果。 反 之 ,如 果 忽视了 数据 结构 的重要 性 ,对 某 些 问题 有 时 就 得不到 满意 的 解答 。

算法 通常 是决定 程序效率 的 关键 ,但 一 切 算法 最 终都要 在 相应 的 数据 结构上 实现 ,许多

算法 的 精 散 就 是 在 于 选择了 合适 的 数据 结构 作为

基础 。在 程序 设计 中 不仅要 注重 算法 设

计 , 也 要 正确地 选择 数据 结构 ,这 样 往往 能 够事半功倍。

144 数据 结构 的 发 展

早期 的 计算 机主要应用于 科学计算 , 随 着计算 机 的 发展和 应 用 范围的拓宽 ,计算机需要

处 理 的 数据 量 越 来 越大,数据的类 型 越 来越多 ,数据 的结构 越 来 越复杂 ,计算 机 的对 象从简

单的纯 数值性 数据发展 为非 数 值 性 的和具有 一 定结构 的 数据。于 是 要 求人 们 对 计算 机 加 工

处 理 的 对 象 进行系统 的 研究 , 即 研究 数据 的 特性 、 数 据之间 存 在的关系 ,以 及 如何有 效 地 组

织 、 管理存储 数据,从 而 提高 计算 机 处 理 数据的效率。数 据结构 这门学科 就 是在此 背景上逐

aa

数据 结构 的 概念 最 早由C.A.R. Hoare 和 N. Wirth 在 1966 年 提出 ,对 这 一 发 展 做 出杰

出 贡献的是D. E. Kunth 和 C. A.R. Hoare,D.E.Kunth 的《计算 机 程序设计 技巧》和 C. A.

R. Hoare 的 《数据 结构札记 》, 这 两 部 著作 对 数据 结构 这门学科 的 发展做出了 重要 贡献 。大

量 关 于 程序 设计 理论 的 研究 表明 : 对 大 型复杂 程序 的 构造 进行 系统而 科学 的 研究 ,必须 对

这 些 程序中 所 包含的数据 结构 进行 深入的 研究。随 着计算 机 科学 的 飞速 发 展,到 20 世纪

数据 结构 教程

虹 第 5 【版

80 年代 初期,数据结构的基础研究日 玉 成熟,已经成 为 一 门 完整 的学科。

计算机科学家简介

Donald Knuth(1938 年 出生 ) ,算法 和 程序设计 技术 的 先驱者,计
算机 排版系统TEX 和 METAFONT 的 发明 者,他 因这 些成 就和 大 量

创造性的 影响 深远 的 著作 (19 部 专著 和 160 篇论文 ) 而 誉 满全球 。

作为斯坦福大 学计算 机 程序设计 艺术 的 荣誉退休 教授,他 当前 正 全

神 贯 注于 完成 其 关于计算机科学 的 史诗 性 的 七 卷 集 。这 一 伟大工

程在 1962 年 他 还 是加 州理工 学 院 的 研究生 时 就 开始了。 他于 1974

年 获得计算 机 科学 界 最高奖 一 一图灵 奖 。

C.A.R. Hoare(1934 年出生 ) ,英国计算机 科学 家 ,毕业 于 牛津

大 学 ,他 的 贡献 是 发 布 了 快速 排序 算法.Hoare 逻辑 形式语言通信

时 序 进程 CCSP) 等

。他于 1980 年获得计算 机 科学 界 最 高 奖 一一图

一 本章小结 一一一

本 章 介绍 了 数据 结构 的 基本 概念 ,主要 学 习 要点如 下 :

(1) 理解数据结构 的 定义 ,数据结构 包含 的 逻辑结构 .存储结构和运算

三方面的相互关系。

(2) 掌握 各 种 逻辑 结构( 即线性结构 、树 形结构 和

图 形结构 ) 的特点 。

站

(3)

了 解 各 种存储 结构( 即顺 序存储结构 、链 式存 储 结构 .索引 和 散 列 )

视频讲解

之间的 差别 。

(4)

了 解数据 类 型 和 抽象 数据 类 型 的 概念 和 区 别 。

(5) 掌握算法定义及特性。

(6) 掌握 使用 C/C++语 言描 述 算法 的 方法 。

(7)

重点 掌握 算法 的 时间 复 杂 度 和 空间 复杂 度 分析 方法 。

(8) 掌握从 数据结构 的 角度 求解 问题的基本 过 程 。

性用由炉

1. 简 述 数据 与数据 元 素 的 关系 与 区 别 。

2. 采用 二 元 组 表示 的 数据 逻辑 结构S$=< D,R>, 其中卫一{a,b, ,让 ,及一人1r) 7 一

{ 人 ab>,< ac><c,d>必cf>fh>< de><flg>,<h,i>),问关系~ 是什么类型的

PASS当论 |

Da上

简 述 数据 逻辑 结构 与存储 结构 的 关系 。

简 述 数据 结构中 运算 描述和 运算 实现的异同 。

数据 结构和 数据 类 型有什么区别?

在 C/C++ 中 提供 了 引用 运算 符 , 简 述 其 在 算法 描述 中 的 主要 作用 。

有以 下 用 CVC++语 言 描述 的 算法 ,说 明 其 功能 :

void fun(double &y,double x,int n)

{人YY 一 xi;

while Cn> 1)

yy<Xi

D 一 一

人

}

}》

8. 用 CVC++ 语 言 描述 下 列 算法 ,并 给 出 算法 的 时 间 复 杂 度 。

(1) 求一 个痉阶 二 维 数组 的所有 元 素之和 。

(2) 对 于输入的任意 3 个 整数 ,将 它们 按 从 小 到 大 的 顺序 输出 。

(3) 对 于输入的任意守 个整数 ,输出其中的 最大和 最小 元 素 。

9. 设 3 个 表示 算法 频 度 的 函数 广g 和 记分 别 为

Ja) 一 1002 十时十 1000

g (2) 一 25723 十5000722

(2) 一 7 十5000zlogs7

求它们 对 应 的 时 间 复 杂 度 。

10. 分 析 下 面 程序段中 循环语句 的 执行次数 。

int j一0,s一0,n 一100;

do

{

jj 二 ji十 1;

S 一 S 十10xj;

} while G<n 孜 &s<n);

11. 设 ”为 正 整 数,给 出 下 列 3 个 算法 关于问题规模 的 时间 复 杂 度 。

(1) 算法 1;

void funl(int n)

{ ii=1,k一100;

while (Ci<一D)

{

KKk=kTli

, 计 一 2;

}

(2) 算法 2:

void fun2(int b[] ,int n)

{

intij,k,x;

for (i王0;i<n一1;i十十)

aa

数据 结构教程

[第! 5版

{ kk一ii

for (G=i十14<nj;j十十)
迁 (b[刁>b 中 ) k 一 j;
x 一 b喇 ;jb加 一 b[g] ;bUg] 一 x;

】》

(3) 算法 3:

void fun3(Cint n)

int i一0,s一0;

while (s <一D)

ii 十 ;
s 一 s 十 ii;

{

}

{

}》

12. 有以 下 递归 算法用 于 对 数组 <[;...放 的 元 素 进行 归并 排序 :

void mergesort(int a[] ,int i,int j)

int mi
迁 (il一j)

{

mm 一 (i十ji)/2;

mergesort(a,i, my) ;

Imergesort(a,m 十 1,j);

merge(a,i,j,m);

}

{

)》

求 执 行 mergesort(a,0,m

一1)的时间复杂度。其中,merge(Ca,z,j

,2)用于两个有 序子序

列 ea[.z]和 a[m 十 1.. 门 的 合并 ,是非递归 函数 , 它 的时间 复 杂 度为 O( 合 并 的 元 素 个 数 ) 。

13. 描述 一 个 集合 的 抽象数据 类型 ASet, 其 中所有 元 素 为 正 整数 ,集合 的 基本 运算 包括 :

(1) 由 整数 数组 c[0..z

一菇创建一个 集合。

(2) 输出 一 个 集合 的所有 元 素 。

(3) 判断一个 元 素是否 在一个集合 中 。

(4) 求 两 个集合 的 并 集 。

(5) 求 两个集合 的差集 。

(6) 求 两 个集合 的 交集 。

Eee

在 此 基础 上 设计 集合 的 顺序 存储 结构 ,并 实现 各 基本 运算 的 算法 。

一 >- 上 机 实验题 1 一 一

驶验证性实验

实验题1,

求 1~m 的连续 整数和

目的, 通过 对 比 同一 问题不同 解法 的绝对 执行时间 体会不同 算法的优劣。

(2

PASS人当论 |

内容: 编写一个程序expl-1. cpp, 对 于 给 定 的 正 整数,, 求 1 十 2 十 ... 十 2 ,采用 逐个 累加

与 2C2z 十1)/2( 高 斯法) 两 种 解法 。对 于相同的 ”给 出 这 两 种解法 的 求和结果 和 求解 时间 ,

并 用 相关 数据 进行 测试 。

实验题 2: 常见算法 时 间 函 数 的增长趋势分析

目的: 理解 常见算法 时间 函 数 的增长 情况 。

内 容: 编写一个程序 expl-2. cpp, 对 于 1 一 半的每个整数 ”输出 logsm、Vn mmlogzm、

12 73、2” 和 7! 的 值 。

对 设计 性 实验

实验题3: 求素数的个数

目的: 通过对 比 同一 问题不同解法 的 绝对 执行时间 体 会如 何设计 “好 ?的 算法 。

内 容: 编写一个程序 exp1-3. cpp,求1~ 的 素数 个 数。给 出 两 种解法 ,对 于 相同的”,

给 出 这 两种解法 的结果 和 求解时间 , 并 用 相关 数据 进行 测试 。

实验题4: 求连续 整数阶乘的和

目的: 体会如何设计 “好 ”的 算法 。

内 容: 编写一个程序expl-4. cpp,对 于 给 定 的 正 整数z, 求 1!二 2! 十 3! 十 ... 十21。 给出

一种时间 复 杂 度为OCz)的解法。

线性 表 是 一 种 典型 的 线性 结构 , 也 是 一 种 最常用 的 数据结构。

线性 表 的 例子 不 胜枚举 , 例如 英文 字母表(A, B, ..., Z) 是 一 个线性

表 , 表 中 的 每个英文 字母就 是 一 个 数据 元 素; 又 如 成绩 单 是 一 个 线

性表, 表 中 的 每 个 成绩记录 是 一 个 数据 元 素 , 每个数据 元 素又是 由

本 章 介 绍线性 表 的 定义 、线 性 表 的顺序 和 链 式 两类存储 结构 以

及 相关 算法 的 实现、 线性 表 的 应 用 和 有 序 表 等 。

|
EX2AsSJ线性表

线性表 及 其 逻辑 结构

庆

在讨论 线性 表 的 存储 结构 之 前 先 分析其 巡 辑 结构。本 节 介绍 线性表 的 定义和 线性 表 的

抽象数据 类 型描述 。

211 线性表的定义

要-要

线性表(linear list)是具有 相同 特性 的 数据 元 素的 一个丰限 序列 ,该序

列 中 所 含元素 的个数 叫 线性 表 的 长 度 , 用表示,x全0。当 ?=一0 时 ,表示线

性 表 是 一 个 空表,即 表 中 不 包含 任何 元 素。在 线性 表 中 每个数据 元 素 由 罗

辑 序号 唯一确定 , 设 序列 中 的 第 ;(G; 表示 逻辑序号 ) 个 元 素为 w(1 和 ;和 2) , 则 线性 表 的 一 般

表示为

(al yaz

ai Go

其中 a 为 第 一 个 元 素 , 又 称为表 头 元 素 ,a 为第 2 个 元 素,a, 为最后 一 个 元 素 ,又称为表 尾 元 素 。

线性 表 中 的 元 素 呈 现 线性关系 ,即第站 个 元 素 ao; 处 在 第 ;一1个 元 素 wi-:的后面,第

i 十 1 个 元 素 cr 的 前 面 。线 性 表 用 二 元 组 表示 为工=(CD,R) ,其中:

也 ={ ao |

1 过 未 wz 全 0,ai

为 ElemType 类型}

/VElemType 是 自定义的类型标识符

玉一{ 7)

7r一{<aiyaiti> |

1]委 运 2 一1)

V/a; 与ai+l 相 邻 (有 序 )

对 应 的 迎 辑 结构 图形表示 如 图 2. 1 所 示 。

2.1 线性 表 逻 辑 结构 的 图 形 表示

从 线性 表 的 定义 可 以 看出, 它具有以 下 特性 :

(1) 有 穷性: 一 个 线性表 中 的 元 素 个 数 是有限 的 。

(2) 一 致性: 一 个 线性表 中所有 元 素 的 性 质 相 同 。从 实现 的 角度 看 ,所有 元 素具有 相

同的数据类型。

(3) 序列性: 一 个 线性表 中所有 元 素 之间 的相对 位 置是线性 的 ,即 存在 唯一的开始 元

素 和 终端 元素, 除 此 之 外 ,每 个 元 素只有 唯一的前 驱 元素和后 继 元 素。各 元 素 在线性 表 中 的
位 置 只 取决 于 它们 的 序号,所 以 在 一 个 线性 表 中 可以 存在 两 个 值相同 的 元 素 。

es

212 线性 表 的 抽象 数据 类 型 描述

线性表 的 抽象 数据 类 型 的描述如下 ;

ADT List

{ 数据对象:

也 ={ ai| 1]受 未 风 x 二 0,ai

是自定义类型标识符
为 ElemType 类型} //ElemType

生理

数据 结构教程

(第5 【版

数据 关系 :

及 一 {< aaiH>| asarED,i一1 ,2一1}

基本 运算 :

InitList(

人&) : 初始化 线性 表 , 构 造 一 个 空的线性 表 工。

DestroyList(&&工) : 销毁 线性 表 , 释放 线性 表 工 占用的内存空间 。

ListEmpty(L): 判断线性 表 是 否 为空表 , 若 工 为 空表, 则 返回 真,否则 返回 假 。
ListLength(工) : 求 线性表 的 长度, 返 回工 中 元 素 的个数 。

DispList(CL): 输出 线性 表 , 当线性表工 不 为 空时顺序显示工 中 各 结 点 的 值域。
GetElem(Li, &e): 求 线性 表 中 某 个 数据元素 值,用 e 返 回工中第;1 近 i 运 站 个 元 素 的值。

LocateElem(L,e): 按 元 素 值查找 ,返回工 中 第 一 个 值 域 与e 相等 的元素 的 序号 , 若 这 样 的

元 素 不 存在 , 则 返回 值为0。

ListInsert(&工ie) : 插入 数据元素 ,在 工 的 第;(1si 生 2 十1) 个 位 置插入 一 个新的 元素。,工

的 长 度增 1 。

ListDelete(& TI &e): 删除 数据 元 素 , 删除工 的第;1 委 i 生 四 个 元 素,并 用 e 返 回 其 值,工

的 长 度减 1。

)》

线性 表 的 作用 主要 体现 在两个 方面,当 一 个 线性 表 实 现 后 ,程序 员 可以直接使用它来存

放 数 据 ,即 作为存放 数据 的 容器 ,另外 程序 员 可以 直接 使用它 的 基本 运算 来 完成更复杂 的 功

能。线 性 表 基 本运算是与 求解 问题相关 的,上面列出的 9 个 基本 运算 是 线性 表 最 常用 的 功

能 ,在 实际 应用中 大 家 可以 根据 需要 进行增减 。

【例 2.1〗 有 一 个线性表工= (1,3,1,4,2),求ListLength(L)、ListEmpty(工)、

GetElem(L,3,e)、LocateElem(L,1)、ListInsert(L,4,5)和 ListDelete(L,3)

基 本运算依次

执行后的结果。

线性表工 中 存放 的 是 几 个 整数,其 各 种 基本 运算 的结果 如 下 。

ListLength(EL)

王5,即线性表工 的 长 度为5。

ListEmpty(L)返回 false,即线性表工 为非空表 。

GetElem(L,3,e),e 一1, 即线性表工 中 的 第 3 个元 素 是 1 。

LocateElem(L,1)

王1,即线性表工 中 第 一 个 值为 1 的 元 素的逻辑序号是 1 。

ListInsert(

工,4,5)是在线性表工 中 逻辑 序号 4 的 位 置插入元素 5 ,执行 后工变为(1,3,

1,5,4,2)。

ListDelete(L,3,e)

是在线性表工 中删除多辑序号 3 的 元 素 ,执行后荆 变为 (1,3,5,4,2)。

【例2.2〗 假设有两个集合 A 和 妃 , 分 别 用 两个线性表LA 和 LB 表示 , 即线性表 中 的

数据元 素 为 集合中 的元 素

。利 用 线性 表 的 基本 运算 设计 一 个 算法 求一个 新 的 集合 C= AU

已 ,即将 两 个集合 的 并 集 放 在 线性 表 LC 中。

ea

先 初始化线性表 LC, 即 创建一个空的线性 表 LC,将LA 的所有 元 素 复制到LC 中 ,

然后 扫描 线性 表 LB,将LB 中 不 属于 LA 的 元 素插入到LC 中 。LA、LB 和 LC 均为List 类

型 变量 ,假设List 是一个 已经 实现了 的 线性 表 数 据 结 构。对 应 的算法如下 :

void unionList(List LA,List LB,List &LC)
{

int lena,ii

ElemType e;
JInitListCLC) ;

// 初 始化LC

(2

|
EXA2AsSJ线性表

for (i王1;i<王ListLength(LA);i 十十)

GetElem(LA,ie);

ListInsert(LC,i,e);

{

}

lena一ListLength(LA);

for (i王1;i<一ListLength(LB);i十十)

{

GetElem(LB,i,e);

迁 (!LocateElem(LA,e))

ListInsert(LC,十十lena,e) ;

//将LA 中 的所有 元 素 复制到 LC 中
//取IA 中 的 第 ii个元素 赋 给 e
// 将 元 素 e 插 入 到 LC 中

//求线性表 LA 的 长 度
//循环处理LB 的 每 一 个 元 素
//取ILB 中 的第i 个 元 素 赋 给 e
// 判断e 是 否在LA 中
//若e 不在LA 中, 则 将 其插入到 LC 中

】}

在 上 述算法 中,LA 和 LB 是 输入型参数,而LC 是 求解结果 ,为 输出 型 参数,所 以将LC

设计为引用型形参。

从 中 可以 看 出 , 当线性表 List 实现以 后,可以 利用 它 作 为 存放 集合 数据 的 容器,也 可 以

利用 它 的 基本 运算 完成 更复杂 的 集合 运算 ,如 求 两个集合的并 集 等 。

线性 表 的 顺序 存储 结构

AI人
AN

线性 表 的 顺序 存储 结构 是 最 常用的 存储 方式, 它 直 接 将 线性 表 的 逻辑 结构映射 到 存储

结构上 , 既便于 理解,又 容易 实现 。本 节讨论顺 序 存储 结构 及 其 基本 运算 的 实现 过 程 。

221 线性 表 的顺序 存储 结构 一 一顺序表

线性 表 的 顺序 存储 结构 是 把 线性表 中 的所有 元 素 按照其逻辑 顺序 依次

存储 到 从 计算 机 存储 器 中 指定 存储 位 置开始 的 一 块连续 的 存储 空间 中 , 如

图 2.2 所 示。由 于 线性表 中 逻辑上相 邻 的 两个元 素 在对 应 的 顺序表 中 它们

的 存储 位 置也相 邻 ,所以 这 种 映射 称为直接 映射 。线 性 表 的顺序 存储结构

简称 为 顺序 表 (sequential

ist)。

线性 表

直接 映射

(CD0

data

length

2.2 线性 表 到 顺序 表 的 映射

这 样 ,线性表工 中 第 一 个 元 素 的存储 位 置 就是指定 的 存储 位置,第 ;十1 个 元 素(1 近 ; 甩

7 一 1) 的 存储 位 置紧接 在第 ;个

元 素 的存储 位 置 的 后 面 。 假 设线性 表 的 元素类 型 为

ElemType,

则每个元素所占用存储空间的大 小 ( 即 字 节 数 ) 为 sizeof(ElemType) ,整个线性

表 所 占用 存储 空间的大小 为 Xsizeof(ElemType) ,其中妈 表 示 线 性 表 的 长 度 。

在 C/C++ 语 言中,借助 数组类 型 来实现 顺序 表 , 也 就是说,用 数组 存放 线性 表 的 元 素 及

其 逻辑 关系 ,数组 的 基本 类 型 就 是线性 表 中 元 素 的 类 型 ,数组 大 小 (即 数组上 界 一下界十1)

要 大 于等于 线性 表 的 长度,否则 该 数组 不 能 存放 对 应 线性 表 的所有 元 素 。所以当 线性表长

到

数据 结构教程

[第! 5版

度 小 于 数组大小 时 ,该数组 中 会有一 部 分 空闲 空间 。

线性 表 中 的 第 一 个 元 素 w 存储 在 对 应 数组 的起始 位 置 ,即 下标为 0 的 位 置上,第二个

元素 az存储在下标为 1 的 位 置上,依次类推,第守 个 元 素 a; 存 储 在 下标 为;一 1 的 位 置上 。

假设线性 表 工 存储在数组A 中 ,A 的 起 始 存 储 位置为LOC(A),则工 所 对 应 的 顺序 表 如

图 2. 3 所 示 。 需 要 注意 的是,顺序 表 采 用 数组 来实现 ,但 不 能 将 任何一个 数组 都当作 是一个

顺序 表 , 二 者 的 运算 是 不 同 的 。

下 标 位 置 线性表存储空间 存储地 址

0

1

大 1

1 一 1

Maxsize 1

al

0

三

Gy

:

LOCC4)

LOC(C4)+sizeofElemType)

LOCC4)+(六1)XsizeofElemType)

LOC(4)+(2-ID)XsizeofElemType)

LOCCD)+(MaxSize-D)Xsizeof(ElemType)

图 2.3 顺序表的示意图

数组 大小 MaxSize 一 般 定 义 为 一 个 整 型 常量 。 如 果 估 计 一 个 线性 表 不 会超过 50 个元

素 , 则 可以把MaxSize 定义为50:

# define MaxSize 50

在声明 线性 表 的 顺序 存储 类 型时 ,定义 一 个 data 数组 来存储 线性 表 中 的所有 元 素 , 还

定义一个整型变量 length 来存储 线性表 的实际 长度,并 采用 结构 体 类型SqList 表示如下 :

typedef struct

{

ElemType data[MaxSize] ;

// 存 放 线 性 表 中 的 元 素

int length;

}SqList;

// 存 放 线性 表 的 长 度

// 顺 序 表 类 型

例如 ,对 于 第 1 章例 1. 1 的 逮 辑结构 City,假设每个元素占用 30 个存储单元,数据从

100 号 单元 开始 由低地 址 向 高 地 址 方向 存储 ,对 应 的 顺序 表 如 图 2.4 所 示 ,其中 data 为 包含

城市 名 区 号 和 说 明 数据 域的结构 体 类 型的数组 ,该 顺序 表 的 length 域 应为5。

aa

地址 区号 城市名
100
010
130
021
160
027
190
029

说明
| Beiiing | 北京 ,首都
| Shanghai | 上海,直辖市
| wuhan
| xian

武汉,湖 北 省 省 会
西安 ,陕西省 省 会

220

025

Nanjing

南京 ,江 苏 省 省 会

图 2.4

City 对 应 的 顺序 表 结 构

(3

|
EX2AsSJ线性表

222 顺序 表 基 本 运算 的 实现

一 旦 采用 顺序 表 存储 结构 ,就 可以用 CV/C++ 语 言实现 线性 表 的 各 种 基本 运算。为了简

单 , 假设ElemType 为 int 类 型 ,使 用以下自 定 义 类 型 语句 :

typedef int ElemType;

注意: 在 后 面的算法 中 ,线性 表 元 素 的 逻辑序号 是从 1 开始 的 ,而 对 应 顺序 表 的 data[L]

数组下标是从 0 开始 的 (这 种 下标 称 为物理序号 ) ,因此 要注意 它们 之间 的 转换 。

本 节 采 用 顺序 表 指 针 方 式 建立和 使用顺序表 , 其 结构如 图 2. 5(a)所示,也 可以 直接 使

用 顺序 表 Q, 如 图 2.5Cb)所示。

说明: 顺序表 指 针 工 和 顺序 表 Q 都 可以 提供 5 一~[

一

一 个 顺序表 , 但 前 者 是通过指针 了 间接地提供顺序

o

-
顺F表

表 , 其 定义 方式为SqList * 工 ,后者是直接地提供 人) 顺序表指针

b) 顺序表O

顺序 表 , 其 定义 方式为SqList Q。 前 者 引用 length

域的方式为了 一 > length,后者 引用 length 域的方

2.5 顺序 表 指针 和 顺序 表

式为Q.length。 之所 以 采用 顺序 表指 针 , 主 要 是 为了方便 顺序 表 的 释放 算法设计 ,并 且 在
函数 之间 传 递顺序 表指针 时 会 节省 为 形参分 配 的 空间 。

要--扫

这 里 介绍 整体 创建顺序 表 , 即 由 数组元素 e[0..% 一创建顺序表 上 。

其方法是将数组 e 中 的 每个元 素 依次放 入 到 顺序 表 中 ,并 将 , 赋 给顺序表

的长度域。算法如下:

void CreateList(SqList * &L,ElemType a[] ,int n)
{

int i 一0,k一0;
工 一(SqList * )malloc(sizeof(SqList)) ;

// 由 a 中的mn 个 元 素建立顺序表
/ 作 表 示 世 中 的 元 素个数 , 初 始 值为0
// 分 配 存 放 线 性 表 的空间

while (i<p)

{ 工一data[ 国一a口 ;

++3 i++

)》
工一 length一k;

)》

Wi 扫描 数组 a 的 元 素

// 将 元素a[i]存放到 L 中

/设置工的长度k

当 调用上 述 算法 创建好工 所 指 的 顺序 表 后 ,需要 回 传 给对 应 的 实 参 ,也 就 是 说 ,L 是输

出 型参数 ,所以 在 形参工 的 前 面需要 加 上 引用 符 “ 监”。

要-要

2 顺序表基本运算算半

1) 初始化线性表 InitList(&L)

该运算 的 功能 是 构造一个 空 的线性 表 工 ,实际上只 需 分 配 线性 表 的 存

储空间 并 将 length 域设置为 0 即可。算 法 如 下 :

void InitList(SqList * &KL)

{ =一(SqList * )malloc(Csizeof(SqList)) ;

// 分 配存放 线性 表 的 空间

数据 结构教程

[第! 5版

工一 length一0;

// 置 空线性 表 的 长 度为0

)》

本 算法的时 间 复 杂 度为O(1)。

2) 销毁 线性 表 DestroyList(&L)

该 运算 的 功能 是 释放 线性 表 工 占用的内存空间。算法如下 :

void DestroyList(SqList < &&L)

{

}

free(L);

// 释 放 工 所 指 的 顺序 表 空 间

本 节 的 顺序 表 是通过 malloc 函数分配存储 空间 的 , 当 不 再 需要 顺序 表 时 务必 调用

DestroyList 基本 运算 释放 其 存储 空间; 否则 ,尽管系统 会 自动释放 顺序 表 指 针 变量 工 ,但 不 会

自动释放 工 所 指向 的 存储 空间,如 此 可 能 会 造成内 存 泄 漏 。本 算法 的 时间 复 杂 度为O(1)。

3) 判断线性 表 是 否 为 空表 ListEmpty(L)

该 运算 返回 一 个 布尔值表示 工 是 否 为 空 表。若 工 为 空表, 则返回 true,和否则返回 false。

算法如下 :

bool ListEmpty(SqList x* 工 )

{

}

return(L -> length 一一0) ;

本 算法的时 间 复 杂 度为O(1)。

4) 求线性表的长度 ListLength(L)

该 运算 返回 顺序 表 工 的 长度, 实际上 只 需 返 回 length 域 的 值即 可。算法如下:

int ListLength(SqList * 工 )

{

}

return(L -> length) ;

本 算法的时 间 复 杂 度为O(1)。
5) 输出 线性 表 DispList(L)

该运算 依次 显示 工 中 各 元 素 的 值 。算法如下 :

加

void DispList(SqList * 工 )

for (int i=0;i<L->1lengthii十十)

// 扫 描 顺 序 表 输 出 各 元 素 值

printf("%%d ",工一> data[);

printfC"\n");

{

)}

本 算法 中 的 基本 操作 为 for 循环中 的 printf

语句,它执 行冯次 , 故 时间 复 杂 度为OCz),

其中 为顺序 表 中 元 素的个 数 。

(se

|
EX2AsSJ线性表

6) 求 线性 表 中 的 某个数据 元 素值GetElem(L,1六&e)

该运算 用 引用 型 参数 返回工 中 第 ;1 入 ;到 2 个 元 素 的 值 。算法如下 :

bool GetElem(SqList * L,int i,ElemType &e)

ii(Ci<l | i>L->length)

return false;

ee一L 一> data[i一品;

Teturn true;

{

)}

本 算法 的 时 间 复 杂 度为O(1)。

7) 按 元 素 值 查找 LocateElem(L,e)

// 参 数 i 错误时返回 false

// 取 元 素值

//成功找到 元 素时返回 true

该 运算顺序 查找 第 一 个 值 域与 e 相等的元 素 的 逻辑 序号 (找到 后 返回 一 个 大 于 0 的

值) , 若 这 样 的 元 素 不 存在 , 则 返回 值 为 0。算法如下 :

int LocateElem(SqList * 工 ElemType e)

inti=0;
while (i< 工 一 length && L 一 data[癌!一e)

i 十十;

这 (i> 王 L 一 1length)

Teturn 0;

else

return i十1;

// 查 找 元 素 e
// 未找到时返回 0

// 找 到 后 返回其逻辑 序号

{

)}

本 算法 中 的 基本 操作 为 while 循环中 的 ;十 十 语句 ,其 平均 执行 (2 十1)/2 次 , 故 时间复

杂 度为O(0z) ,其中 7 为 顺序 表 中 元 素 的 个 数 。

8) 插入 数据 元 素 Listlnsert(&L ,1,e)

该运算在顺序表工 的 第 ;Ci 过 2 十1) 个 位 置上插入 新 元 素 e。 如果 ; 值 不 正确,返回

false; 否则 将 顺序 表 原 来的第 守 个 元 素 及以后的 元 素 均 后 移 一 个位 置 , 并 从 最 后 一 个 元 素

au 开始 移动起,如 图 2. 6 所 示 , 腾 出 一 个 空位 置插入 新 元 素 ,最 后 顺序 表 的 长 度增 1 并 返回

true。 算法如下 :

bool ListIJnsert(SqList * &L,int i,ElemType e)

{

intj;

if(i<1l | i>L->length十1)

return false;

i 一一;
ij一一)
for (j一世一> length;j>

工 一 data[站=L 一> data0j一二 ;

工一data[i训一e;

工一length十十;

Teturn true;

)}

// 参 数 i 错 误 时返回 false
// 将 顺序 表 逻 辑 序号 转化 为 物理 序号
//将 data[癌 及 后 面 的元素后移 一个位 置

aa

//插和元素 e

// 顺 序 表 长度增 1
// 成 功插入 返回 true

对

F 本 算法 来 说 ,元 素 移动 的次数 不 仅与表 长 zx一 工 一> length 有 关 , 而 且 与插入 位置,

有关,共有 2 十 1 个 可以插入 元 素 的 地 方: 当 ;i=72十 1 时 (插入 在 末尾 ) ,移动次数为0; 当

数据 结构教程

[第! 5人版

0

al

1

2 :Fl

co |

本

1

1

PPlL

Cr

7

MaxSize-l length

本

本

7 增 1

忌人人立一六休

从 右 向 左 进行

图 2.6 插入 元素时 移动 元 素的过 程

i]1 时 (搬入 在 开头),移动 次 数为”达到最大值; 一 般 需 要 将 一av 的 元 素 均后移 一 个位

置 ,移动次数 为*一 ;十1。假设记 是 在第; 个 位 置上搬入 一 个 元 素 的 概率 ,在 等概率 的 情况

下 , 户一二 , 则 在长度为”的 线性表 中 插入一 个 元 素时 所 需 移动元 素 的平均 次 数 为

十1

十 1

十1

之 六 0 i 十 1) 之 寺 1 i 十 1) 二 12 1 十 1)

1

-

-

1

义 2C2 十 1)

7 十 1

2

允

2

该算法 的 主要 时间 都是花费 在 元 素 的 移动上,因此 插入 算法 的 平均时间 复 杂 度为OC0z) 。

9) 删除 数据 元 素 ListDelete(&L ,),&e)

该运算 删除顺序 表 工 的 第 ;所 二 裤 个 元 素

。 如果 ; 值 不 正确 ,返回 false; 否则将线

性 表 第 ;个

元 素以后 的 元 素 均 向 前 移动 一 个位置,并 从 元 素 ui+ 开始移动起 ,如图 2.7 所

示 , 这 样覆盖 了 原来 的第;个 元 素 ,达 到 了删除该元素的目的,最 后 顺序 表 的 长 度减 1 并返

加

回 true。 算法如下 :

bool ListDelete(SqList * &L,int i,ElemType &e)

{

intj;

if Gi<1l | i>L一length)

// 参 数 i 错误 时 返回 false

return false;

i 一 一 ;

e 王工一 data[ ;

// 将 顺序 表 逻 辑 序号 转化 为物理 序号

一1;j十十)
for (j=i;j<L一1length

//将 data[j 之后的 元 素 前移一个位 置

工一 data[让=L 一> data0j十 ];

工一length一一;

Teturn true;

)}

// 顺 序 表 的 长 度减 1

// 成 功 删 除返回 true

0

1

2 :Fl ... MaxSize-l length

| 中 amw| 2

7 减 1

<儿反性

从 左 向 右 进行

图 2.7 删除 元素时 移动 元 素的过 程

对 于 本算法来说,元 素 移动的次数 也与 表长 2 二 工一> length 和删除元素的位 置; 有

关,共有 了 个 元 素可以 被 删除: 当 二 时 (删除 末尾 元素) ,移动次数 为0; 当 i1 时 ( 删

除开头 元 素),移动次数为"一1; 一 般需 要 将 ai+i 一o 的 元 素 均前 移 一个位置,移动次数

征殉

|
EX2AsSJ线性表

为 1 一(Gi 二 1) 十1=2 一;。假设 六 是 删除第; 个 位 置 上 元 素 的 概率 ,在等概率 的情况下 , 户 一

寺 , 则 在长度 为

的 线性 表 中 删除一个元 素时 所 需 移动元 素 的 平均 次 数 为

六 po 六 Lo 一DD= 工六
i=1

7 1
二

i=1 7

加

oO-

一 工xz一2 一 1
了2

2

2

该 算法 的 主要 时间 都 是花费 在元 素 的 移动 上,因此 删除 算法 的 平均时间 复 杂 度 为

OGCz)。

顺序 表 是 最常见 的 数据 存储结构 ,除了 基本 运算 以 外 ,下 面通过 一 些示例 介绍 比较 通用

【例2.3】

假设

一 个 线性 表 采 用 顺序 表 表示 ,设计 一 个 算法 ,删除其中所有 值 等于z 的

元 素 , 要 求 算法 的时间 复 杂 度为 OC0m) 空间 复杂 度为O(1)。

这 里提供两种解法。

解法一: 设 删 除工 中所有 值 等于xz 元 素 后 的顺序表 为 工1, 显然志 1 包

含在工 中 ,为此工1 重用 工 的 空间。扫 描 顺序表工 ,重建工 只包含不等于工

的元 素 ( 类 似 整体 创建 顺序 表 的 过 程),算法过程是置=0C& 用 于记录新表

中 的 元 素 个 数) ,用 ;从左到右扫 描工 中 的所有 元 素 , 当 ; 指向的元素为开

时跳过它; 否则将其放置在& 的位 置 ,即研一> data[E]王二一> data[i,

4 十 十。算法如下:

void delnodel(SqList * &L,ElemType x)

{ intk一0,i;

/从 记录 不 等于 x 的 元 素 的 个数, 即 要 插 人 到 L 中 的 元 素 个 数

for (i一0;i<L 一 length;i十十)

让 (L -> data[j!一x) , // 若当前元素不为 x, 将 其插入到 工 中
{ 工人一data[k] 王 L 一> data[;

k 十十 ;

// 插 入 一 个 元 素 时 元 素 的 个 数 增 1

】}

工一 length 一 k;

// 顺 序 表 工 的 长 度 等于上

}

解法二: 扫描顺序 表 工 ,用 ;从左到右扫描工 中 的所有 元 素 ,用和& 记录工 中 当前等于

的 元 素的个 数 ,一边 扫描 工 一 边统计 当前 & 值 。当 指向的元素 为 时 & 增 1; 否则将不 为工

的元素前移 上 个 位 置 , 即 工一> data[Li

一馈一工一> data[让。最后修改 工 的 长 度 。算法如下:

void delnode2(SqList * &&L,ElemType x)

{

intk

一0,i一0;

/外 记录 等于 x 的 元素的个数

Te

while (i< 工 一 length)

{

证 (L->data[四一一x)

// 当 前 元 素 为x时 上 增 1

k十十;

else

// 当 前 元 素 不 为x时 将 其 前 移 k 个 位 置

工 一 data[i一针王L 一 data[] ;

i十十;

数据 结构教程

[第! 5版

工一 length 一一k;

// 顺 序 表 工 的 长 度 递减上

}

上 述 两 种 算法 中 都 只 扫描 顺序 表 一 次 ,时间 复 杂 度 为O0z) ,只 有 两 个 临时变量 ,所 以 空

间复杂度 为 O(1) ,满足题目的要求。

下 面 两种解法 都 不 满足 题目的 要 求 :

(1) 每 次删除一个 等于 z 的 元 素时 都 进行元素移 动,此 时 算法 的 时间 复 杂 度为OCO2)、

空间 复杂 度为OCG1)。

(2) 在 算法 中 临时新 建一个 顺序 表 用 于 存放 不 等 于 z 的 元素, 通 过 扫描 原来 的 顺序 表

得 到 该新 的 顺序 表 , 此 时 算法 的时间 复 杂 度为 OC02) 空间 复杂 度为OCz) 。

【例 2.4〗 有 一 个顺序表工 ,假设元素类型ElemType 为 整 型 ,设计一个 尽 可 能 高 效 的

算法 ,以第一 个 元 素 为 分 界线(基准 ) ,将所有小 于 等于它 的 元 素 移 到 该 基准 的 前 面 ,将所有

大 于 它 的元 素 移 到 该基准的后面。

国 基本思路 是以 第一个元 素为基准 ,从 右 向 左找 一 个 小 于 等于 基准的“|国

元素z, 从 左 向 右找 一个大 于 基准 的元素 >, 将 两者交换 ,直到 全 部找 完 。下

面 提供 两种解法 。

扫-- 要

ET

解法一: 用 pivot 存放 基准 ,即 工一> dataL0],i(初值 为 0)从 左 向 右 扫 视电江于

描 光 ( 初 值 为 一 > length

一1)从右向左扫描。当 ; 径 7 时 循环( 即 循环到; 和 7 指向 同一 元

素时为止): 7 从 右 向 左找 一 个 小 于 等于 pivot 的元 素 data[门,z 从 左 向 右找 一个大 于 pivot

的元 素 data[ 让 ,然后将 data[让和 data[让进行交换 。当 循环结束后再 将 dataL0]和 data[订

进行 交换。算法如下 :

int partition1(SqList * &L)
{

int i 一0,j王L一> length一 1;

ElemType pivot王L -> data[0] ;

// 以 data[0] 为 基准

while (Ci<j)

// 从 区 间 两端交 蔡向中 间 扫 描 , 直 到 i 一 j 为止

{

while (i<j & 开 一 data[和> pivot)

j 一一;

// 从 右 向左扫描 , 找 一 个小 于 等于 pivot 的 元 素

while (i<j && LIL 一 data[中<一pivot)

i 十十;

这 (Ci<j)

// 从 左 向 右 扫 描 , 找 一 个大于 pivot 的 元 素

swap(L -> data[],L -> data[j]); /将 工一 data[站和 L 一 data[]进行交换

}
swap(L -> data[0] ,L 一 > data[);

)}

// 将工->data[0j 和 L世 一 data[申进行交换

3 例如,若顺序表工为 (3|,8,2,7,1,5,3,4,6,0),执行 上 述算法后工 变 为 (1,0,2,3,|3|,

5,7,4,6,8)

,其执行过程如图 2.8 所示 。 一 共经 过 3 轮 循环,其 中 |引是 基准 ,在 算法 执行 后

对 应的下标为4。

解法二: 用 pivet 存放 基准 ,即 工 一> dataL0],;(初值为 0) 从 左 向 右 查找 ,)( 初 值 为 工一>

length一1)从 右 向 左 查找。当 ; 径 ) 时 循环:

7 从 右 向 左找 一 个小 于 等于 pivot 的 data[方,找

到 后 将 data[让放到 data[菇处(用 data[7门覆盖 data[让),从 左 向 右找 一 个大于 pivot 的记

录 data[Li

让,找到后将 data[Li 放 到 data[7让处(用 data[i 覆 盖 data[L门) 。最 后 让 data[让一

|
EX2AsSJ线性表

F标0

1 23453567 8

9

pivot 一-- 全 2

本

人 第1轮循环

交换

本

国

人

第2轮 循环

| 交换

本

广 4

第 3 轮 循环

| 不 交换

10 2

3

团

5

7

4

6

8|

与data[]交换
循环 结束data[0]

图 2.8

”movel算法的执行过程

pivot。 算法如下 :

void partition2(SqList * &KL)

int i一0,j=王L 一 length一1;
ElemType pivot一L -> data[0] ;
while (Ci<j)

// 以 data[0] 为 基准
// 从 顺序 表 两端交替 向 中 间 扫 描 , 直 到 i 一 j 为目

{

while 0j>i 术 & LIL 一 data[]> pivot)

j 一一 ;

// 从 右 向左扫描 , 找 一 个小 于 等于 pivot 的 data[j]

工 一 data[丫二 L -> data[i;

// 找 到 这 样的data[ 门 ,放和人 data[癌处

while (i<j && LIL 一> data[中<一pivot)

i 十十;

工 一 data[丫= 世 一 data[丫 ;

// 从 左向右 扫描 , 找 一 个大于 pivot 的 记录 data[
// 找 到 这 样的data[ 口,放和人 data[] 处

}

工 一 data[i] 王 pivot;

{

}

例如,若顺序表 工 为 (3|,8,2,7,1,5,3,4,6,0),执行 上 述 算法后工 为 (0,3,2,1, 3引,5,

7,4,6,8)

,其执行过程如图 2. 9 所 示 。 同 样需要 3 轮 循环,其中 |引 是 基准 ,在 算法 执行后对

应的下标为4。

尽管对 于 同一 个 数据序列,这 两 个 算法 的 执行结果 不完全 相同 ,但都能 满足 题目 要求,

而 且 它们 的时间 复 杂 度 均为OC0z) 空间 复杂 度 均为O(1) ,都属于高效算法 。

但比较而言,第 2 个 算法 中 移动 元 素 的次数 更少, 所以 算法 更 优。这 是因为在交换两个

元素ab 时 , 若通过 语句“tmp=a; a=b; b 一 tmpi;? 来实现 ,需要 移动 3 次元 素 。

如 果 需 要 多 次 连续 交换 两个相 邻元 素 , 例 如 将 ab、.c 转换为bc\a(即循环左移一个元

素 ) , 若 先 将位置 1

和位置2 的 元 素 交 换得 到 ba\c,需移动 3

次 ,再将位置 2 和位置 3 的元

素交换得到 bc\a,需移动 3 次 ,这 样 一 共 移动 6 次 。而 采用 “tmp=a; a王b; b=c; c一tmp;j”,

同样 满足要 求 ,但 一 共 只 需要 移动 4 次,所以 性 能 得 到 提高 。在 上 述两个 算法中,第 1 个算

数据 结构教程

[第! 5版

F标 0122314156 7

pivorB----Pp

ss

7 15 3

41

0

8

6

9

1

六9

0 827 153 4

6

0

第 1 轮 循环

|

-9

0

8

2

7

1

5

3

4

6

8| 结果

六-一一

0 827 15 3

4

6

8

1

万6

03 2

7 1153 4

6

8

3

广6

0

3

2

7

1

5

7

4

6

8| 结果

-]

03 2

7 15 7

4

6

8

0

人

2 轮 循环

第 2轮循环

=3 六4

0

3 21135 7
,
大 产4

0

3

2?

1

1

5

-一

0

3

2 13 5

7

7

4

4

4

6

8

第 3 轮 循环

6

6

8 结果

8

最 终结

图 2.9

move2算法的执行过程

法 采用 的 是 前 一 种 方法 ,第 2 个 算法 采用 的 是 后 一 种 方法的思路 。

本 例 算法 实际上 是 第 10 章 10. 3. 2 节 介绍 的 快速 排序 的 划分 过 程,主要 采用 第 2 种解

法 ,读者 掌握它对 于 理解 快速排序 过 程 有很大的 帮助 。

【例 2.5】 有 一 个顺序表工 ,假设元素类型ElemType 为 整 型,设计 一 个尽可 能 高 效 的

aa

算法 ,将 所 有 奇数 移动 到 偶数 的 前 面 。
这 里提供两种解法。

解法一: 类 似 例 2.4解法一的思路。i( 初 值 为 0)从 左 向 右 扫 描 ,7( 初 值 为 工一> length一1)

从 右 向 左扫描。当 ; 径 ) 时 循环: 7 从 右 向 左找一 个奇数 元 素 data[四,; 从 左 向 右 找 一 个 偶

数 元 素 data[

让,然后在 ;<7 时 将两者 交换,从 而 把所有 奇数 移动 到 偶数 的 前 面 。算 法 如 下 :

void movel(SqList * &L)

{

int i王0,j王L一> length一1;

while (i<j)

9

|
EX2AsSJ线性表

{

while (i<j &L 一 data[]%2一一0)

j 一一 ;

// 从 右 向左扫描 , 找一个奇数 元 素

while (i<j && L一> data[丫%2王一1)

i 十十 ;

这 (i<j)

// 从 左 向 右 扫 描 , 找一个 偶数 元 素

//若i<j, 将 一 data吕和工 -data[]交换

swap(L 一 > data[让,L -> data[] );

】}

解法二: 用 工一> data[0..

详表示存放奇数的奇数区间 (;i 指向 奇数区间 中 的 最后元 素 ) ,

如图 2. 10 所 示 ,初始时 ;为一1 表示 奇数区间 为空。 下标 0 1
了 从 左 向 有 要 措所有 元 素 ,如 果 7 指向 的 元 素 是 奇数 , [ED
让 ; 增 1 表 示 奇数区间 多 了 一 个奇数 ,然后将 一一
村娄 区站
工一> data[门和工一> data[记交换,7 继续 扫描。循
环 结束 后 ,奇数 区 间 包含了 所 有 的 奇数, 剩 下 的所有

图 2.10 奇数区间

偶数放在后面。算法如下 :

void move2(SqList * &L)

{

int ii 一一1,j;

for (j王0;j < 王 L 一 length一1;j十十)

迁 (L-> data趾%2=一1)

//i 指向 奇数时

{ 这 十 ;

让 (il一j)

// 奇数区 间 个 数 增 1
//若ji 不 为j, 将 二 > data[口和 L -> data[j]交换

swap(L -> data[i ,L -> data[] );

】}

上 述 两 个 算法 的时间 复 杂 度为OC0x) 、 空 间复杂度为0(1) ,都属于 高 效 的 算法。

线性 表 的 链 式 存储 结构 “站

顺序 表 必 须 占用 一 整块事先 分配 大小 的 存储 空间,这样会降低存储空间的 利用率 ,为此

|

有 了 可 以 实现 存储 空间 动态管理的链 式存储 结构 一 一链表。本 节讨论链 式存储 结构 及 其 基

本 运算 的实现过程。
231 线性 表 的 链 式 存储 结构 一 “链表

扫-扫

时

线性 表 的链 式 存储结构 称 为 链表 (linked list)

。 其 中 每 个存储 结 点 不仅包 家

含 元 素 本 身 的 信息 ( 称 为 数据 域) ,而 且 包 含 表示 元 素 之间 光 辑 关 系 的 信息 ,在 C/C++语言中

由 于线性表中的 每 个元素 最 多只有 一 个 前 驱 元素和 一 个后继元素 , 所以当 采 用 链 式 存

储时 ,一种最 简单.最 常用的 方法 是 在 每 个 结点中 除 包 含有数据 域 以外 只 设置一个 指针 域 ,

数据 结构 教程

虹 第人5 【版

用 于 指向 其后继 结 点 ,这 样构成的链表 称 为 线性 单 向 链接 表 , 简 称 单 链 表 (singly linked

list);, 另 一 种 可 以 采用 的 方法是 在 每 个 结 点 中 除 包含有 数值 域 以 外 设置 两个指针 域,分 别

用 于 指向 其 前 驱 结点和 后 继 结 点,这 样 构成 的链表 称 为 线性双向 链接 表 , 简 称 双 链 表

(Cdoubly linked list)。若 一 个 结 点 中 的 某 个 指针 域 不需要 指向 其 他任何 结 点 , 则 将 它 的 值置

为空 ,用 常量 NULL 表示 。

在 线性 表 的 链 式 存储中 ,通常 每个链表带有 一 个头结 点 ,并 通过 头 结 点 的 指针 唯一标识

该 链表 , 称 之 为头指 针 (head pointer) ,相应 的 指向 首 结 点 或 者开始 结 点 的指针称为首指针

(first pointer) ,指向尾结点的 指针 称 为 尾 指针 (tail pointer)。

从 一 个 链表 的 头 指 针 所指的头 结 点 出 发,沿 着 结 点 的 链 ( 即指针 域 的 值)可 以 访问 到 每

个 结 点。如 图 2. 11 所 示 , 图 2. 11(a)是 带头 结 点 的 单 链表 head,图 2. 11(b)是 带头 结点的 双

链表 dhead ,分 别称为head 单链表 和 dhead 双 链 表 。

线性表

(an 00

head 一一|

一| G

| GD 一 人

dhead | 国 攻 |

HHilol 人 = 二]|o|

(b)双链表

图 2.11 链表 示意 图

例如 ,对 于 第 1 章 中 例 1. 1 的 巡 辑 结构 City, 采 用 带头 结 点 的单链表 存储时 的 结构 如

图 2. 12 所 示 , 即 对 应图2. 13 所 示 的示意图,这时 2三70 作为头结点的地址。其 中数据域包

含 区 号 ,城市名和说 明 等 信息 。

在 顺序 表 中 ,逻辑上相 邻 的元素 对 应 的 存储 位 置也相 邻,所以 当 进行插入 或 删除 操

作 时 通常需要 平均 移动 半 个 表 的 元素, 这 是相当 费时 的 操作。在 链表 中 ,逻辑上相邻的

元 素对 应 的 存储 位 置 是通过 指针 来 链接 的 ,因而 每个结 点 的 存储 位 置 可以任意 安排,不

必要求相邻,所以当 进 行插入 或 删除操作 时 只 需要 修改 相关 结 点 的 指针 域即 可 ,这 样 既

方便又省时。

正 因为 顺序 表 是 线性 表 的 直接 映射,所以具有 随机 存 取特 性 ,即 查 找第;个 (序号)元素

对 应 的时间 复 杂 度为O(1) ,而 链表 不具有 随机 存 取 特 性 。

2AS 性表

地 址

区 号

城市 名

说 明

下 一个结 点地址

70

io

ao | ER

180

025

Nanjing

南京 ,江 苏省 省 会

029

Xian

西安 ,陕西省省会

250

50

460

021

Shanghai 上海,直 辖 市

100

而

人

180

击

310

图 2.12

”City 对 应 的单链 表 存 储结构

-一一

010

021

027

Beijing

Shanghai

Wuhan

029

Xian

025

Nanjing

首都

直辖 市 湖北省省会|

|陕西省省会|

|江苏省省会

一|

一|

一|

|

一|

人

图 2.13

City 对 应 的单链 表 存 储 结 构 示 意图

是指结点中数据元素
另外,顺序表的存储密度比较高。所谓 存储 密度(storage density)

本 身 所 占 的 存储量和 整个结 点 占用 的存储量之比 , 即

.,, _ 结点中 数据 元素所 占 的在储量

存储 密度 =

殖 点 所 中 的 存储量

一 般情 况 下 ,存储 密度越大 ,存储 空间 的利用 率 越 高 。显 然 ,顺序 表 的 存储 密度 为 1(顺

序 表 中 没有 指针 域 , 每个顺序 表 元 素存放 一 个 线性 表 元 素 ) ,而链表 的 存储 密度小于 1。 例

如 , 若 单链表 的 结 点 数据 均 为整数 ,指针 所 占 的 空间 大小 和整数元素所占 的 空间大小

相同 ,

则 单链表 的 存储 密度为50%。

要-要

232 单链表

在单链表中,假设每个结点的类 型用 LinkNode 表示 , 它应包括 存储 元

素 的 数据 域,这 里 用 data 表示 ,其类 型 用 通用类 型标识符 ElemType 表示 ,

还 包括 存储后继结 点 位 置 的指针 域,这里 用 next 表示 。LinkNode 类 型 的声明 如 下 :

typedef struct LNode

{

ElemType datai

// 存 放 元 素 值

Struct LNode * nexti

// 指向后继结点

} LinkNode;

// 单 链表 结 点 类 型

数据 结构教程

[第! 5版

为 了 简单 ,假设ElemType 为 int 类型,使 用以下自定义类型语句 :

typedef int ElemType;

在 后 面 的 算法 设计 中 ,如 果 没有特别 说 明 , 均 采用 带头 结 点 的 单链表 ,在 单 链表 中 增加

一 个 头 结 点 的 优点如 下 :

(1) 单 链 表 中 首 结 点 的 插入和 删除操作 与其他 结 点 一 致 ,无须进行 特殊处理 。

《2) 无 论单链表 是 否 为 空 都有一 个头结点,因此 统一了空表和 非空表 的处理 过 程 。

在 单链表 中 ,由 于 每 个 结点只 包含有一 个 指向 后 继 结 点 的指针 ,所以 当 访 问 过 一 个 结 点

后 只 能 接着 访问 它 的后继 结 点 ,而 无法访问 它 的 前 驱 结 点,因此 在 进行单链表 结 点 的 插入和

删除时 就不能 简单地 只 对 该 结 点 进行 操作 ,还 必须 考虑其 前 后的结 点 。

全 搬入 和 吓傈 结 R 的探人

在 单链表 中 ,插入和 删除结 点 是 最 常用的 操作 ,是建立 单链表 和 相关 基本 运算 算法 的

基础。

1) 插入结点的操作

这 里 插入指 在 单链表 的 两个数据 域 分别 为c 和 2 的 结 点 (已知 < 结点的 指针之) 之间 揪

入 一 个数据域为z的结点(由 s 指向它),如图 2.14(a)所示。其操作是首先让 z 结 点 的 指

针域(*一> next) 指 向 0结点(2一> next),然后让 a 结 点 的 指针 域 ( 一 > next) 指 向 z 结点

(3) ,从 而 实现 3 个 结 点 之 间 浊 辑 关 系 的 变化 ,插入过 程如 图 2. 14(b)和(c)所示,图2.14(d)

是插入后的结果。

忆

忌

忆

忌

aa -| 一 一 0- 一

S-= 工 |信

-|

|

(a) 插入 前

万 A\

(b) s->next=p->next:

... 和| 4

D | 一 一

忆

|

了

人

忆

-

| 0 -| 二 一 |

S 一| 世

(c) p->next=s:

(d) 插入后

图2.14 在 单 链 表 中 插 人 结 点的过 程

pe

说明: 为了描述 简单,在 链 式 存 储 结构中 由指针 妃 所指向 的 结 点 称 为 结点 户 或者也

结点。

上 述 指针 修改用 CVC++语句描述如下 :

S 一 next一p 一> next;

P -> next一s;

注意: 这 两 个语句 的顺序不能颠倒,否则先执行"p一>next一s; ”语句 ,指向 六 结 点 的指

|
EX2AsSJ线性表

针就不存在了,再 执行“s 一 > next一pb一> next;”语名 ,相当 于执行“s一>next一si”,这样插

入 操作错误 。

所以 在 单 链 表 中 插入 一 个 新结 点 需要 找到 插入后 的 前 驱结 点 。

2) 删除结点的操作

这 里 删除指 在 单 链 表 中 删除结 点 六 的 后 继结 点 ,如 图 2. 15Ca)所示 ,删除 2 结 点 的 操作

是让a 结 点 的 指针 域 ( 一> next) 指 向 c 结 点(一> next一> next) ,其过程如图2.15(b)所

示。上 述 指针 修改 用 CVC++语句描述如下 :

p -> next一p -> next 一> next

人

人 [|

ad 二 症| 一 0 站

(a) 删除前

(b) 删除后

图 2.15 在 单链表 中 删除 结 点 的 过 程

所 以 在单链表 中 删除 一 个结 点 需要 找到其前驱结点。

一般情况下 ,在 删除一个 结 点 后 还需要 灵 放 其 存储 空间 ,实现 删除上述 2 结点 并 释放其

存储 空间 的语句 描述如下 :

q 一D 一 next;

p 一 > next一q一> next;
free(q) ;

V//a 临时保存被删结点

// 从 链表 中 删除结点q
//释放结点 q 的空间

这 里 介绍 整体 创建 单链表 ,即由数组 元素w[0..m

一1创建单链表 工 。

整体建立 单链表 的常用 方法有以 下 两种。

1) 头 播法
该方法 从 一 个 空表开 始 依次 读 取

数组<中 “人

的元素,生成一个新结点(由、指向它),将读取的
数组 元 素存放 到 该结 点的数据域中 ,然后将其插入
到 当前 链表 的 表头上 ( 即 头 结 点 之 后) ,如 图 2. 16

所 示 ,直到 数组 “ 的所有元 素 读 完 为 止 。采 用 头
捅 法建表 的 算法如 下 :

void CreateListF(LinkNode * &L,ElemType a[] ,int n)

{

LinkNode *s;

工 一(LinkNode * )malloc(Csizeof(LinkNode) ) ;

-LT 才~... 一 [LA
人 十入:snexCL>next Unextrss

图 2.16

将 * 所 指 结 点插入 到 表 头

工 二 next=NULL;

// 创 建头结 点 ,其 next 域 置为NULL

for (int i=0;i<nii 十十)

// 循环建立 数据 结 点 s

{ , s 一(LinkNode * )mallocCsizeof(LinkNode) ) ;

s 一> data一a[];

// 创 建数据结点 s

数据 结构教程

[第! 5版

s 一> next一 一> nexti

// 将 结点s 插 和人到 原 首 结点之 前 、 头 结点之 后

工一 next一S;

}

本 算法 的时 间 复 杂 度为O(0z) ,其中?为 单链表 中 数据结 点的个 数 。

若 数组 w 包含4 个 元 素1.2.3 和 4, 则 调用 CreateListF(L,a,4)建 立 的 单链表 如 图 2. 17 所

示 , 所以 在 采用 头 插 法 建 表 时 单链表 中 数据 结 点 的 顺序 与 数组 a 中 元 素 的 顺序相反 。

5 一

5

|

二| 3

| 2

一| 1 |从

图 2.17 一个单链表 荆

2) 尾 插 法

该 方法从 一 个 空表开始 依次 读 取 数组 中 的 元 素,生 成 一 个 新 结 点 *, 将 读 取 的 数组 元

素存放 到 该结 点 的 数据 域中,然后将其 搬入 到 当前 链表 的 表尾上 ,如图 2. 18 所示 ,直到 数组

4a 的所有 元 素 读 完 为 止 。为 此 需要 增加 一 个 尾指针 -~, 使 其始终指向 当前链表 的 尾结 点 ,每

插入一个新结点后让 指向 这 个 新 结 点 ,最 后还需要 将 ~ 所指结 点 ( 尾结 点 ) 的 next 域置为

空 。采 用 尾 插 法建表 的 算法如 下 :

void CreateListRCLinkNode * &L,ElemType a[] ,int n)

{人 LinkNode *s,xr;

工一(LinkNode * )malloc(Csizeof(LinkNode)) ;
T 一 Li;
for (int i一0;i<nii 十十)

// 创 建头结点
//r 始 终 指向尾 结 点 ,初始时 指向 头 结 点
// 循环建立 数据 结 点

{ , s 一(LinkNode * )malloc(sizeof(LinkNode)) ;

s 一> data一a[];

IT一> next一Si;

IT 一 S;

}》

r 一 > next王NULL;

/创建 数据 结点 s

/将 结点 s 插 和人到 结点r 之 后

//尾结点的 next 域 置为NULL

人

办

个 插入 : r->next=s;

图 2.18 将 * 所 指 结 点 插 和人到 表 尾

本 算法 的时 间 复 杂 度为O0z) ,其中 7 为 单链表 中 数据结 点 的 个 数 。

若 数组 a 包含 4 个元 素 1.2.3 和 4, 则 调用 CreateListR(CL,a,4)

建立的单链表如图2. 19 所

示 , 所以 在 采用 尾 插 法 建 表时 单 链表 中 数据 结 点 的 顺序 与数组 a 中 元 素 的 顺序相同。

|
EX2AsSJ线性表

工 一|

| 1

m 2

| 3

一| 4 | 人

图 2. 19 一个单链表 工

注意: 整体 创建单链表 的 两个算法 特别 是 尾 插 法建表 算法 是 很多其他

复杂 算法 的 基础,读者 必须 牢固 宫握。例 如 将 两 个单链 表 合 并 成 一 个单链

表 等 都 是利用 尾 插 法建表 算法实现 的 。

3 于 线 作 表 基本 运算 存单链表 中 的 实现

采用 单 链表 实现 线性 表 基 本 运算 的算法如下 。
1) 初始 化线性 表 InitList(&L)
该运算 建立 一个空 的单链 表 , 如 图 2. 20 所 示 , 即 创

人 人

人

建 一个头 结 点 并 将其next 域 设 置 为 空 。算法如下

图 2. 20 创建一个空的单链表

void InitList(LinkNode * &L)

{ , 工 =(LinkNode * )malloc(sizeof(LinkNode)) ;

工一next王NULL;

/创建头结点,其 next 域 置为NULL

}

本 算法 的 时 间 复 杂 度为 O(1) 。

2) 销毁 线性 表 DestroyList(&L)

该 运算 释放 单 链 表 工 占用 的 内 存 空 间 , 即 逐一 释放 全 部 结 点 的 空间。其 过 程 是让 pre、

娘 指 向 两个相 邻的结 点 (初始时 pre 指向头结点,户指 向 首 结 点),如 图 2. 21 所 示 。 当 户 不

为空时循环: 释放 结 点 pre, 然后 pre\ 同步后移一个 结 点。循 环结束后,pre 指向尾结点,

再将其释放。算法如下 :

void DestroyList(LinkNode * &L)

{

LinkNode * pre一L, xp 一 L 一> nexti;

//pre 指向 结 点 p 的 前 驱 结 点

while (p!=NULIL)

free(pre);

Pre 一 p;

P 一 pre 一> next;

{

}

freeCpre) ;

)}

// 扫 描 单链表 工

// 释 放 pre 结点

//pre,p同步后移一个结点

// 循 环结束时 p

指向尾结点,释放它
为 NULL,pre

也

儿子 四-寺-

pre

忆

一|

二

=区可入

图 2.21

pre\力指向两个相邻的结点

本 算法 的时 间 复 杂 度为 00z) ,其 中 ?为 单链表 中 数据 结 点 的个数 。

数据 结构教程

[第! 5人版

3) 判断 线性 表 是 否 为 空表 ListEmpty(L)

该运算在单链表 工 中 没有数据 结 点时 返回 真,否则 返回 假 。算法如下 :

bool ListEmpty(LinkNode * L)

{

}

return(L -> next 一一NULL) ;

本 算法 的时 间 复 杂 度为O(1)。

4) 求线性表的长度 ListLength(L)

该运算返回单链表 工

中数据结点的个数。由 于 单 链 表 没有存放 数据 结 点 个 数 的信息 ,

需要 通过 遍历 来统计。其 过程是让 户 指 向头结 点 ,用 来 累计 数据 结 点 个数(初始 值为0),

当 户 不 为 空时 循环: ?增1,2指向下一个结点。循 环结束后返回>。 算法如下 :

int ListLengthCLinkNode * L)

{

int n一0;

LinkNode * p一;

//p 指向 头 结 点,n 置为 0( 即 头 结 点 的序号为0)

while (p ~> next!王NULL)

nn十十 ;

p王p 一> next;

{

}

return(n) ;

// 循环结束,p 指向 尾 结 点 ,其序号 n 为 结 点个数

}

本 算法 的时 间 复 杂 度为OC0z) ,其中 ) 为 单 链表 中 数据 结 点 的 个 数 。

5) 输出 线性 表 DispList(L)

该运算 逐一 扫描 单链表 工 的 每个数据结点,并 显示 各 结 点 的 data 域值。算 法如 下 :

void DispList(LinkNode * 工)

{

LinkNode * p 一 L 一 nexti;

V//p 指向首结点

while (p!王NULL)

//p 不 为NULL,输出 p 结 点的 data 域

printf("%d",p 一> data);
p王p 一>next;

V//p 移 向 下 一 个 结 点

{

}

printfC"N\n");

)}

下 本 算法 的时 间 复 杂 度为 OC0z) ,其

中 为 单链表 中 数据 结 点的个 数 。

6) 求 线性 表 中 的 某 个 数据 元 素值 GetElem(L ,1&e)

该 运算 在 单链表工 中 从 头 开始 找到 第 ; 个 结 点 , 若存在第;个 数据 结 点 , 则 将其data域

值 赋 给 变量。。其 过 程 是让 户 指 向 头 结 点,7 用 来 累计 遍历 过 的 数据 结 点个数 ( 初始值 为

0) , 当 7 <i 上且刀不 为 空 时 循环: 7) 增 1,2指向下一个结点。循 环 结束 后有两种情况 ,若 包 为

空 ,表示单链表工 中 没有第 ;个数据结点(参数 ;错误) ,返回 false; 否则 找到 第 ;个 数据 结

点 ,提取它的值并返回 true。 算法如下 :

(so

|
EX2AsS线性表

bool GetElem(LinkNode * L,int i,ElemType &e)

{

intj=0;

LinkNode * p一工;

//p 指向头结点,j置为 0( 即 头 结 点 的 序号为0)

过 (i<王0) return false;

/Wi 错误 返回 假

while (Gj<i&& p!=NULL) // 找 第 i 个 结 点

jj十十;

p王p 一> next;

{

}

让 (p==NULL)

//不存在第 i 个数据结点,返回 false

return false;

ee王p 一> datal;

Teturn truei

else

{

》}

)}

// 存 在 第 i 个数据结点,返回 true

本 算法 的时 间 复 杂 度为 OC0z) ,其 中 ) 为 单 链表 中 数据 结 点 的 个 数 。

7) 按 元 素 值 查找 LocateElem(L,e)

该运算在单链表工 中 从头开 始 找第一 个 值 域与e 相等的结点 , 若 存在 这 样 的结 点 , 则返

回 逻 辑 序 号 ,和 否则 返回0。 算法如下,

int LocateElem(LinkNode * 工,ElemType e)

int i 一 1;
LinkNode * p 一 工一 next;
while (p!I王NULL && p -> datal一e)

//p 指向首结点,i置为 1(即 首 结 点 的 序号为1)
// 查 找 data 值为e 的 结 点 ,其 序号 为 i

p 王 p 一 next;

i十十;

{《

}

这 (Cp==NULL)

Teturn(0);

else

Teturn(i);

// 不存在值为e 的 结 点 ,返回 0

// 存 在 值为e 的 结 点 ,返回其逻辑 序号 i

{

)》

本 算法 的时 间 复 杂 度为 O0z) ,其 中 ) 为 单 链表 中 数据 结 点 的 个 数 。

8) 插入 数据 元 素 Listlnsert(&L ,1 ,e)

该 运算 的 实现 过 程 是 先 在单链表 工 中找到第;一1 个 结 点 ,由 户 指向它。若存在这样的

结点 ,将 值为e 的结 点 (* 指向它)插入到妃 所 指 结 点 的 后 面 。算法如下 :

bool ListInsert(LinkNode * &L,int i,ElemType e)

{1

intj=一0;

LinkNode * p一L, xs;

//p 指向头结 点 ,j 置为 0( 即 头 结 点 的 序号为0)

计 (i< 一 0) return false;

//i 错 误 返 回 false

while (Gj<i一1 && p!=NULIL)

// 查 找 第 i一1 个 结点 p

jj十十;

p 王 p 一>next;

{

)》

数据 结构教程

[第! 5版

这 (p=王NULL)

Teturn false;

else

// 未找到第 i一1 个 结 点 ,返回 false

// 找 到 第 i 一1 个 结 点 p, 插 和人新 结 点 并 返回true

{ s 一(LinkNode * )malloc(sizeof(LinkNode) ) ;

S 一> data 一 ei

// 创建新结点 s,其data域置为e

s 一 next一D 一 nexti

// 将 结 点 s

插 人 到 结 点 p 之后

p 一> next一S;

Teturn true;

】}

本 算法 的时 间 复 杂 度为OC0z) ,其中 ) 为 单 链表 中 数据结 点 的 个 数 。

9) 删除数据 元 素 ListDelete(&L ,)&e)

该运算 的 实现 过 程 是先在 单 链表 工 中找到第;一1 个 结 点 ,由 刀 指向 它。若存在这样的

结 点,且 也 存在 后 继结 点 (由 4 指向它), 则 删除 g 所 指 的 结 点 ,返回 true; 否则 返回 false,表

示 参数; 错误。算 法如 下 :

bool ListDelete(LinkNode * &L,int i,ElemType &e)

{

intj=0;

LinkNode * p 一

L,* qi;

过 (i< 一0) return false;

//p 指向头结点,j置为 0( 即 头 结 点 的 序号为0)

//i 错 误返回 false

while (0j<i 一1 && p!I=NULL)

// 查 找 第 i 一 1 个 结 点

{

jj十十;

p一p 一> next;

}
这 (p=一NULL)

return false;

else
人 q一pp 一 nexti

i (q==王NULL)

Teturn false;

e 一 q 一> datai;
P 一>next一q 一> next;

free(q) ;

Teturn truei

】}

// 未找到第 i一1 个 结 点,返回 false

// 找 到 第 i一1 个 结 点 p
//q 指 向 第 ii个 结点
// 若 不存在第 i 个 结 点 ,返回 false

// 从 单 链 表 中 删除 q 结 点

// 释 放 q 结点

// 返 回 true表示成功删除第 i 个 结点

本 算法 的时 间 复 杂 度为 O0z) ,其 中 ?为 单链表 中 数据结 点 的个数 。

【例 2.6】〗 有 一 个 带头 结 点 的 单链表 工 = (aa ,0 az , 六 ,ao) ,设计 一 个 算法 将 其

拆 分 成 两 个带头结 点 的 单链表 工1 和 工 2 ,其中 1 一(al ,az ,as),L2一(2 0 0),

利用 原单 链表 工 中 的所有 结 点 通过 改变指针 域 重组 成 两个单 链表

工1和 工2。由于工1 中 结 点 的 相对顺序 与工 中 的相同 ,所以 采用 尾 插 法

建立

单链表 工1; 由于工2 中 结 点 的相对 顺序 与工 中 的 相反 ,所以 采用 头 插 法 建

立 单链 表 工2 。算法如下 :

扫 一扫

(2

|
EXA2AsSJ线性表

void split(LinkNode * &L,LinkNode * &L1,LinkNode * &L2)

{

LinkNode * p 一 L 一> next,

xq,xTrli

L1 一 L;
zIL 一 L1;
L2 一(LinkNode * )malloc(sizeof(LinkNode));

//p 指向 第 1 个 数据 结 点
//LI1 利用 原来 L的头结点
//rl 始终 指向 L1 的尾结 点
// 创建L2 的 头 结 点

L2 -> next=NULL;

//置L2 的 指针 域为NULL

while (p!I=NULL)

{

rrl -> next一pi

// 采 用 尾 播 法将 p(data 值为 ai) 插 入 L1 中

I 一 p;
p一p 一> nexti;
q一p 一> nexti

//p 移 到 下 一 个 结 点 (data 值为bi)
// 头 揪 法 会 修改 结点 p 的 next 域,用 q 保存结点 p 的后继 结 点

p 一 next王L2 -> next; ,// 采 用 头 揪 法 将 结点 p 插入 L2 中

工2 一 next一pi;

p 一 q;

}

//p 重 新 指向 at 的 结 点

ITl 一 next王NULL;

// 尾 结 点 next 置空

)}

【例2.7】 设计 一 个 算法 ,删除 一 个单链表 工 中 元 素 值最大 的结 点 (假设 这 样的结点

唯一) 。

扫-要

在 单链 表 中 删除一个结 点 先 要找到 它 的 前 驱结 点 ,用指针 户 扫描

整个单链表,pre 指向结 点 户 的 前 驱 结 点 ,在 扫描时 用 maxp 指向 data 域值

最 大 的 结 点,maxpre 指向 maxp 所指结 点 的 前 驱结 点 。当 单链 表 扫 措 完 毕

后 ,通过 maxpre 所指 结 点 删除其后的结点 , 即 删除了 结 点 值最大 的 结 点 。

视频讲解 算法如下 :

void delmaxnode(LinkNode * &EL)

{

LinkNode * p 一 L 一> next, * pre一L, * maxp一D, x* maxpre一prei

while (p!I=NULL)

//用 p扫描整个单链表, pre 始终 指向 其前驱 结 点

{

计 Cmaxp->data<p一data)

, // 若找到 一 个更大 的 结 点

{ maxp一p;

Imaxpre一pre;

// 更新maxp

// 更新maxpre

】》
pre 一 p;

}

//p、pre同步后移一个结点

maxpre 一> next一maxp 一> nexti;

//删除maxp 结 点

freeCmaxp) ;

// 释 放 maxp 结点

】}

【例 2.8〗 有 一 个 带头结 点 的 单 链表 工 ( 至 少 有 一 个 数据结点),设计一个算法使其元

素 递增有序排列。

由 于 单链表工 中 有 一个 以 上 的 数据结 点 ,首先 构造 一个只 含 头结点和 首 结 点 的 有

序 单 链表 (只 含 一个数据结 点 的 单 链表 一 定 是 有序 的 ) 。然后 扫描单链表 工 余下的结点(由

妃 指 向), 在 有 序 单 链 表 中 通过比较找插入结点 妨 的 前 驱结 点 (由 pre 指向它),在 pre 结点

之 后 插入 户结点,如图 2.22 所示 , 直 到 如= 王 NULL 为 止(这里 实际上 采用 的 是 直接插入 排

数据 结构 教程

5全

序 方法 ) 。算法如下,

人

22芝-本 - 一本和

“>

一 一|

图 2.22

将 结 点久有 序 插入 到 有 序 单链表 中

void sort(LinkNode * &L)
{

LinkNode * p,*pre,xqi

p 一 工 -> next -> next;

//p 指向 工 的 第 2 个 数据 结 点

工一next 一 next=NULL; , // 构造只 含 一个数据 结 点 的有序 单 链 表

while (p!=王NULL)
{ qda=p一next;
pre 一 L;

//q 保存p 结 点 后 继 结 点 的 指针
// 从 有 序 单链表 开头 进行比较 ,pre 指向 插 和人结 点 的 前 驱 结 点

while (pre -> next!王NULL 下 & pre 一> next 一> data<p 一> data)

pre一pre 一> next;

//在有 序 单 链表 中 找 插入 p 所 指 结 点 的 前 驱 结 点(pre 所 指向 )

p 一 next=pre-> next; //在 pre 所 指 结 点 之后插入 p 所 指 结 点

pre 一> next一pi;
D 一 qi

// 扫 描 原 单链表 余下 的 结点

}

}

233 双 链 表

对 于 双 链 表 , 采 用 类 似 于 单链 表 的 类 型声明 ,其结 点 类型DLinkNode

的声明 如 下 ;

视频讲解

typedef struct DNode

{

ElemType data;

struct DNode * prior;

struct DNode #* nexti;

// 存 放 元 素 值

// 指 向 前 驱 结 点

//指向后继 结 点

} DLinkNode;

// 双 链表 的 结 点 类 型

在 双链表 中 ,由 于 每 个结 点 既 包 含一个指向 后 继结 点 的指针 ,又 包含一个指向 前 驱 结 点

指针 ,所以 当 访问 过 一 个 结 点 后既可以 依次 向 后访问 每 一 个结 点 ,也 可以 依次 向 前 访问 每一

个结点。因 此 与 单 链表 相比 , 双 链表 中 访问一个结 点 的 前 后结 点 更 方便 。

和 -

PE

整体 建立 双链表 也 有 两 种方法 , 即 头 插法和 尾 插 法。采 用 头 插 法 建立

双链 表 的 过程和 单链表头 皇法相似 ,算法 如 下 ,

视频讲解

void CreateListF(DLinkNode * &L,ElemType a[] ,int n)

// 采 用 头 揪 法 建立双 链 表

// 由 含有 n 个 元 素的数组 a 创建 带头 结 点 的 双 链表 工

{

。 DLinkNode * s;

工 一(DLinkNode * )malloc(sizeof(DLinkNode) ) ;

// 创 建 头 结 点

|
EXA2AsSJ线性表

L 一 prior一L ->next王NULL;

// 前 后指针域置为NULL

for (int i=0;i<nii 十十)

// 循环建立 数据 结 点

{1 ,s= 一(DLinkNode * )malloc(Csizeof(DLinkNode)) ;

s 一> data一a上加;

// 创 建 数据结点 s

s 一> next一L 一 next;

//将s 结 点插和人到 头 结 点 之 后

计 (L 一 nextl=NULIL)

//若工 存在 数据 结 点 ,修改 L -> next 的前驱 指针

工 一> next 一> prior一Si;

工 一 next一s;

s-> prior一LL;

}

采用尾插法 建立 双 链 表 的 过 程和 单链表 尾 插 法 相似 ,算法如下:

void CreateListR(DLinkNode * &L,ElemType a[] ,int n)

// 采 用 尾 插 法 建立双 链 表

// 由 含有mn 个 元 素的数组 a 创建带头 结 点 的 双 链 表 工

{

。 DLinkNode *s,*T;

工 一(DLinkNode * )malloc(sizeof(DLinkNode)) ;

// 创 建 头 结 点

I 一 L;

/人 始终 指 向尾结 点,开始 时 指向 头 结 点

for (int i=0;ii<nii 十十)

// 循 环 建立 数据 结 点

{1 ,s= 一(DLinkNode * )malloc(Csizeof(DLinkNode)) ;

s 一 data一a[j;

// 创 建数据结点 s

IT一>next一sis 一> prior一IT;

//将s 结 点插入到r结点之后

TI 一 Si

}

//r指向尾结点

T 一 next一NULL;

//尾结点的 next 域 置为NULL

】}

在 双 链 表 中 ,有 些 运 算 ( 如 求 长度. 取 元 素 值和查找 元 素等) 的 算法 与单

链表 中 的 相应 算法 是相同 的 ,这 里不多讨论 。但 双 链 表 中 插入和 删除结 点

是 不 同 于 单 链 表 的 ,下 面 分别 介绍 双链 表 的 插入和 删除操作 算法 。

人
在 双 链 表 中 妃 所 指结 点 之 后搬入 一 个结 点 ,其 指针 的 变化 过 程 如 视闫讲解

假设

图 2. 23 所示 。 其 操作 语句 描述如 下 ( 共 修 改 4 个指针域) :

S 一 > next一D 一 > nexti;
p -> next -> prior一s;

Ss

一 > prior一p;

p 一>next一S;

//将 s 结 点 插 和人到 p结点之后

ss

注意:

在 上 述描述语身中 ,修改 p 一> next 地 址 尽量 放 在 后 面 执行,否则 会 因为找不到

结点访 的 后 继 结 点 而 导致插入 错误 。

在双链表工 中的第; 个 位 置 上搬入值为e 的结 点时 采用 类 似单链 表 的 插入 过 程,先 查

找第 ;一1 个结 点 (由 馆 指 向它), 然 后在 户 所 指结 点 之 后插入 一 个 新结 点。算法如下 :

5 一=| 人

入

5 一=| 入

|

(a) 插入 前

书 忆

(b) s->next=p->next

耸

一 上 吕 全 二 , 二 上

5 一一| 八

上

5 一 |

|

(c) p->next->prior=s;

(d) s->prior=p;

从

一 |

| 访-

1

万

、

四

、

一 |

| 二 ma

-H

王

(e) p->next=s;

(Gf) 插入后

2.23 在 双 链 表 插 人 结 点的过 程

bool ListInsert(DLinkNode * &L,int i,ElemType e)

{

intj=一0;

DLinkNode * p 一 L,* si;

迁 (i<一0) return false;

//p 指向 头 结点,j 设置为0

//i 错 误 返 回 false

while (j<i一1 && p!=NULIL)

// 查 找 第 i 一 1 个 结 点

jj十十;

p王p 一> next;

{

}

if (p=一NULL)

return false;

else

// 未找到第 i一1 个 结 点 ,返回 false

// 找 到 第 i一1 个 结点p

{ , s 一(DLinkNode * )malloc(sizeof(DLinkNode) ) ;

s 一> data 一 ei;

// 创建新结点 s

s 一> next一pD 一> nexti;

//在p 结 点 之 后插入 s 结点

让 (p 一 next!l==NULL)

//若p 结 点 存在后 继 结 点 ,修改 其前驱 指 针

Pp 一 next 一> prior一Si;

s 一> prior一pi;

P 一>next一Si

Teturn true;

)}

本 算法 的时 间 复 杂 度为00z) ,其中 为 双 链表 中 数据 结 点 的个数 。

假设 删除双 链 表 工 中 结 点 祖 的 后 继结 点 ,指针 的 变化 过 程 如图 2. 24 所 示 。 其操作 语

|
EX2AsSJ线性表

句 描述如下 ( 共 修 改 两个指针 域) :

p 一 > next 一 q 一> next;

q 一> next 一> prior一p;

AN

AN

(a) 删除 前

万 机 Ge

或p->next=q->next;
(b) p->next=p->next->next;

忌 EN

到|

一一|

...

|

1

产 一 ...

和

(c) q->next->prior=p

区

(d) 删除后

2. 24 在 双 链 表 删除结 点的过 程

在双链表工 中 删除第; 个 结 点 时 采用 类 似 单链表 的 删除过 程,先 查找 第 ;一1 个 结点 刀 ,

然后删除 结 点 的后继结点。算法如下 :

bool ListDelete(DLinkNode * &L,int i,ElemType &e)

{1

intj=一0;

DLinkNode * p 一 L,* qi;

//p 指向头结点,j 设置为0

迁 (i<一0) return false;

/Vi 错误 返回 false

while (Gj<i一1 && p!I=NULL) // 查 找 第 i 一 1 个 结 点

jj十十;

p一p 一>next;

{

}

这 (p==NULIL)
Teturn false;

else

//未找到第 i一1 个 结 点

// 找 到 第 i 一 1 个 结点(由 p 指向它)

aa

{

, q王p 一> nexti

//q 指 向 第 i 个 结 点

让 (q==NULL)

// 当 不存在第 i 个 结 点 时 返回 false

Teturn false;

e 一q 一 data;

p 一> next一q 一> nexti

迁 (p 一> nextl王NULL)

// 从 双 链 表 中 删除结 点 q
//若p 结 点 存在后继 结 点 ,修改 其 前 驱 指针

数据 结构教程

[第! 5版

Pp 一> next 一> prior一pi;

freeCq) ;

Teturn true;

// 释 放 q 结点

)}

本 算法 的时 间 复 杂 度为 00z) ,其

中 为 双 链表 中 数据结 点 的个数 。

由 于 在 双 链 表 中 通过 一 个结 点 既 可以找到 它 的 前 驱结 点 ,又 可 以找到 它 的 后 继结 点,所

以在双链表 工 中 实现 插入和 删除第;个结点时 可以先查找 第 ;个结点(由 之 指向它) ,搬入

时在包 所指结 点 的 前 面插入 一 个 新 结点,删除时 通过 之 所指 结点 的 前 驱 结点 来 删除它 。

【例 2. 9] 有 一 个带头结 点 的 双 链 表 工,设计 一 个 算法 将 其所有 元 素 道

置,即第 1 个元 素 变 为 最后一 个元 素 ,第 2 个 元素变 为 倒数第 2 个元 素 ......

最 后 一 个元 素 变 为 第 1 个 元 素 。

先 构 造 只 有 一 个头结 点 的空双链表 工 (利用 原来 的 头结 点)

,用户扫 各得

描 双 链表 的所有 数据结 点 ,采用 头 搬 法将户 所 指结 点插入到工 中 ,如图2. 25 所示 。 算法如下,

void reverse(DLinkNode * &L)

// 双 链表 结 点 着 置 算法

{

。 DLinkNode * p 一 二 next,x*qi

//p指向首结点

工僵next王NULL;

while (p!I=NULL)

{

, q=p一nexti

p 一> next 一 一> next;

// 构 造具有 头 结 点的双 链表 工

// 扫 描 工 的所有数据结点
// 会 修改p 结 点的next域,用 q 临时 保存 其后继 结点
// 采 用 头 插 法将 p 结 点插入 到 双 链表 中

这 (L 一 next!==NULL)

//若工 中 存在 数据 结 点

工一 next 一> prior一pi;

// 修 改 原 来 首 结 点 的 前 驱 指 针

工一next一pi;

p一> prior一L;
p 一 qi

// 将 新 结 点 作为 首 结 点

//让p 重 新 指向 其后继 结点

检 |

人

= 上 -一 和

人 |

AAA采用 头 插法插入

八

图 2.25 采用头插法将 户 所 指 结 点插人 到 工 中

【例2. 10〗 有 一 个 带头结 点 的 双 链 表 工 (至 少 有 一 个 数据 结 点),设计

一 个 算法 使 其 元

素 递增有序排列。

本 算法 与例2. 8算法的思路相同,只 是插入 结 点 的 操作 略 有 不 同。算法如下 :

void sort(DLinkNode x* &L)

// 双 链表 结 点递增排序

{

。 DLinkNode * p,*pre,

qi

p 一 工

一 > next -> next;

V//p 指向 工 的第 2 个数据结点

(ss

|
EX2AsSJ线性表

工人一next一 next=NULL;

// 构 造只含一个 数据 结 点 的有序 表

while (p!=NULL)

{ ,q王p 一>next;

pre 一 L;

//q 保存p 结 点 的后继 结 点

// 从 有 序 表 开 头 进行 比较, pre 指向插入 结 点 p 的 前 驱 结 点

while (pre -> next!王NULL 区 & pre 一 next 一 data<p 一> data)

Pre一pre 一> next;

//在有 序 表 中 找插和人结 点 的 前 驱 结 点 Pre

p 一> next一pre 一> next;

//在 pre 结 点 之 后插入 结点 p

这 (pre 一> next!王NULL)

pre 一> next 一> prior一p;

pre 一> next一pi;

p 一> prior一pre;
D 一 qi;

// 扫 描 原 双 链 表 余 下 的 结 点

234 循环链表

循环链表(circular linked list) 是 另 一 种形式 的链 式 存储结构。循 环链表 有 循环单链表

和 循环双 链 表 两 种类 型 ,循环 单链表 的结 点类 型和非循环 单链表 的结 点类 型 LinkNode 相

同 ,循环双链 表 的结 点 类 型和 非 循环双链 表 的 结 点 类型DLinkNode 相同 。

把 单链表 改 为 循环 单 链 表 的 过 程 是将它 的 尾 结点 next 指针 域由原来 为 空改为 指向 头

结点 ,整个 单链表 形 成 一 个 环。由 此 ,从 表 中任 一 结 点 出 发均 可找到 链表 中 的 其 他结 点 。

图 2. 26(a) 所 示 为 带头结 点 的循环单链表 。

线性表7

nm)

用 mg时

头结 点

。 开始结 点
一| 0

工 一|

CD 一

尾结 点

(Ga) 循环单链表

线性 表

(al Gao an)

由 映射

头结点

首结 点

站 尾结 点

G1

|
戎 |

4

2 ” 一

(b) 循环双链表

图 2.26 循环链表

把 双 链表 改 为 循环双链表 的 过 程 是 将它的尾结点 next 指针 域 由 原来 为空改 为 指向 头

结点 ,将 它 的头结点 prior 指针域改为 指向 尾 结 点 ,整个双链 表 形 成 两 个 环。图 2. 26(b)所

数据 结构教程

[第! 5版

循环 链表 的 基本 运算 实现 算法 与 对 应非 循环链表 的 算法 基本 相同 ,主要 差别 是 对 于 循

环 单 链 表 或 循环双链表 工 ,判断表 尾结 点 娟 的 条 件 是 六 一>next一一工; 另外 在 循环双链表

中 可 以 通过 工一> prior 快速找到 尾结 点 。

【例 2. 11〗 有 一 个 带头结 点 的 循环单链表 工,设计 一 个 算法 统计 其 data 域 值为x 的结

扫描 整个循环 单链表 ,用 ; 累计 data 域 值为 z 的结 点 个 数。算法如下 :

int count(LinkNode * 工,ElemType x)

一 0;

inti
LinkNode * p一工 一 next;

while (p!一L)

{

, 计 (p 一 data一一X)
i 十十;
p 一 p 一 nexti;

}
Teturn ii

{

}

//p 指向首结点,i置为0

// 扫 描 循 环单链表 工

// 找 到 值为 x 的 结 点后i 增 1
//p 指向 下 一 个 结 点

// 返 回 值为 x 的 结 点 个 数

【例 2.12〗 有 一 个 带头结 点 的 循环双 链 表 工 ,设计一个算法删除第

个 data 域 值为zx 的结 点 。

用 了 指针 扫描 整个 循环双链表 来 查找 data 值为zx 的结 点 ,找到后

删除 疡结 点 ,并 返回 true, 若 未找到 这 样 的结 点 返回 false。 算法如下 :

视频讲解

bool delelem(DLinkNode * &L,ElemType x)

{

。 DLinkNode * p一 工 一> next;

while (p!一L 攻 & p 一 datal!一x)

//p 指向首结点
// 查 找 第 一个 data 值为x 的 结点 p

P王p 一> next;

这 (p!王L)

// 找到 了 第 一 个 值为 x 的 结点 p

{

, p 一 next 一 > prior一p一> prior;

/删除 p 结点

p 一> prior 一> next一p 一> next;

free(Cp);
Teturn truei

Teturn false;

}
else

)》

// 返 回 真

// 没有找到值 为x的 结 点 ,返回 false

PE

【例 2.13】 设计 一 个 算法 ,判断带头结 点 的 循环双 链 表 工 ( 含 两 个以上 的结 点 ) 中 的 数

算法 思路 是 用

户 从 左 向 右 扫描二 ,9 从 右 向 左 扫描 二, 然后 循环 。若 如 、d 所 指结 点

的 data 域不相等 , 则 退出 循环,返回 false; 否则继续比较,直到 = 一4( 数 据结 点 个 数 为奇数

的情况)或者 = 一 一 > prior( 数 据结 点 个 数 为偶数 的情况) 为 止,这 时 返回 true。 算法如下 :

bool Symm(CDLinkNode * 工)

{

bool same一true;

//same 表示工 是 否 对 称 ,初始时为true

|
EX2AsSJ线性表

DLinkNode * p一二一 next;

DLinkNode * q一L 一 prior;

while (same)

//p 指向首结点

//aq 指 向尾结 点

{

这 (p 一 data!一q一> data)

// 对 应 结 点 值 不相同 ,退出循环

same一false;

else

{

】》

这 (p= 一一q ‖ p 一一q 一 prior) break;
q 一q一> prior;

//q 前 移 一 个 结点

p 一 p 一 next;

//p 后 移 一 个 结 点

}

Teturn Same;

)}

该 算法 利用 循环双 链 表 工 的 特点 ,通过 工一> prior 直接 找到 尾 结点,然后 进行 结 点 值

的比较,从而判断工 的 数据 结 点 是否对 称

。 如 果 是非 循环双 链 表 , 需 要 通过 遍历查找 尾 结

点 ,显然 不 如 循环双 链 表 的 性能 好 。

线性 表 的 应 用

米

本 节 通 过 计算任意 两个表 的 简单 自然连接 过 程 讨 论 线性表 的 应 用。假 设有两个表 4
和 瑟 , 分别是ma 行列和 zs 行,w 列 , 它们 的 简单 自然连接 结果 C 一 4 区 已,其 中 1 表示

表4 中 的 列 号,) 表示 表 召 中 的列号,C 为4 和 召 的 稍 卡 儿积 中 满足 指定 连接 条件 的所有 记

录组 ,该连接 条件 为表4 的第;列与表召 的第7 列 相等 。例如:

1

2

3

3

4 一 233 8B= 1

1

1

1

3

5

6

4

C=A | 3 的 计算 结果 如 下 :

产mm一一 广oomm

产oowooo 产oowooo 口上必品

由 于 每个表 的行 数不确 定 , 因 此 采用 单 链表 作为 表 的 存储 结构 ,每 行作为 一个数据 结

点 ,也 称 为 行 结 点 。另外 ,每 行中的 元 素个数 也 是 不 确定 的 ,但 由 于 需要 提供 随机 查找 行 中

的 数据 元素,所以 每 行的数据 元 素 采 用 顺序 存储 结构 ,这 里 用 长 度为MaxCol 的 数组 data

存储每行的数据。因 此 该单链表 中 数据 结 点的类 型 声明 如 下 :

数据 结构 教程

[第! 5版

# define MaxCol 10
typedef struct Nodel

{

ElemType data[MaxCol] ;

//最大列数

// 定 义 数据 结 点 类 型
// 存 放 一 行的数据

Struct Nodel #* next;

// 指 向 后 继数据结点

})DList;

// 行 结 点 类 型

另外 ,需要 指定 每个表 的 行数和 列 数 ,为此 将单链表 的 头结点类 型声明 如 下 :

typedef struct Node2

{

int Row,Coli;

DList * next;

} HList;

// 行数和 列 数

// 指 向 第 一 个 数据 结点

// 头 结 点 类 型

这样A、B 两个表 对 应 的 单链表 存储结构 如 图 2. 27 所 示 。

AN

3 |3

中 123

一 233

w和|111|和A

PN\

3 | 2

中 35

| 1 6

辣| 3 4

人

图 2.27 A、B 两 个表对 应 的单链表 存储 结构

注意: 在 前 面 讨论的 链表 中 , 头 结 点的类 型与数据 结 点的类 型 均相同 ,而 这 里两者 的 类

型是不 同 的 。

通过 对 本 求解 问题分析 ,需要 设计以下 4 个 基本 运算 算法 。

。 CreateTable(&

7 : 采用 交互 方式建立 单 链表 太。

。 DestroyTable(&j): 销毁单链表太。

。 DispTable(CP) : 输出单链 表。

。 LinkTable(Ch1,j2,&j): 由 记 和 72 连接 产生 结果 单链表 太。

1) 采用 交互 方式建立 单 链 表 的 算法

采用 尾 插 法建表 的 方法 创建存储 一个表 的 单 链表 ,用 户 先 输入表 的行数和 列 数 ,然后 输

和各行的数据。在 采用 尾 插 法 建 表时 需要 设置 一 个 尾结 点 指针 ~, 一 般 尾 插 法 是 先让 > 指

向 头结 点 ,但 这 里 头 结点和 数据 结 点 的 类 型 不 同,上且 头 结 点 只 要 一 个 ,而 数据 结 点有若干个,

所以只 让 指向 数据结 点

。 对 应 的建表 算法 如 下 :

void CreateTable(HList * &h)

{

intij;

DList * T, 关 Si

h 一(HList * )malloc(sizeof(CHList)) ;

// 创 建 头 结点

printf("
表的行数,列数:");
scanf("%d%d",&h -> Row,&h-> CoD);

for Ki一0;i<h-> Row;i十十)

{

printf(" 第 %d 行:",i十1);

// 输入表 的 行数和 列 数

// 输 入所有 行 的数据

(>

|
EX2AsSZ线性表

s 一(DList * )malloc(sizeof(DList)) ;

// 创 建 数据结点 s

for Gj=0;j<h -> Col;j十十)

// 输入一 行的数据

scanf("%%d",&s 一 data[]);

这 (h 一> next==NULL)

// 揪 入 第 一个数据 结 点 的 情况

h 一 next一si;

else

T 一 > next 一 si

I 一 si

}》

// 插 入 其 他 数据 结 点 的 情况

//将s 结 点插入到r结点之后

//r 始终 指向 尾 结 点

Tr一> next一NULL;

//尾结点的 next 域 置空

)》

显然 该算法 的 时间 复 杂 度为OOm"XzD) ,其中疡 为 表 的行数,” 为 表 的 列 数 。

2) 销毁单链表的算法

该 算法 和 前 面 销毁 单 链表 的 算法 类似 , 只 是 要 针对 头 结点和 数据 结 点 类 型 不相同 的 情

况 进行相应 修改 。对 应 的算法如下 :

void DestroyTableCHList * &&h)

{

, DList * pre一h 一 next,,x p 一 pre 一> next;

while (p!王NULL)

free(pre);

pre一p; p 王 p 一>next;

{

}

free(Cpre) ;

free(h) ;

)}

该 算法 的时 间 复 杂 度为 OC(m) ,其 中

为 表 的行 数 。

3) 输出单链表的算法

对 应 的 输出 表 的 算法如 下 :

void DispTableCHList * h)

{

intj;

DList * p一h 一> next;

while (p!I=NULL)

//p 指向 开始行结点
// 扫 描所有 行

一Col;j十十)
for Gj=0;j<h

// 输 出 一 行的数据

printf("%4d",p 一 > data[门);

printfC"\n");

Dp 一 p 一 nexti;

//p 指向 下 一 个 行 结点

{

}

)》

该 算法 的时 间 复 杂 度为 O(0m"Xz) ,其 中 z 为 表 的行数、” 为 表 的 列 数 。

4) 表 连 接 运 算 算法

为 了实现两个表Al 和 /2 的 简单 自然连接 , 先 要 输入 两个表 连 接 的列

序号 和), 然后

用 刀 指针 扫描 单 链表关 1 ,对 于 Al 的 每个数据 结 点 ,都用 9 指针 从 头 至尾扫描 单链表 /2 的

所 有数据结点 ,若自然连接 条 件 成 立 ,即 的馆所 指 结点和 关 2 的g 所 指结 点 满足连接 条 件

Rs

数据 结构 教程

5版

2 一> data[i 一=一4

一> data[7

一 , 则 在结果 单链表 关中 添加 一 个 新结 点。结 果 单 链 表

户 也 是 采用 尾 捅 法 建 表 方法 创建 的 。实 现 两 个表 Al 和 /2 的 简单 自然连接 并 生成 结果 单 链

表 太 的算法如下 :

void LinkTableCHList * hl,HList * h2,HList * &b)

{

intij,k;

DList * p一hl 一> next, 关 q,, 关 S, 关 Ti;

printf( "连接 字段是:第 1 个 表序号,第 2 个 表 序 号 :");

scanf("吕dd &i&ji);
h 一(HList * )malloc(sizeofCHList));

h 一 Row一0;

// 创 建结果 表 头 结 点

//置行数为0

h 一 Col王hl -> Col二h2 一 Col;

// 置 列 数为表 1

和表2 的列数和

h 一 next=NULL;

while C(p!I=NULL)

{ ,q=h2一 next;

while (qdl=NULL)

//置next 域 为NULL

// 扫 描 表 1

//a 指 向 表 2 的 首 结 点

// 扫 描 表 2

{

, 过 (p 一 data[i一可一一4一data0一可)

// 对 应字段值相等

{

, s=一(DList * )malloc(sizeof(DListb)); 。// 创 建 一个数据 结点 s

for (k王0;k<hl 一 Col;ik十十)

// 复 制 表 1 的 当前 行

s-> data[k] 一p 一 data[k] ;

for (k一0;k<h2 一 Col;ik十十)

// 复 制 表 2 的 当前 行

ss 一> data[hl -> Col 十匡 一 q一> data[k] ;

让 (h 一 next一一NULL)

// 若 插入 的 是 第 一个数据 结 点

Ph 一> next一s;

//将s 结 点 插入 到 头 结 点 之 后

else

T 一> next 一 si;

T 一 Si

h 一> Row 十十;

】}

q 一 q 一> nexti

】}

p一p 一 nexti;

}

T 一 next一NULL;

下 设计永解程序

// 若 插入 其 他 数据 结 点
//将s 结 点 插入 到 结点r 之后

//r 始 终 指向尾结 点

// 表 行 数增 1

//表 2 后 移一个 结 点

//表 1 后 移一个 结 点

// 表 尾 结 点 的 next 域置空

在 设计 好 4 个 基本 运算 算法以 后,设计以下主 函 数调用 这 些 算 法 完成 求解 任务 :

me

int main()

* hl x h2,x hi
{ HList

printf("表 1:\n") ;

CreateTable(hl) ;

printf("表 2:\n");

CreateTableCh2) ;
LinkTableChl,h2,bh);

printf(" 连 接结果表 :\n");
DispTable(h) ;

// 创建表 1

// 创建表 2
// 连 接 两个表

//输出 连接 结果

|
EX2AsSZ线性表

// 销 毁 单链表 hl

// 销 毁 单链表 h2
// 销 毁 单链表 h

DestroyTable(hl) ;

DestroyTable(h2) ;

DestroyTable(h) ;

return 1;

}

于 运行 结 采

运行 本 程序,输入相应 表 数 据 ,得到 对 应 的 简单 自然连接 结果(带 下 画 线的表示 用 户 输

入 的 数据 ,上巡表示 按 回 车键,下同 ) :

表 1:
表 的 行 数,列 数 :3 3 上妇
第 1 行 :123忱

第 2 行 :233必
第 3 行 :L11必

:32

IS民兹
马党

表 2:
表 的 行数,
第 1 行 :
第2行:16

内
SS
第3行:34
连接 字段是:第 1
连接 结果 表 :
12335

个 表 序 号,第 2 个 表 序号:3 1 上巡

12334

23335

233314

11116

所谓有序表 (ordered list)是指这 样的线性 表 , 其中所有元 素以 递增或 递减 方式 有 序排

列。 为 了 简单,假设有序 表 元 素 以递增 方式 排列 。从 中 可 以 看 到 ,有 序 表 和
线性 表 中 元 素 之 间 的 多 辑 关 系相同 , 其 区 别 是 运算 实现不同 。

扫--扫
天

251 有 序 表 的抽象 数据类型描述

有 序 表 的 抽象数据 类 型 描述如 下 :

视频讲解

ADT OrderList

{ 数据 对 象 :

={ ai| 1 和 受 未 x人 0,ai;

为 ElemType 类型}

//ElemType 是 自定义类型标识符

数据 关系 :

尺一{< aiyaiH>| aatEDD 且 ws委oitii一1 ,7 一 1])

基本 运算 :

InitList(&L): 初始化有序表工。

数据 结构教程

[第! 5 【版

DestroyList(&L): 销毁有序表工。
ListEmpty(L): 判断有序表荆 是 否 为 空表 。
ListLength(L): 求有序表工 的 元 素个数 。
DispList(L): 输出有序表工。
GetElem(L,i, &e): 求有序表工 的第;个 元 素 。

LocateElem(L,e): 返回有序表工 中 第 一 个 元 素 值等于 。 的 元 素 的 序号。
ListInsert(&&工,e) :
ListDelete(& Li &e): 删除有序表工 中 的 第 ;个 元 素 。

在 有序表工 中 插入 一 个 元 素 值为e 的 元 素 。

252 有 序 表 的 存储 结构 及 其 基本 运算 算法

由 于 有 序 表 中 元 素 之间 的 逻辑 关系 与 线性 表 的完全 相同 ,因此 可 以采

用顺序表(类型为 SqList) 和 链表 ( 单 链 表结 点 类 型为LinkNode,双链表结 部
视频讲解
点类 型为DLinkNode)进行存储 。

若 以 顺序 表 存储有 序 表 , 大 家 会 发现基 本 运算 算法中只 有 ListInsert()算法与 前面的 顺

序 表 对 应 的 运算 有 所 差异,其余都 是 相同 的 。有 序顺序表的 ListInsert()算法如下 :

void ListInsert(SqList * &L,ElemType e)

一 0,j;

inti
while (i< 工 一 length && LEL 一 data[]<e)

i 十十;

for (三 ListLength(L);j>ij 一一)

工 一 data[让=L 一> data0j一 匡 ;

工 一 data[ 品一e;

L ->length十十;

//查找值为e 的 元 素
//将 data[丫及 后 面 的元素 后 移 一 个位置

// 有 序 顺 序 表 的 长度增 1

{

)》

本 算法 的 思路 是从头 开始 扫描 有 序顺序表工 ,通过 比较找到 插入 位 置间 ,将 dataL让及后

面 的元 素后移 一 个位 置 ,在 该 位 置插入 元 素 e。 显 然 该 算法 的时 间 复 杂 度为OCz)。

若 以 单 链表 存储 有 序 表 , 同 样 会 发现基本 运算 算法 中只有 ListInsert()算法与 前 面的单

链表 对 应 的运算有所差异,其余都是 相同 的 。有 序 单链 表 的 ListInsert()算法如下 :

void ListInsert(LinkNode * &L,ElemType e)

{

LinkNode * pre一 L,* pi;

while (pre -> next!王NULL 了了& pre 一 > next 一 data<e)

pre二pre 一> next;

// 查 找 插 入 结 点 的 前 驱 结点 PrIe

p 一(LinkNode * )malloc(sizeof(LinkNode)) ;

p一> data一ei;

P 一> next一pre 一> nexti

pre 一>next一Di;

// 创 建 存放 e 的数据结点p
//在 pre 结 点 之 后插入 p 结 点

253 有 序 表 的 归并 算法

【例2.14】〗 假设有两个有序表 LA 和 LB, 设计 一 个 算法 ,将 它们 合并 成 一 个 有 序 表

LC( 假 设 每 个 有 序 表 中 和 两 个 有 序 表 间 均不存在 重复 元 素),要求不破坏原有表 LA 和 LB。

|
EX2AsSJ线性表

将 两 个有序 表 合并 成 一个有 序 表 可以 采用 二 路 归并 算法 ,如 图 2. 28 所 示 。 其 过 程

是分别扫描 LA 和 LB 两 个有序 表 , 当 两 个有序 表 都 没有扫描 完时 循环: 比较 LA、LB 的当

前 元 素 , 将 其中较小 的 元 素放和 LC 中 ,再 从 较 小 元 素 所 RE
在的有 序 表 中 取 下 一 个 元 素。重 复 这 一 过程直到 TIA 或 | -PE rc

LB 比较 完毕 ,最 后 将 未比较 完 的有序 表 中 余下 的 元 素 放
入 LC 中 。 例如LA=(1,3,5),LB一(2,4,8,10) ,其 二 图2. 28 二 路 归并 示意 图

归并 过 程 如图 2. 29 所 示 。

了
1
LA:135

LB:24810
4
7

开

LA:135
:13

1-2

(人

4
3<:

Lc:l

+

LC:123

LA:135

LB:24810
4
7

天

LA:1

:135

2-3

ina,

站

(b)

4

<5

LB:2 1 & 10

计 +

LB:2 48 10

HH

己一一 rc1234

7

下

(c)

7

(d)

开

LA:135

5<8

LC:12345

LA:135

1LB24810 呈 1,LA 扫描完 LB24810

人
7

(Ce)

>

LC:12345810

将 LB 余 下的 元 素
复制到LC中

(CD)

图 2.29 二 路归并过程

说 明 : 本题要 求 不破坏原有 表 LA 和 LB,所 以 采用 复制 的 方式生成 LC,即 采用 建 表 方

法 新 建 表 LC。

采用 顺序 表 存 放 有 序 表 时 的 二 路 归并 算法 如 下 :

void UnionList(SqList * LA,SqList * LB,SqList x* &LC)

{

int ii一0,j一0,k=0;

//ij 分 别为LA、LB的下标,k 为 LC 中 元 素 的个数

LC=(SqList * )malloc(sizeof(SqList)); 。 // 建立有 序顺序表 LC

while (i<LA 一 length && j<LB 一 length)

{

(LA-> data[<LB-> data[)

LC 一 data[gj=LA 一 data[口;

证

LC->data[gj 王 LB 一> dataD];

四国 二 二 本

{

)》

else

{

)》

}》

//LA-> data[中 >LB -> data[j]

while (i<LA -> length)

//LA 尚未扫描 完 ,将 其 余元素 插入 LC 中

{人1 , LC->data[g 王 LA 一 data[;

i直二55

}

数据 结构教程

[第1 5 【版

while Gj<LB 一 length)

//LB 尚未扫描 完 ,将 其余元 素插入 LC 中

{人1 , LC->data[ 国王LB-> dataD] ;

j十 十 ;+十;

}

LC -> length一k;

)》

采用 单 链表 存放有 序 表 时 的 二 路 归并 算法如 下 :

void UnionListl(LinkNode * LA,LinkNode * LB,LinkNode * &LC)

{

LinkNode * pa一LA 一> next, x pb一LB一> next, #T, 关 Si

LC=(LinkNode * )malloc(sizeof(LinkNode)) ;

// 创建LC的头结点

I 一 LC;

//r 始终 指向 LC 的 尾 结点

while (pal王NULL && pb!=NULL)

{

, 计 (pa 一> data<pb 一 data)

{

ss 一(LinkNode * )malloc(sizeof(LinkNode));

//复制pa 所 指 结 点

Ss 一> data一pa 一> data;
T 一> next 一 Sir 一 Si;

pa一pa 一> next;

// 将 s 结 点插入 到 LC中

{ s 一(LinkNode * )malloc(sizeof(LinkNode));

//复制pb 所 指 结 点

s 一> data一pb 一> data;
TI 一> next 一 SiT 一 si;

pb一pb 一 > next;

》

}

while (pa!王NULL)

//将s 结 点插和人到 LC中

ss=(LinkNode * )malloc(Csizeof(LinkNode)) ;

//复制pa 所指结点

S 一> data一pa 一> data;
T 一> next一s;T一si;

pa一pa 一> next;

// 将 s 结 点插入 到 LC中

{

}

while (pb!=NULL)

{

s=(LinkNode * )malloc(Csizeof(LinkNode));

// 复制pb 所 指 结 点

ss 一> data一pb 一> data;
T 一> next一s;T一si;
pb一pb 一>next;

}
T 一 > next一NULL

// 将 s 结 点插入 到 LC中

//尾结点的 next 域 置空

上 述 两个算法的设计思路完全 相同。第 1 个 while循环在最坏情况下的执行次数为

O(CListLength(LA)

十ListLength(CLB))。 第 2 个 while循环在最坏情况下的执行次数为

O(CListLength(LA))。 第 3 个 while 循环 在 最 坏情况 下 的 执行次数为O(ListLengthCLB))。

所 以 算法时间 复 杂 度为O(ListLength(LA) 十 ListLength(LB))。 实际上 ,每

个算法都恰好

只 扫描 LA 和 LB 有序 表 一 次 。

说明: 两 个 长 度 分 别为12 的有序表A 和已 采用 二 路归并 算法 ,在 最 好 情况 下 元 素 的

比较次数为MINCmzzz) ,如A=(1,2,3),B=(5,6,7,8,9)

,元素比较次数为3; 在 最坏情况

下 元 素 的比较 次 数为办十一1,如A=(2,4,6),B=(1,3,5,7)

,元素比较次数为 6。

254 有 序 表 的应用

【例 2.15〗 已知 3 个 带头 结点 的 单 链表 LA、LB 和 LC 中 的 结 点 均 依 元 素 值 递增 排列

(假设 每 个 单链表 不存在 数据 值相同 的 结点,但 3 个 单链表 中 可 能 存在 数据 值相同 的结点 ),

设计一个算法对 LA 链表 进行如下 操作 : 使操作后的链表 LA 中 仅 留下 3 个 表 中 均 包含的

数据 元 素 的 结 点,且 没有数据 值相同 的 结点 ,并 释放 LA 中 所 有 的 无用结 点。要 求算法的时

间 复 杂 度为 O(z十 z十加) ,其中加 2 和 刀 分 别为 3 个 表 的 长 度 。

国 先以单链表 LA 的 头 结点作为一个 空表,r 指向 这 个 新 建 单链表 的 尾 结 点 。以 pa

扫描 单 链表 LA 的 数据 结点 ,判断 它是否 在 单链表 LB 和 LC 中,若同时在 LB 和 LC 中,表

示 pa 所 指 结点是 公共 元 素 , 则 将 其 链接 到 -所 指 结 点 之后,否则 删除 之。算 法 如 下 :

void Commnode(CLinkNode * & LA,LinkNode * LB,LinkNode * LC)

LinkNode * pa一LA 一 next, * pb一LB 一> next, x pc一LC 一 > next, 关 q, 关 工;
LA 一 next=NULL;
TI 一 LA;
while (pal=NULL)
{

// 此 时 LA 作为 新 建单链 表 的 头 结 点
/人r 始终 指向 新 单链表 的 尾 结 点
// 查 找 均 包含的公共 结 点 并 建立 新 链表
while (pb!=NULL gg& pa-> data> pb -> data) //pa 结 点与LB 中 的 pb 结 点进行比较

pb一pb 一 > next;

while (pc!==NULL && pa 一> data> pc 一> data) //pa 结 点与LC 中的 pc 结 点进行比较

pc 一 pc 一> next;

让 (pb!=NULL && pc!王NULL && pa 一 data一一pb 一> data

术& pa -> data一一pc一> data)

{ T 一 next一pali

I一pa;
pa 一 pa 一> nexti

】}
else

{ 9q一pai;

pa 一 pa 一> nexti
free(q) ;

】}

}
IT一> next一NULL;

//著 pa 结点是公共结点
//将 pa 结 点插入到LA 中

//pa 移 到 下 一 个 结点

//若 pa 结 点 不是公共 结 点 , 则 删除 之

//pa 移 到 下 一 个 结点

// 释 放非公共 结 点

//尾结点的 next 域置空

{

)}

注意 : 本 算法 实际上也 是利用 尾 插 法 新建链表 的 过 程 。

在 上述算法中 ,指向 LA、LB、LC 单链 表 的指针 pa\pb、pc 都 没有 出 现 回 溯 过 程 ,即每个

单 链 表 均 只 扫描 一 遍 ,所以 算法的时 间 复 杂 度为 OCOmz十 2 十让) 。

【 例 2.16】〗 已 知 一 个有序 单 链表 工(人允许 出 现 值 域重复 的 结点) ,设计 一 个 高 效 算法 删

由 于 是 有序 单链表 ,所以 相同 值 域 的结 点 都 是 相 邻 的

。 用 思扫描递增单链表,若/

所 指结 点 的 值 域 等于其 后 继 点 的 值 域 , 则 删除 后 者。算法如下 :

扫 - 扫

void delsC(LinkNode * &L)
{

LinkNode * p 王 L 一> next, x qi

while (p -> next!王NULL)

数据 结构教程

[第1 5 【版

{

让 (p->data王一bp一> next 一> data)

// 找 到重复值的结点

{

, q=p一nexti

//aq 指 向 这 个重复 值的结点

p 一 next一 q 一>next;

// 删除 Q 结点

free(Cq);

】}

else

bp一D 一 next;

}

// 不 是重复结点,p 指针 下 移

本 算法 的时 间 复 杂 度为 O(z) ,其中冯 为 有 序 单链表工 中数据结点的个数。

【例 2.17】〗 一个长度为zz1)的升序序列 S, 处 在 第 z72 个 位 置的数 称为 S 的 中位

数 。例 如 , 若 序列 Si=(11,13,15,17,19),则 S;,

的 中位 数是15。 两 个 序列的中 位 数 是含它

们 所 有 元 素 的 升序 序列 的 中 位 数。例如,若S:=(2,4,6,8,20),则S 和 S,, 的 中 位 数是11。

现 有 两个等 长 的 升序 序列 A 和 吾 , 设 计 一 个 在时 间 和 空间 两方面都 尽 可 能 高效的 算法 ,找

出两个序列 A 和召 的 中位数。假 设 升序 序列 采用顺序 表 存 储 。

当 升 序 序列 采用顺序 表 存 储时 ,一 个 升序 序列 S 的 中 位 数 就 是 S 一> data[LS一>

length/2]

元素,求解算法十分简单; 而

S, 和 S;* 两 个 等 长 升序 序列的中位 数是将 它们 二 路

归并 后 的 一 个 升序序列 S 的 中位数。实际上 不需要求出 S 的 全 部 元 素,用 & 记录 当前 归并

的 元 素 个 数,当 A=S 一> length 时 进行 归并 的 那个元 素 就 是中位 数。求 两 个 等 长 有 序 顺序

表 A、B 中位 数 的 算法 如 下 :

ElemType M_Search(SqList * A,SqList * B)

//A.B的长度相同

{

int i一0, j一 0,k一0;

while (i<A -> length && j<B->length)

// 两个序列 均 没有扫描 完

{

kk 十 十;

// 当 前 归并 的 元 素个数 增 1

让 (A -> data趾 <B-> data[D])

// 归 并 较 小 的元素 A 一 data[j

{

}

else

这 (k=一A一 length)

// 若 当前 归并 的 元 素 是第 n 个 元 素

return A -> data跨 ;

//返回A -> data[j

i十十;

// 归 并 较 小 的元素 B-> data[站

{ , 计 (k一王B一length)

// 若 当前 归并 的 元 素 是第 n 个 元 素

return 了 一> data[j] ;

//返回B-> data[j]

ee

j十十;

}

)}

上 述 算法 的 时 间 复 杂 度 为 O(0z) 空间 复杂 度为 O(1) ,是 高 效 的 算法,其 中 ?为 等 长 有

序 顺 序 表 A、B 中 的元 素 个 数 。

9

本 章 的 基本 学 习 要点 如 下 :

(1) 理解线性 表 的逻辑结构 特性 。

(2) 掌握线性 表 的 两 种存储 方法 , 即 顺 序表和链表 ,体会 这 两 种 存储结构之间的差异。

(3) 掌握 顺序表上 各 种 基本运算 的实现 过程 和顺序 表 的通用 算法 设计 方法 。

(4) 掌握 单 链表上 各 种 基本 运算 的 实现 过 程和单 链表 的通用 算法 设计 方法 。

(5) 掌握双 链 表 的 特点和 双 链 表 的 通用 算法 设计 方法 。

(6) 掌握 循环链表 的 特点 以 及 循环 链表 和 对 应 非 循环链表 的差别 。

(7) 掌握有 序 表 的特点 和 二 路归并 算法 ,以 及 利用有 序 性设计 高效的 算法 。

(8) 综合 运用线性 表 解 决 一些 复杂 的 实际 问题 。

1. 简述线性 表 的 两 种存储结构的主要特点。

2. 简述单链表设置头结 点 的 主要 作用 。

3. 假设某 个 含有 个 元 素 的 线性表有 以 下 运算 :

有

. 查找 序号为 isi生 加)的 元 素 ;

. 查找第一个 值为 zx 的 元 素 ;

. 插入 新 元 素 作为 第 一 个 元 素 ;

. 插入 新 元 素 作为 最 后一个 元 素 ;

. 插入 第 ;2所i委 四 个 元 素 ;

. 删除第一个 元 素 ;

.删除最后 一个元素;

.删除第

现 设计 该 线性 表 的以下 存储结

O@ 顺序表;

@ 带头 结 点 的 单链表,

@ 带头 结点的 循环单 链表 ;

@@ 不 带头 结点 仅有尾结 点 指针 标识 的 循环单链 表 ;

@ 带头 结 点 的 双 链 表 ;

@ 带头 结点的 循环双 链 表 。

数据 结构教程

[第! 5版

指出 各 种 存储 结构中 对 应 运算 算法 的时 间 复 杂 度 。

4. 对 于顺序表工 ,指出 以 下算法的功能。

void fun(SqList * &L)

{1 intij王0;

for (i=1;i<L 一 length;i十十)

填 (L -> data[>L-> data[j)

一1;

for (i一j;i<L 一 length一1;i 十十)

工 一> data[丫二 L -> data[i十]] ;

一length一一;

}》

5. 对 于顺序表工 ,指出 以下算法的功能。

void fun(SqList * &L,ElemType x)

{1 intij王0;

for (ji一 1;i<L 一 length;i十十)

让 (L -> data[i]<=王L 一 > dataD] )

j 一 i

for (ji王L 一 length;i>jj;i一一)

工 一 data[癌二 L 一 > data[i一]] ;

二> data[] 一 xi;

工一 length十十;

}

6.

有 人 设计以 下 算法 用 于 删除整数 顺序 表 工 中 所 有 值 在[z,y] 范 围内的 元 素 ,该算法

显然不是 高 效的,请 设计 一个同样 功能 的 高效算法 。

void fun(SqList * 必 L,ElemType x)

{人 inti ji

for (ij一0;i<L 一 >1length;i十十)

让 (L 一 data[> 一 x&蚊工一data[<一y)

{

for (0j=ij<L

一 length一1;j十十)

工一data[j]=L 一 > data0j十 ]];

工 一 length一一;

)》

7. 设计 一 个 算法 ,将 元素z 搬入 到 一 个有序(从 小 到 大 排序?顺序 表 的 适当 位 置,并

保

持有序性。

8. 假设一个顺序表工 中 的所有 元 素 为 整数,设计 一 个 算法 调整 该 顺序 表 , 使 其中所 有

小 于 零 的 元 素 放 在所有 大 于 等 于零的 元 素 的 前 面 。

9., 对 于 不 带头 结 点 的单链表 工 1, 其 结 点 类 型为LinkNode,指 出以 下算法的功能。

void funl(LinkNode * &L1,LinkNode * &L2)

{

int n一0,ii

(72

|
EXA2AsSJ线性表

LinkNode * p 王 L1;

while (p!王NULL)

mn十十 ;

p一p 一> neXt;

{

}

p一L1;

for (i一1;i<n/2;i十十)

p一p 一> neXt;

工2一p 一 next;

p 一> next一NULL;

}

10. 在结点类 型为DLinkNode 的 双 链 表 中 给 出 将 户 所 指结 点 (非 尾结 点 ) 与 其后继 结

11. 有 一 个线性表(al ,az ,...,a) ,其 中 汪 2, 采 用 带头结 点 的 单 链 表 存 储 , 头 指针 为

工 , 每 个结 点 存放 线性 表 中 的 一 个 元 素 ,结 点 类 型 为(data, next) , 现 查找 某 个 元 素 值 等 于 工

的结 点指针 , 若 不 存在 这 样 的 结 点 返回NULL。 分 别 写 出 下 面 3 种情况 的 查找 语句 ,要 求

时 间 尽 量 少 。

(1) 线性 表 中 的 元 素 无 序 。

(2) 线性 表 中 的 元 素 按 递增 有 序 。

(3) 线性 表 中 的 元 素 按 递 诚 有序 。

全3)的单链表的所
12. 设计 一 个 算法 ,将 一 个带头结 点 的 数据 域依次为wa ,ax、...、\avCz

据 域 变为ai 。

13. 一 个线性表(a ,az ,...,,a,)(Gz>3)

采用带头结点的单链表工 存储 ,设计一个高效算

法求中间 位 置 的元 素 ( 即 序号为Lz/2|的 元 素 ) 。

14. 设计 一 个 算法 在 带头结 点 的 非空单链表 工 中 第 一 个 最 大 值结 点 (最 大 值结 点 可能

有 多 个 ) 之 前插入 一 个 值为zx 的结点 。

15. 设 有 一 个 带头结 点 的 单链表 工 ,结 点 的 结构 为(data,next) ,其中 data 为整数元素,

next 为后继 结 点 的指针 。 设计 一 个 算法 ,首先 按 递减 次 序 输出 该 单链表 中 各 结 点 的 数据 元

素 , 然后释放 所 有 结 点占用的存储空间 ,并 要 求 算法 的 空间 复杂 度 为 O(1) 。

16. 设 有 一 个 双链 表 太 , 每 个结点 中 除了 有 prior data 和 next 几 个 域 以 外 ,还 有 一 个 访

问 频 度域 freq, 在 链表 被启用 之 前,其 值均 初始化 为 零 。 每当进行LocateNode(Ch,z)运算
时 , 令 元 素 值为zx 的 结点 中 freq 域 的 值加 1, 并 调整表 中 结 点 的 次 序 , 使其按 访问 频 度 的 递

aa

减 次序 排列 ,以 便 使 频繁访问 的结点总 是 靠近 表 头

。试写一 个 符合 上 述 要求的LocateNode

17. 设 ha一(aa ao)和 hb=(,2

,oo) 是 两 个带头结 点 的循环 单 链表 ,设计

18. 设 两 个非 空线性 表 分 别 用 带头 结 点 的 循环双 链 表 ha 和 hb 表示 ,设计一个算法

Insert(ha,hb,z)

,其功能是当 ;i=0 时将hb 插 和人到 ha 的 前 面; 当 ;盖0 时将hb 搬入到 ha 中

数据 结构教程

[第! 5 【版

第 站 个 结 点 的 后 面; 当 ; 大于等于 ha 的 长 度时 将 hb 插入到 ha 的 后 面 。

19. 用 带头 结 点 的 单 链表 表示 整数 集合,完成 以下算法 并 分 析 时间 复 杂 度

要求不破坏原有的单
(1) 设计 一 个 算法 求 两 个 集合 A 和 吾 的 并集运算,即C=AUB,

链表A 和 了 。

(2) 假设集合中的元素按 递增 排列 ,设计 一 个 高效算法 求 两 个 集合 A 和导 的 并 集运

算,即C=AUB,

要求不破坏原有的单链表A 和 忆 。

20. 用 带头 结 点 的 单链表 表 示 整 数集合 ,完成以下 算法 并 分 析时间 复 杂 度 ,

(1) 设计 一 个 算法 求 两 个 集合A 和 忆 的 差 集运算,即 C一A 一 了 ,要求算法的空间 复杂

度为O(1) ,并 释放 单链表 A 和 也 中 不需要的结点。

(2) 假设集合 中 的 元 素 按 递增 排列 ,设计 一 个 高效算法 求 两 个 集合 A 和 了3 的 差集运

算 ,即 C=A 一 B, 要 求 算法 的空间 复杂 度为O(1) ,并 释放 单链表 A 和 了 中 不需要的结点。

一> 上 机 实验题 2 一

实验题1: 实现 顺序 表 的 各种 基本 运算 的 算法

目的: 领会顺序 表 存 储 结构和 掌握 顺序 表 中 的 各 种 基本 运算 算法 设计 。

内 容 : 编写一个程序sqlist cpp, 实现 顺序 表 的 各 种 基本 运算和 整体 建 表 算 法 (假设 顺序 表

的元素类型FlemType 为 char) ,并 在 此 基础 上 设计 一 个 程序exp2-1. cpp完成以下功能。

(1) 初始化顺序表工。

(2) 依次 插入abc.de 元素。

(3) 输出 顺序 表 工。

(4) 输出 顺序 表 工 的长度 。

(5) 判断 顺序 表 工 是否为空 。

(6) 输出 顺序 表 工 的第 3 个 元 素 。

(7) 输出 元素 a 的 位 置 。

(8) 在第 4 个 元 素位 置上插入 了 元素。

(9) 输出 顺序 表 工。

(10) 删除 顺序 表 工 的第 3 个 元 素 。

(11) 输出 顺序 表 工。

(12) 释放 顺序 表 工。

实验题 2: 实现 单 链 表 的 各种 基本 运算 的 算法

目的: 领会单链表 存储 结构和 掌握 单链表 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序 linklist. cpp, 实 现单链表 的 各 种 基本 运算和 整体建表 算 法 (假设 单

链表的元素类型ElemType 为 char) ,并 在 此 基础 上 设计 一 个 程序exp2-2. cpp完成以下功能。

(1) 初始化单链表/。

(2) 依次 采用 尾 插 法 插入abc\d\e 元素。

(3) 输出单链表 彤。

GE

|
EX2AsS线性表

(4) 输出单链表大的 长 度 。

(5) 判断 单链表 刀 是 否 为空。

(6) 输出单链表姑的第 3 个 元 素 。

(7) 输出 元素 a 的 位 置 。

(8) 在第4 个 元 素位 置上插入 了 元素。

(9) 输出单链表彤。

(10) 删除单链表 岂 的第 3 个 元 素 。

(11) 输出单链表 彤。

(12) 释放单链表几。

实验题3: 实现 双 链 表 的 各种 基本 运算 的 算法

目的: 领会双 链表 存储 结构和 掌握双 链表 中 的 各 种 基本 运算 算法 设计 。

内 容 : 编写一个程序dlinklist. cpp ,实现 双 链 表 的 各 种 基本 运算和 整体建表 算法 (假设

双 链 表 的 元 素 类型ElemType 为 char) ,并 在 此 基础上 设计 一 个 程序exp2-3. cpp 完成 以下

功能。

(1) 初始化双链表 /。

(2) 依次 采用 尾 插 法 插入 a\b.c\d\e 元素。

(3) 输出双和链表。

(4) 输出双链表太的 长 度 。

(5) 判断双 链 表 彤 是否 为空。

(6) 输出双链表六的第 3 个 元 素 。

(7) 输出 元素 a 的 位 置 。

(8) 在第4 个 元 素位 置上插入 了 元素。

(9) 输出双和链表。

(10) 删除双链表刀 的第 3 个 元 素 。

(11) 输出双链表彤。

(12) 释放双链表彤。

实验题4: 实现 循环单链表 的 各 种 基本 运算 的 算法

目的: 领会 循环单链表 存储 结构和 掌握 循环 单链表 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序 clinklist, cpp, 实 现 循环单链表 的 各 种 基本 运算 和 整体建表 算 法

(假设 循环 单链表 的 元 素 类 型 ElemType 为 char) ,并 在 此 基础上设计 一 个 程序exp2-4. cpp

完成以下功能。

(1) 初始化循环单链表 7。

(2) 依次 采用 尾 插 法 插入 a\b\c\de 元素。

(3) 输出 循环单链表 。

(4) 输出循环 单链表 六 的 长度。

(5) 判断循环 单链表 大 是 否 为空。

(6) 输出循环 单链表 六 的第 3 个 元 素 。

(7) 输出 元素 a 的 位 置 。

aa

数据 结构教程

[第! 5版

(8) 在第4 个 元 素位 置上插入 了 元素。

(9) 输出 循环单链表 。

(10) 删除 循环 单链表 刀 的第 3 个 元 素 。

(11) 输出循环 单链表 。

(12) 释放 循环 单链表 )。

实验题5: 实现 循环双 链 表 的 各 种 基本 运算 的 算法

目的: 领会 循环双 链 表 存 储 结构和 掌握 循环双 链 表 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序cdlinklist. cpp, 实 现 循环双 链 表 的 各 种 基本 运算和 整体建表 算法

(假设 循环双 链 表 的 元 素 类 型 ElemType 为 char) ,并 在 此 基础上设计 一 个 程序exp2-5. cpp

完成以下功能。

(1) 初始化循环双链表彤。

(2) 依次 采用 尾 插 法 插入 a\b.c\d\e 元素。

(3) 输出 循环双 链 表 彤。

(4) 输出 循环双 链 表 关 的 长度。

(5) 判断 循环双 链 表 凡 是否为空。

(6) 输出 循环双 链 表 关 的第 3 个 元 素 。

(7) 输出 元素 a 的 位 置 。

(8) 在第 4 个 元 素 位 置上插入 了 元 素 。

(9) 输出 循环双 链 表 。

(10) 删除循环双链表刀的第 3 个 元 素 。

(11) 输出 循环双 链 表 /。

(12) 释放 循环双 链 表 几。

谷设计

实验题6: 将 单 链表 按 基准 划分

目

的: 掌握单链表 的 应用和 算法 设计 。

内

容: 编写一个程序exp2-6. cpp,以给定值z 为 基准 将 单链表 分 割 为两部 分,所 有小 于

工 的 结

点 排 在大于 或 等于z 的 结 点 之 前 。

实验题7: 将 两 个 单链表 合 并 为 一 个单链表

目

的: 掌握单链表 的 应用和 算法 设计 。

内 容: 编写一个程序 exp2-7. cpp 实现 这 样 的功能 ,一 (Czyz, yz),L 一 (yw,

Eee

JJy2,

...ym) ,它们 是 两 个线性 表 , 采 用 带头结 点 的单链表 存储,设计一个算法合并 Li 、L: , 结

果 放 在线性表 L 中。要 求如 下 :

了3 一 (Ziyyiyzyy

TonyymyTntyZn) 7 < 7

了 3 一 (Ziyyiyzyy

ThyynyynHeyym)

7 二 7

ZLs 仍 采用 单链表 存储 ,算法 的 空间 复杂 度为OC1)。

实验题8: 求集合 (用 单链表 表示 ) 的 并 、 交 和 差 运算

目 的 : 掌握单链表 的 应用和 有 序 单 链表 的 二 路 归并 算法 设计 。

ED

|
EX2AsSJ线性表

内 容: 编写一个程序exp2-8. cpp, 采 用 单 链 表 表 示 集 合 (假设同一 个集合 中 不 存在 重复

的 元 素 ) ,将 其 按 递增方式 排序,构成有序单链表 ,并 求 这 样 的 两个集合 的 并 、 交 和 差 。

实验题9: 求 两个多 项 式的相 加 运算

目的: 掌握线性 表 的 应用和 有 序单链表 的 二 路 归并 算法 设计 。

内 容: 编写一个程序exp2-9. cpp, 用 单 链表 存储 一元多 项 式 , 并 实现 两个多 项 式 的 相 加

实验题10: 求 两个多 项 式 的相乘 运算

目的: 深入 掌握单链表 应 用 的 算法 设计 。

内 容: 编写一个程序exp2-10. cpp, 用 单 链 表 存 储 一 元 多 项 式 ,并 实现 两个多 项 式的相

乘 运算 。

实验题11: 职工信息 的 综合 运算

目的: 深入 掌握单链表 应 用 的 算法 设计 。

内 容: 设有一 个职工文件emp. dat, 每 个职工记录 包含职工 编号(no)、 姓名Cname)、 部

门 号(depno) 和 工资 数(salary) 信 息。设 计 一 个 程序exp2-11. cpp 完成以下功能:

(1) 从 emp. dat 文件 中 读 出职工 记录 ,并 建立 一 个 带头 结 点 的 单链表 工。

(2) 输入 一 个职工 记录 。

(3) 显示 所 有职工记录。

(4) 按 编号no 对所有 职工记录 进行 递增 排序 。

(5) 按 部门号depno 对 所 有 职工记录 进行 递增 排序 。

(6) 按 工资 数 salary 对 所 有 职工记录进行递增 排序 。

(7) 删除指定职工 号 的 职工记录 。

(8) 删除职工 文件中的 全 部记录 。

(9) 将 单 链表 工 中 的所有 职工记录 存储 到 职工 文件emp. dat 中 。

实验题12:

用 单 链 表 实现 两 个大整数 的相 加 运算

目的: 深入 掌握单链表 应 用 的 算法 设计 。

内容: 编写一个程序 exp2-12. cpp, 完 成以下 功能 。

(1) 将 用 户 输入的 十 进 制整数 字符 串 转化 为带头 结 点 的 单链表 , 每 个 结 点 存放 一 个 整

数位。

(2) 求 两 个 整数单链表 相 加 的 结果 单链表 。

(3) 求结果 单链表 的 中间 位 ,如 123 的 中 间位为2.1234 的 中间位为2。

从 组 成 元 素 的 逻辑 关系 看 , 栈 和 队列都属于 线性 结构。 栈和队

列 与线性 表 的 不 同之处在于 它们 的 相关 运算具有 一 些 特殊 性。更

准确 地说 , 一 般 线 性 表 上 的插入 、 删 除 运算 不 受限制 , 而 栈 和队列上

的 插入、 删 除 运算 均 受 某 种特殊限制, 因此栈和 队列 也 称 为 操作 受

限 的线性表。

本 章 介绍 栈 和 队列 的 基本 概念.存储 结构 、 基本 运算 算法 设计

和 应 用 实例。

PASS 和栈和队列 |

栈 是 一 种 常用 而 且 重 要 的 数据结构 之 一,如 用 于 保存 函数 调用 时 所 需要 的 信息 ,通常在

将递归 算法 转换 成非递归 算法 时 需要 使用到 栈。本 节 主 要讨论栈及 其 应 用 。

311 栈 的 定义

栈 (stack) 是 一 种 只 能在 一 端 进行插入或 删除操作 的线性 表。表 中人允许 进行 插入 、 删 除

操作 的 一 端 称 为栈顶 ( 画 园 , 表 的 另 一 端 称 为 栈 底人Eteoag ,如图 3.

1 所示。栈 顶 的 当前 位 置 是 动态的 , 栈 顶 的 当前 位置由 一 个被称 为 Mi Ah

栈 顶 指针 的 位 置指示 器 来 指示。当 栈 中 没有数据 元素时 称 为 空栈。
栈 的 插入 操作 通常 称 为进栈 或入栈人Bush) , 栈 的 删除操作 通常 称 为
出 栈 或 退 栈人66D) 。

栈 的 主要 特点 是 “后 进 先 出 (Last In First Out,LIFO) , 即后进

|栈顶

ww

02

4 _

|栈底

栈 的 元 素 先 出 栈。每 次进栈 的 数据 元 素都放 在 原来栈顶 元 素 之 前
成 为新的 栈 顶 元 素 ,每 次出栈 的 数据 元 素 都是当前 栈 顶 元 素。栈也 图 3.1 栈 示意 图
称 为 后进先 出 表 。

例如 ,若干 个 人 走 进 一 个 死胡同 ,假设 该死胡同 的 宽度 恰好 只 够 一 个人

进出 ,那么走出死胡同 的 顺序和 走 进 的 顺序正好 相反。这 个死胡同就是一

个栈

栈 抽 象 数据类 型 的 定义如下 :

ADT Stack
{ 数据对象:

也 ={ ai| 1 过 ii和 2 xz二 0,a;

为 ElemType 类型}

//ElemType 是 自 定 义 类 型标识符

数据 关系 :

及一人 aiaiti> | aisaE 大一 1 一1}

基本 运算 :

InitStack(&&s): 初始化栈,构造一个空栈>。
DestroyStack(&&gs):销毁栈,释放栈 * 占用的存储空间 。

StackEmpty(s) : 判断栈是 否 为 空,若 栈 * 为 空,则 返回真; 否则 返回假。

Push(C&s,e): 进 栈 ,将元素e 插 和人到栈 中作为栈项元素。
Pop(&Es,&e):出栈,从栈 * 中 删除栈 顶 元 素 ,并 将 其 值 赋给e。
GetTop(s,&e): 取 栈 顶 元 素 ,返回 当前 的 栈 顶 元 素 , 并 将 其 值赋给 e。

)》

【例 3. 1〗 若 元 素 的 进栈序列为 1234 ,能 否 得 到 3142 的 出 栈 序列?

为了让 3 作为 第 一 个出栈 元 素,1、2先进栈,此时要么 2 出 栈 ,要么 4 进 栈后出 栈 ,

出 栈 的 第 2 个 元 素 不 可 能 是 1, 所以得 不 到 3142 的 出 栈 序列。

【例 3. 2〗 用 S 表示进栈操作 `X 表示 出 栈 操作 , 若 元 素 的 进栈顺 序为1234,为了得到

1342 的 出 栈 序列 ,给 出相应 的S和 X 操作串。

为了得到 1342 的 出 栈 序列 ,其 操作 过 程是 1 进栈,1 出栈,2 进栈,3 进栈,3 出栈,

数据 结构教程

[第! 5版

4 进栈,4 出栈,2 出栈。因 此 相应 的S和 X操作串为SXSSXSXX。

说明: , 个 不 同 的元素通过 一 个 栈 产生 的 出栈序列的个数为 - C5。 例如7一4时 ,出

7十1

栈序列的个数等于 14。

进栈 序列

出栈 序列

,2通过一个
【例3.3】〗 一 个 栈 的 进 栈 序列为1,2,...

由

5 4

3
个 人

栈 得 到 出 栈 序列

户 ,po

(CD po 是 1 2

填 。的 一 种 排列) 。 若 户 一 3,则 广 可 能 取 值 的个数 是多少 ?

局 疡

2

1

一 个栈

图 3.2 栈操作 的 一 个时 刻

为了让 3 作为 第 一 个 出 栈 元 素 ,将 1.2、3 依次进

栈,3 出 栈,此 时 如 图 3.

2 所 示 。 之 后 可以 让 2 出栈, 己一2,

也 可 以 让 4 进 栈 再 出 栈,加 一 4, 也 可以 让 4、5 进 栈 再 出

栈 , 加 一5, 所以 加 可以是2,4,5,...,2,不可能是 1 和

3,即 记 可 能 取 值 的 个 数 是”一 2。

312 栈 的 顺序 存储 结构 及 其 基本 运算 的 实现

栈 中数据元 素的逻辑 关系 呈 线 性 关系,所以栈 可以 像线性 表 一 样

采用

顺序 存储 结构 进行 存储, 即分配 一 块连续 的 存储空间 来存放 栈 中 元 素 ,并 用

一 个变量(如 top) 指 向 当前 的 栈 顶 元 素以 反映 栈 中 元 素 的 变化 。采 用顺序

存储结构 的 栈 称 为 | 硕 序 并 CESOUEDESLEEek)。

假设 栈 的 元 素个数 最 大 不 超过 正 整数MaxSize,所有的 元 素 都具有 同一 数据 类 型 , 即

ElemType,

可用下列方式来声明顺序栈的类型SqStack:

typedef struct

{

ElemType data[MaxSize] ;

// 存 放 栈 中 的数据元素

int top;

} SqStack;

// 栈 顶 指针 , 即存放 栈 顶 元 素在 data 数组中的下标

// 顺 序 栈 类 型

栈 到 顺序 栈 的 映射过 程如 图 3. 3

所 示 。 本 节 采 用 栈 指 针(不同于栈项指针 top) 的 方

式 创建和使 用 顺序 栈 ,如 图 3.4 所示。

栈

(al 0) 一> 四 |四 | | om

直接 映射

顺序栈
0

1 人 天 1 MaxSize-1

一” 一一

六1

top

data

图 3.3 栈 到顺序栈的映射

图 3.5 是 一 个 顺序 栈 操作 示意 图。图 3. 5(a)是初始情
况 , 它 是一个 空 栈; 图 3. 5(b)表 示 元素 a 进 栈 以 后 的状态 ;
图 3. 5(c)表 示 元素 bc.d 进栈以后的 状态; 图 3. 5(d)表 示 元

5 |

顺序本

图 3.4 顺序栈指针

素 d 出 楼 以后的 状态。

综 上 所 述 , 对 于* 所 指 的 顺序 栈 ( 即顺序栈 ,) ,初始时设置 *一> top= 一 1,可 以 归纳 出

对 后 面 算法设计 来 说非常重要的 4

个 要 素 。

PASS和栈和队列 |

全

3

2

1

0

人 一 1

4

3

2

1

一 aa | 0
top

一

一一|
top

da

C

b

a

4

3

|2

1

|0

一 1

Te
top

|

4

3

2

1

0

一 |

(a) 空栈

人b) 元 素 a进栈 。。 (G) 元素 b、c、d 进栈

(d) 元 素 d 出栈

图 3.5 栈操作 示意 图

。 栈 空的 条件: *一> top王一一1。

栈 满的条件: * 一> top=王MaxSize 一1(data 数组 的 最大下标 ) 。

元素e 的进栈 操 作 : 先 将栈 顶 指针 top 增 1 ,然后 将元素e 放在 栈 顶指针处。

出栈操作: 先 将栈顶 指针 top 处的 元 素 取 出放在 e 中 ,然后将栈项指针减 1。

在 顺序栈上 对 应 栈 的 基本 运算 算法设计 如 下 。

1) 初始化 栈 initStack(&s)

该运算创建一个空栈, 由 s 指向 它。实际上 就是分 配 一 个 顺序 栈 空间 ,并 将 栈 顶指针设

置 为 一 1。算法如下 :

void InitStack(SqStack * 中 s)
{

s 一 (SqStack * )malloc(sizeof(SqStack));
ss一 >top 一 一 1;

)}

// 分 配 一 个 顺序 栈空间 , 首地址存放 在 s 中
// 栈 顶 指针 置 为一1

2) 销毁栈 DestroyStack(&s)

该运算释放顺序栈 * 占用的存储空间。算 法如 下 :

void DestroyStack(SqStack * &s)
{

free(Cs) ;

)}

3) 判断栈是否 为空StackEmpty(s)

该 运算 实际 上 用 于 判断条 件 * 一> top= 三 一 1 是 否 成 立 。算法如下:

bool StackEmpty(SqStack * s)

{

)}

Teturn(s 一 > top 王 一 一 1);

4) 进栈PushC&s,e)

该运算 的 执行 过 程是,在 栈 不 满的条件下先 将 栈 顶 指针 增 1 ,然后在 该 位 置上插入 元 素

e, 并返回真; 否则 返回 假 。算法如下 :

bool Push(SqStack * &s,ElemType e)

{

让 (s 一 top=王MaxSize一1)

// 栈 满 的情况 ,即栈上溢出

Teturn false;

数据 结构教程

[第1 5 【版

Stop 十十;
s-> data[s 一 top]一e;

// 栈 顶指针增 1
// 元 素 e 放 在 栈 顶指针处

Teturn true;

)》

5) 出栈 PopC&s ,&e)

该 运算 的 执行 过 程是,在 栈 不 为 空 的 条件下先 将 栈 顶 元 素 赋给 e, 然 后将栈 顶指针 减 1,

并 返回 真; 否则 返回 假 。算法如下 ,

bool Pop(SqStack * &s,ElemType &e)
{

让 (s 一 top=一一一1)

// 栈 为 空 的情况 ,即栈下 溢出

Teturn false;
e 一 s 一 data[s 一 top];
Ss一 > top 一一;

Teturn true;

)》

6) 取 栈 项 元素 GetTop(s ,&e)

// 取 栈 顶 元 素
// 栈 顶指针减 1

该运算 在 栈 不 为 空的条件 下 将 栈 顶 元 素 赋 给 e 并返回真; 否则 返回 假 。算法如下 :

bool GetTop(SqStack * s,ElemType &e)
{

让 (Cs 一 top 一 一 一1)
Teturn false;
e 一 s 一 data[s 一> top] ;

Teturn true;

)》

// 栈 为 空的情况 ,即栈下 溢出

// 取 栈 顶 元 素

和 出 栈 运算 相 比 ,本 算法 只 是 没有 移动栈顶指针。 上述 6 个 基本 运算 算法 的时 间 复 杂

度 均为 OC1) ,说 明 这 是 一 种非常高效 的 设计 。

【例 3. 4】 设计 一 个 算法 利用 顺序 栈 判断 一个字符 串 是 否 为对 称 串。所谓 对 称 串指 从

左 向 右 读和 从 右 向 左读 的序列相同 。

扫一扫

对 个 元 素 连续 进 栈 ,产生 的 连续 出 栈 序列和 输入序列 正好 相反 ,本

算法 就 是利用 这 个特点 设计 的 。对 于字符串 str, 从 头 到 尾 将 其所有 元 素 连

续 进 栈 , 如 果 所 有 元 素 连续 出 栈 产生 的 序列 和 str 从 头 到 尾 的 字符 依次 相

此

同 ,表示 str 是 一个对 称 串 ,返回真; 否则 表示 str 不是对 称 串 ,返回假。算

视频讲解

法如下 :

bool symmetry(ElemType str口)

// 判 断 str 是 否 为对称 串

{

intis ElemType e;

SqStack * sti
JInitStack(st) ;
for (i一0;str国! 一\05i十十)

了Push(st,str品);

for (ji一0;str[品 ! 王 人 0';i 十十)
{

PopCst,e);
if (Cstr品!一e)

// 定 义 顺 序 栈 指针
//初始化栈
//将 str 的所有 元 素 进 栈

// 处 理 str 的所有 字符
//退栈元素e
//若e 与 当前 串 字 符 不同表示 不是对 称 串

{

DestroyStack(st);

// 销 毁 栈

人

PASS和栈和队列 |

Teturn false;

// 返 回 假

】》

)}
DestroyStack(st); //销毁栈
return true; // 返 回 真

}

顺序 栈 采 用 一 个 数组 存放 栈 中 的 元 素

。 如 果 需 要 用 到 两 个相同 类 型 的栈,这 时 若 为 它

们 各 自 开辟 一 个 数组 空间 , 极有可 能 出 现 这 样 的 情况 : 第 一 个 栈 已 满 ,再进 栈 就 溢出了 ,而

另 一 个 栈还有很 多 空闲 存储 空间。解决这个问题 的 方法是将 两 个栈合 起 来 ,如图 3.6 所 示 ,

用 一 个 数组 来实现 这 两 个栈, 这 称 为共享 栈(share stack) 。

0

1

1-1
六

数组data: | 吉 | 豆 |

|

四
, 1

MaxSize 1

国

因 可

本 1的 栈底

栈 1的栈项
指针 topl

栈 2的 栈顶
指针 top2

本 2 的 栈度

栈 1

栈2

图 3.6 共享栈

在 设计 共享栈时 ,由 于 一 个 数组 (大小为 MaxSize) 有 两 个 端点 ,两 个栈有 两个栈 底 ,让

一 个 栈 的 栈 底 为数组 的 始 端 ,即下标为 0 处,另 一 个 栈 的 栈 底为数组 的 末端 ,即 下 标为

MaxSize 一1, 这 样 在 两 个栈中 进 栈 元 素时 栈 顶向中间伸 展 。

共享 栈的4 个 要 素如下 。

。 栈空条件: 栈 1 空为topl=王一一1; 栈 2 空为top2一一MaxSize。
。 栈满条件: top1王一top2一1。
。 元素z 进 栈 操作 : 进栈 1 操作为 tpp1 十十;dataLtop1]=z; 进栈2 操作为top2一一;

data[ top2] 一 工 。

。 出 栈 过 操作: 出栈 1 操作为z=dataLtopl];topl一一; 出栈 2 操作为 zx 一 dataLtop2];

top2十十。

在上述设置中,data 数组 表示 共享栈的 存储 空间 ,topl 和 top2 分 别 为 两个栈 的 栈 顶 指

针 , 这 样该共享栈通 过 data\topl 和 top2 来标识 ,也 可以 将 它们 设计 为 一 个 结构体 类 型 :

typedef struct

{

ElemType data[MaxSize] ;
int topl,top2;

}DStack;

// 存 放共享栈中的 元 素
// 两个栈 的栈顶 指 针

// 共 享 栈的类 型

Ps

在实现 共享 栈的基本 运算 算法时 需要 增加 一 个 形参 二 指出是对 哪个校 上

进行操作,如;一1 表示 对 栈 1 进行操作,?一2 表示 对 栈 2 进行操作 。

313 栈 的 链 式 存储 结构 及 其 基本 运算 的 实现

栈 中 数据 元 素 的 逻辑 关系 呈 线性关系 ,所以酚可以 像 线性表 一样采用

数据 结构教程

[第! 5版

链 式 存储 结构。采 用链 式存储结构 的栈称 为 链 栈 人

inKEediStask员链表 有 多 种,这 里 采用 带

头 结 点 的 单 链 表 来 实现 链 栈 。

链 栈 的 优点 是不存在 栈满上 洪 出的情况 。规 定 栈 的所有 操作 都 是 在单链表 的 表 头 进行

的 (因为 给 定 链 栈后,已 知头结点地 址 ,在 其 后 面插入 一 个 新 结点和 删除首结 点都 十 分 方便 ,

对 应 算法的时间 复 杂 度 均为OG1))。

图 3.7 所 示为头结点 指针为 * 的 链 栈 , 首结点 是 栈顶结点 , 尾 结 点 是 栈底结 点。栈 中 元

素 自栈底 到 栈 顶依次是 cl ,as ,... ,av。

栈

(ol 0)

几 m 对

一| on

Goj-l 一 0 入

图 3.7 栈 到 链 栈 的 映射

链 栈 中 结 点 类 型 LinkStNode 的声明如下 :

typedef struct linknode

{

ElemType data;

Struct linknode # next;

}) LinkStNode;

// 数 据 域

//指针域
// 链栈结 点 类 型

在以* 为头结 点 指针 的 链 栈 ( 简 称 链栈>)中 ,可以 归纳 出对 后 面 算法 设计 来说非常重要

的 4 个 要 素 。

。 栈 空 的 条 件: * 一>next一=NULL。

。 栈 满的 条件 : 由 于 只 有 内 存 溢 出时 才 出现 栈 满,通常 不 考虑 这样的 情况 ,所以 在 链

栈中可以 看 成不存在 栈 满 。

。 元素e 的 进栈

操作: 新 建一个结 点 存放 元 素 e(由了j 指 向 它 ) ,将结 点 户插入到 头 结

。 出栈操作: 取出首结点的 data 值并将 其删除 。

在 链栈上 对 应 栈 的 基本 运算 算法 设计 如 下 。
1) 初始化 栈 initStack(&s)
该运算 创建一个空链栈*, 如 图 3.8 所示。实际 上 是 创建链栈

S

人 六]

PE

的 头 结点,并 将其next域轩 为 NULL。 算法如下;

图 3.8 创建一个空本

void InitStack(LinkStNode * &&s)

,s 一(LinkStNode * )malloc(sizeof(LinkStNode) ) ;

Ss 一 >next 一NULL;

{

}

本 算法 的 时 间 复 杂 度为O(1)。

PASS 和栈和队列 |

2) 销毁栈 DestroyStack(&s)

该 运算 释放 链 栈 * 占用 的 全 部 结 点 空间,和 单链表 的 销毁 算法完全 相同。算 法如 下 :

void DestroyStack(LinkStNode * &s)

{

LinkStNode * pre一s, * p一s 一> nexti;

//pre 指向 头 结 点,p 指向 首 结 点

while (p!I=NULL)

free(Cpre) ;

pre 一 p;

p王Pre 一> next;

{

》}

freeCpre) ;

}》

// 循环到 p 为空

// 释 放 pre 结点

//pre\p 同步 后 移

// 此 时 pre 指向 尾 结 点 ,释放其空间

本 算法 的时 间 复 杂 度为 O0z) ,其 中 7 为 链栈中 的 数据 结 点 个 数 。

3) 判断栈是否 为空StackEmpty(s)

该运算 判断:一> next=NULL 的 条 件 是 否 成 立。算法如 下 ;

bool StackEmpty(LinkStNode * s)

{

)》

return(s -> next 一 一NULL) ;

本 算法 的 时 间 复 杂 度为 OG1) 。

4) 进栈 PushC&s ,e)

该运算 新 建 一个结 点,用于存放元素e( 由 馆 指向它),然后将其 插入到 头 结 点 之 后 作为

新的首结点。算法如下 :

void PushCLinkStNode * &&s,ElemType e)

{

LinkStNode * p;

p 一(LinkStNode * )malloc(sizeof(LinkStNode)) ; //新建结点p

Pp 一> data一e;

P 一> next一s 一> next;

S 一 > next一Di;

)}

本 算法的时 间 复 杂 度为 O(1) 。

5) 出栈PopC&s ,&e)

//存放元素e

//将p 结 点 插入 作为首结 点

该运算 在 栈 不 为 空的条件 下 提取 首 结 点 的 数据 域赋给 引用 型 参数,然后将其删除。

算法 如 下 :

必_

bool Pop(LinkStNode * &s,ElemType &e)

{

LinkStNode xp;
if (s -next一一NULL)

Teturn false;

p 一 s 一 next;

e 一D 一> datai

S 一> next一pD 一> next;

// 栈 空的情况

//返回假

//p 指向首结点

// 提 取 首 结 点 值
// 删 除 首 结 点

数据 结构教程

[第! 5版

free(p);

Teturn truei

)}

// 释 放 被删 结 点 的存储 空间

// 返 回 真

本 算法 的时 间 复 杂 度为O(1)。

6) 取 栈 顶 元素GetTop(s,&e)

该运算 在 栈 不 为 空的条 件 下 提取 首结 点 的数据域赋给 引用 型 参数。。 算法如下 :

bool GetTop(LinkStNode * s,ElemType &e)

{

, 计 (s 一 next=一NULL)

// 栈 空的情况

return false;

// 返 回 假

e一s 一> next 一> datai

// 提 取 首 结 点 值

Teturn true;

// 返 回 真

)》

和 出 栈 运算 相比 ,本 算法 只 是 没有 改变栈顶结 点 ,其时 间 复 杂 度为O(1)。

【 例 3.5】 设计 一 个 算法 判断输入 的 表达 式 中 括号 是 否配对 (假设只

含有左、右圆括号) 。

该 算法 在 表达 式 括号配对 时 返回 真,否则 返回 假 。设 置 一个链 栈

st 扫描 表达 式 exp, 遇 到 左 括号时 进栈; 遇 到 右 括 号时 , 若 栈 顶 为左括号 ,

则 出 栈 ,否则 返回 假 。当 表达 式 扫描 完毕 而 且 栈 为 空 时 返回 真; 否则 返回

视频讲解

假 。算法如下 :

bool Match(char exp[] ,int n)

{

inti 一0; char e;
bool match一true;

LinkStNode * st;
JInitStack(st) ;
while (i<n 本 & match)
站 Cexp四一一'()
{

// 初始化 链 栈
// 扫 描 exp 中 的所有 字符
// 当 前 字符 为左括号 ,将其进 栈

了Push(st,exp[癌 );
else it (exp加二 一)
// 当 前字符为右括号
{ , 让 (GetTop(st,e)一一true) ,// 成功取 栈 顶 元素e
// 栈 顶 元 素 不 为'(' 时
// 表 示 不匹配

match 一 false;

这 (el一'()

{

else

Pop(st,e) ;

// 栈 顶 元 素 为'(' 时
// 将 栈 顶 元 素 出 栈

】》

else match一false;

/无法取 栈 顶 元素时 表示 不匹配

】》

证 十 ;

}

// 继 续 处 理其他 字符

迁 (!StackEmpty(Cst))

// 栈 不 空时表示 不匹配

match一false;
DestroyStack(st) ;

return match;

// 销 毁 栈

PASS和栈和队列 |

314 栈的应用

在 实际 应用中 , 栈 通 常作为一种存放 临时 数据 的 容器。如 果 后存人 的 元 素 先 处理, 则 采

用 栈。本小 节 通 过 简单 表达 式 求 值和迷宫 问题 的 求解过程 来说明 栈 的 应 用 。

1) 问题 描述

这 里 限定 的 简单 表达 式 求 值 问题是用 户 输入一 个 包含 十

一 、*、/、正

整数和 圆括号 的 合法 算术 表达 式 ,计算该表达 式 的 运算 结果 。

上

简单 表达 式 采 用 字符 数组 exp 表示 ,其 中 只含有十、一 .*、/

人 正 整数和圆括号 。 为了方

便 , 假 设该表达 式 都是合法 的 算术 表达 式 ,例如 exp="1十 2x* (4 十12)", 在 设计 相关 算法 中

用 到 栈 ,这 里 采用顺序 栈 存 储 结构 。

3) 设计 运算 算法

在算术 表达 式 中 ,运算 符位于 两 个操作 数 中间 的 表达 式 称 为中缀 表达式 (infix

expression) ,例如 1 十 2* 3 就 是 一个中 绥 表 达 式。中 绥 表 达 式 是 一种最 常用的 表达 式 形式 ,

日常生 活 中 的 表达 式 一 般 都是中 绥 表 达 式 。

对 中 绥 表 达 式 的 运算 一 般 遵循“先 乘除,后 加 减,从 左 到 右 计算 , 先 括号内 ,后 括号外 ”的

规则 ,因此 中 缀 表达 式 不仅要 依赖运算 符 优先级,还要 处 理 括号 。

或着波兰表达式,就是在
算术 表达 式 的 另 一 种 形式是后 缀 表达 式 (postfix expression)

算术 表达 式 中 运算 符 在 操作 数 的 后 面 ,如 1 十 2* 3 的 后 缀表达式 为 12 3 * 十。在 后 绥 表

达 式 中 已 经 考虑了 运算 符 的 优先级,没有括号 ,只有 操作 数 和 运算 符 , 而 且 越 放 在 前 面的运

算 符 越优先执行。

同样,在 算术 表达 式 中 ,如 果 运 算 符 在 操作 数 的 前 面,称 为前缀 表达 式 (prefix

expression),如 1 十 2* 3 的 前 绥 表达 式 为 +1 * 23。

后 缀 表达 式 是 一 种 十 分有用 的 表达 式 , 它 将 复杂 表达 式 转换 为 可以 依靠简单的操作 得

到 计算 结果 的 表达 式 。所以对 中 绥 表 达 式 的 求 值 过 程 是 先将中 组 算术 表达 式 转换 成 后绥表

达 式 ,然后对 该后绥 表 达 式 求值。

(1) 将 算术 表达 式 转换 成 后绥表 达 式 。

在 将 一 个 中 绥 表 达 式 转换 成后缀 表达 式 时 ,操作 数 之间 的 相对 次 序 是 不变的 ,但 运算 符

的 相对 次 序 可 能 不 同,同时 还 要 除去 括号 。所 以 在 转换 时 需要 从 左 到 右 扫描 算术 表达 式 ,将

遇 到 的 操作 数 直 接 存 放 到 后 缀 表达 式 中 ,将 遇 到 的 每 一个运算 符 或者左 括号 都暂时 保存 到

运算 符 栈 , 而 且 先 执行的运算 符 先出栈 。

中 妈表 达式 exp

后组 表达式 postexp

aa

假设用 exp 字符 数组 存储 满足 前 面条 件 的 简单 1;2+3

12

中 绥 表 达 式 ,其 对 应 的后缀 表达 式 存放 在 字符 数组

优先级比较

postexp 中。下 面 讨论几 种 情况 。

例如,若 exp= 王"1 十 2 十 3" ,转换 过 程 是首先 将 操
作数 1 存人 postexp; 遇 到 第 1 个 ' 十 ,尚未确定它是

一

运算行栈

否 最 先 执行 ,将 其 进 栈; 再 将操作数 2 存人 postexp;

图 3.9 两 个'十 ' 进 行优先 级 比较

数据 结构教程

[第! 5人版

又遇到第 2 个 ' 十 ,需要 两个'十' 进 行优先 级 比较 ,如 图 3. 9 所 示 ,如 果 直 接 将 第 2 个 ' 十 ' 进

栈 , 它以 后 一定先 出栈,表示 第 2 个 '十 ' 比第 1 个 ' 十 ' 先 执行,显然是错误的。正 确 的 做 法 是

先将栈中的第 1 个 ' 十 ' 出 栈 并 存人 postexp,

然后再将第 2 个 '十' 进 栈 ( 表 示 第 1 个 ' 十 ' 先 执

行); 最后 将操作数 3 存人 postexp; 此时 exp 扫描 完毕 ,出 栈第 2 个 '十 并 存人 postexp。 得

到 的 最 后结果是postexp=王"1 2 十 3 十

归纳 1: 在 扫描 exp遇到一 人个运算 符 op 时 ,如 果 栈为 空,直接将 其 进栈; 如 果 栈 不空 ,
只 有 当 op 的优先级 高于栈 顶运算 符 的 优先 级时 才 直接将 op进栈(以后op 先 出 栈 表 示 先 执

行它); 否则 依次 出 栈 运 算 符 并存和人 postexp(

出栈的运算符都比 op 先 执 行),直到栈顶运算

符 的优先级小于 op 的优先 级 为 止 , 然后再 将 op 进栈。

中 绷 表 达式 exp
2*(1+3) -4

+,
(

“
运算符栈

后 组 表达式 postexp 再看看带有括号的例子,若exp 一"2* (1 十 3)
一 和, 转换 过 程 是 将操作 数 2 存人 postexp; 遇到
2 13
存 人
.将其进酚; 遇 到 '', 将 其 进酚; 将操作 数 1

postexp; 遇 到 ' 十' ,将 其 进 栈; 将操作数 3 存人
postexp; 遇 到 ') ,如图 3. 10 所 示 ,出 栈 ' 十 "并存人

图 3.10 遇 到 ')'的情况 将'一 '进栈; 将 操作 数 4

postexp,出栈"'; 遇到' 一...,出栈'* "并存人 postexp,
存 和人 postexp; 此时 exp 扫

描 完 毕 ,出 栈 ' 一 "并 存 入 postexp 。 得 到 的 最 后结果

是 postexp王 "213 十 * 4 一"。

归纳 2: 在 扫描 exp 遇 到 一 个 运算符 op 时 ,如果 op 为 "(', 表示 一 个子表达式的开始,直

接将其进栈; 如 果 op 为 )', 表 示 一 个 子 表达 式的结束 ,需要 出栈 运算 符 并存人 postexp,直

到栈 顶 为 "(', 再 将 '('出栈; 如 果 op 是 其他 运算 符 ,而 栈 顶 为 "(', 直接 将 其 进 栈 。

设置一个运算符栈Optr,初始时为空 。为了 方便 后 面将数值 串转换 为对 应 的 数值,在

后 缀 表达 式 中 的 每个数字 串 末尾 添加 一 个 '# '。 将 算术 表达 式 exp转换成后缀表达式
postexp 的 过 程如下 :

while (从 exp读取字符 ch,ch! 一\0)

{

ch 为 数字 : 将后续 的所有 数字 均 依 次存放 到 postexp 中,并以字符'# ' 标 识 数 字 串 结束 ;

ch 为 左括号 '(': 将 此括号进栈到Optr 中 ;

ch 为右括号 )': 将 Optr 中 出 栈 时 遇 到 的 第 一 个 左 括号'(' 以 前 的 运算 符 依 次 出栈并

存放到 postexp 中,然后将左括号'('出栈;

ch 为其他运算符:

计 〈 栈 空 或者栈 顶 运算 符 为

"(') 直接将 ch 进栈;

else 这 (ch 的 优先 级高于 栈 顶运算 符 的优先级)

EEEE

直接将 ch 进栈;

else

依次出栈并存人到 postexp 中 ,直到 ch 的 优先 级 高于栈 顶 运 算 符 ,然后将 ch 进栈;

)}

若 exp 扫描 完毕, 则 将 Optr 中 的所有 运算 符 依次 出栈并 存放 到 postexp 中。

对 于 简单的算术 表达 式,, 十'和 ' 一 ' 运 算 符 的 优先 级

相同 ,* '和"运算符的优先级相同 ,

只有'* ' 和 '"' 运 算 符 的 优先 级 高于' 十'和 ' 一 运算 符 的 优先 级。所以上述 过 程 进 一步改 为 如

下:

PASS 和栈和队列 |

while (从 exp读取字符 ch,ch! 一\0)

{

,eh 为数字 : 将 后 续 的所有 数字 均 依 次存放 到 postexp 中,并以字符'# ' 标 识数字串结束;
ch 为 左括号 '(': 将 此括号进栈到Optr 中 ;

ch 为 右 括号 ')': 将 Optr 中 出 栈 时 遇 到 的 第 一 个 左 括号 '(' 以 前 的 运算 符 依次出栈 并

存放到 postexp 中 ,然后将左括号'('出栈;

ch 为' 十或'一': 出栈运算 符 并 存放 到 postexp 中 ,直到 栈 空 或 者栈顶 为 "(', 然 后将 ch

进栈;

ch 为'* ' 或/': 出 栈 运算 符 并 存放 到 postexp 中 ,直到 栈空或 者栈顶 为 "('、' 十 ' 或' 一 ,

然后将 ch 进栈;

)}
若 exp 扫描 完毕, 则 将 Optr 中 的所有 运算 符 依次出栈 并 存放 到 postexp 中 。

例如对 于 表达 式 "(56 一20)/(4 十2)”, 其 转换 为后绥 表 达 式的过 程如表 3. 1 所 示 , 最 后

得 到 的 后 绥 表 达 式 为"56#井20 间 一4#2间十 /"。

表 3.1 表达 式"(56 一 20)/(4 十2)" 转 换 成后缀 表达 式 的 过 程

操

作

postexp

Optr栈
(楼 底 杰 项 )

遇到 ch 为 "(', 将 此括号进栈

遇到 ch 为数字 ,将 56# 存 人 postexp 中

遇到 ch 为 ' 一 ', 直 接 将 ch 进栈

遇到 ch 为 数字 ,将 20# 存 人 postexp 中

56 井

56 井

56提20间

遇到 ch 为)',将栈中 '('" 之 前 的 运算 符 ' 一 ' 出栈并 存人 postexp 56#20间一

中 ,然后将'('出栈

遇到 ch 为/将 ch 进栈

遇到 ch 为 "', 将 此 括号 进 栈

遇到 ch 为数字,将 4# 存 人 postexp中
遇到 ch 为 ' 十 ,由 于 栈 顶 运算 符 为 "(', 则 直接 将 ch 进栈
遇到 ch 为数字,将 2# 存人 postexp中

56 井 20 井 一

56 井 20 井 一

56 井 20 井 一 4 井
56 井 20 井 一 4##
56 井20 井 一4提 2 提

遇到 ch 为)',将栈中'(' 之 前 的 运算 符 ' 十 '出栈 并存人 postexp 56#20井一4#2间十

中 ,然后将'('出栈

str 扫描 完毕,则 将 Optr 栈 中 的所有 运算 符 依 次 出栈并 存人 56#20# 一 4#2间十/

postexp 中 ,得 到 最 终 的后缀 表达 式

(

《

(一

(一

/

7

7
/(十
/(十

/

设置 运算 符 栈类 型 SqStack 中的ElemType 为 char 类型。根据上 述原理得到的 trans()算

法如下 :

void trans(char * exp,char postexp[)

// 将 算术 表达 式 exp转换成后缀表达式 postexp

{

char e;

SqStack * Optr;

InitStack(Optr) ;

int i一0;

while

(* exp! 一 0)

{

Switch(#x exp)

{

case

// 定 义 运算 符 栈 指针

// 初 始化运算符栈

/Vi 作为 postexp 的下标

//exp 表达 式未扫描 完 时 循环

// 判定为 左 括号

数据 结构 教程

了Push(COptr,,'();

exp 十 十 ;

break;

case )

了Pop(COptr,e) ;

while (Ce! 一'()

postexp[i十十]一 e;

Pop(COptr,e);

{

】》

exp 十 十 ;

break;

case ' 十 '

case 一

// 左括号进栈
// 继 续 扫 描 其 他 字符

// 判 定 为右括号
//出栈元素e

// 不 为'(' 时 循环
//将e 存 放 到 postexp 中
// 继 续出栈元素 e

// 继 续 扫 描 其 他 字符

// 判 定 为加 或减号

while (!StackEmptyCOptr))

{

, GetTop(Optr,e);

// 栈 不 空循环
// 取 栈 顶 元 素 e

这 (el 一 (7)

postexp[i 十 十] 一 e;

Pop(COptr,e);

{

}

else

//e不是'('
//将e 存 放 到 postexp 中
//出栈元素e

//e 是 '(' 时退出循环

break;

】》

了Push(Optr, * exp);

exp 十 十 ;

break;

Case “关

case

// 将 ' 十 或 ' 一 ' 进 栈
// 继 续 扫描 其 他 字符

//判定为'* ' 或 /号

while (!StackEmptyCOptr))

{

, GetTop(Optr,e);

// 栈 不 空 循环
// 取 栈 顶 元 素 e

过 (Ce 一 一'# '

|‖ e==一/7)

//将栈顶'* ' 或/运算符出栈并存放到 postexp 中

{

}》

else

postexp[i 十 十] 一 e;

//将e 存 放 到 postexp 中

Pop(COptr,e);

//出栈元素e

//e 为非'* ' 或/' 运 算 符 时 退出循环

break;

】》

了Push(COptr, * exp);

exp 十 十 ;

break;

default:

//将'* ' 或"/'进栈
// 继 续 扫描 其 他 字符

// 处 理 数字 字符

while

(x* exp> 一'0' 必& * exp<一'9)

// 判 定 为 数字 字符

下

postexp[i十十] 一 * exp;

exp 十十;

】》

postexp[i十十]一 '井?

//用间 标 识 一 个 数字 串 结束

】》

}

while (1StackEmptyCOptr) )

{

Pop(COptr,e);

// 此 时 exp 扫描 完毕 , 栈 不 空 时循环
//出栈元素e

PASS 和栈和队列 |

postexp[i十十] 一 e;

/将 e 存 放 到 postexp 中

}

postexp[加一 人 0"
DestroyStack(Optr) ;

)}

(2) 后 缀表达式求值。

//给 postexp 表达 式添加 结束 标识
// 销 毁 栈

若读取的是一个操作数,
后 绥 表 达 式 的 求 值过程 是从左 到 右 扫描 后 缀 表达 式 postexp,

将 它 进 操作 数 栈 , 若 读 取 的 是一个 运算 符 op, 从 操作 数栈中 连续出 栈 两 个操作 数 ,假设 为

a(第 1 个 出 栈元 素 )和 0第 2 个 出 栈元 素),计算 op a 的 值,并 将 计算结果 进 操作 数 栈 。

当 整 个后缀 表达 式 扫描 结束时 ,操作 数 栈 中 的 栈 顶元 素 就是表达 式 的 计算 结果 。

在后绥 表 达 式 求 值 算法 设计 中 操作 数 栈为 Opnd, 用 于 临时 存放 要 进行 某 种 算术 运算

的 操作 数。下 面 给 出 后 缀 表达 式 求 值的过 程 ,假设postexp 存放 的后绥 表 达 式 是 正确 的 ,在

while 循环结束 后 ,Opnd 栈 中 恰好 有 一 个 操作 数 , 它 就 是 该后绥 表 达 式 的 求 值结 果 。

while (从 postexp读取字符 ch,ch! 一\0)

{ ch为'十': 从 Opnd 栈 中 出 栈 两个数值 a 和 bb, 计算 c=b十a;将c进栈;
ch 为 ' 一 ': 从 Opnd 栈 中 出 栈 两 个 数值 a 和 b, 计算 c 一 b一a; 将 ec 进栈;

ch 为'* ': 从 Opnd 栈 中 出 栈 两个数值 a 和 b, 计 算 c一bx a;将c 进 栈 ;
ch 为 /': 从 Opnd 栈 中 出 栈 两个数值 a 和 b, 若 a 不 零,计算 c一b/a;将c 进 栈 ;
ch 为 数字 字符 : 将 连续 的 数字 串 转换 成 数值d,将 d 进栈;

}

返回 Opnd 栈 的 栈 顶操作数 (即 后 绥 表 达 式 的 值 );

后 绥 表 达 式 "56#20井一 4#2# 十 儿 的 求值过 程如 表 3. 2 所示 ,最 后 的 求 值结果 为 6,

与原表 达 式"(56 一20)/(4 十2) "的计算结果 一 致。

表 3.2, 后缀 表达 式"56 间 20 间 一4#2# 十 /" 的 求 值过程

操

作

Opnd 栈 ( 栈底一 栈 顶 )

遇到 56井 ,将 56 进栈

遇到 20# ,将 20 进栈

遇 到 ' 一 ,出 栈 两次,将 56 一20一36 进栈

遇 到 4# ,将 4 进 栈

遇 到 2# ,将 2 进 栈

遇 到 ' 十 ,出 栈 两次,将 4十2 一 6 进栈

遇 到 '/", 出 栈 两次,将 36/6一6 进栈

postexp 扫描 完毕 ,算法 结束 , 栈 项 数值 6 即 为所求

56

56 ,20

36

36,4

36,4,2

36,6

6

设置操作数栈类型SqStackl 中的ElemType 为 double 类型 ,将栈基本 运算 名 称 后 面 加

上 “17以区 别 前 面 字 符 栈 的 基本 和 运算。根据 上 述计算 原理 得 到 求后缀 表达 式 值 的 算法如下 :

double compvalueCchar * postexp)

// 计 算 后 缀表达式的值

{

, double d,a,b,c,e;

SqStackl * Opnd;

InitStackl(Opnd);

// 定 义操作数栈
// 初 始化操作 数 栈

数据 结构 教程

while ( x postexp!一\07)

//postexp 字符 串 未 扫描 完 时 循环

{人 switch (# postexp)

{
case '十'

了Popl(Opnd,a);
Popl(Opnd,b);
c 一 b 十 ai;
了Pushl(Opnd,c);
break;

case ' 一 '

了Popl(Opnd,a);
Popl(COpnd,b);
c一b一ai;
Pushl(Opnd,c);

break;

Case " 关 1

了Popl(Opnd,a);
Popl(Opnd,b);
c一 bx ai

Pushl(Opnd,c);

break;

case

Popl(Opnd,a);
了Popl(COpnd,b);
让 (Ca!一0)
{ ec一byai

Pushl(COpnd,c);

break;

// 判 定为'十' 号
//出栈元素a
//出栈元素b
// 计 算 e
// 将 计算 结果 “ 进栈

// 判定为 ' 一 ' 号
//出栈元素a
//出栈元素b
// 计 算 <
// 将 计算 结果 c 进栈

// 判 定 为'* ' 号
//出栈元素a

//出栈元素b
// 计 算 e

// 将 计算 结果 c 进栈

// 判 定 为 /' 号

//出栈元素a
//出栈元素b

// 计 算 e
// 将 计算 结果 c 进 栈

】》

else

{

printf("\nNt 除 零错误!\n");
exit(0) ;

// 异常退 出

】》
break;

default:

d 一 0;

// 处 理 数字 字符

// 将 连续 的 数字 字符 转换 成对应 的 数值存放 到 d 中

while (x postexp> 一 '0' 了 了必 * postexp<一'90)

// 判 定为数字 字符

{

,d=王10* d十x postexp一'07

PE

postexp十十 ;

】》
Pushl(Opnd,d);

break;

】》
postexp十十 ;

}
GetTop1(Opnd,e);
DestroyStack1(Opnd) ;

Teturn ei

)》

4) 设计 求解程序

设计以 下 主 责 数 调用上 述 算法 :

// 将 数值 d 进栈

// 继 续处理其他 字符

// 取 栈 顶 元 素 e
//销毁栈

// 返 回 e

PASS 和栈和队列 |

int main()

{

char exp口 一"(56 一 20)/(4十2)";

// 可 将 exp 改 为键盘输入

char postexp[MaxSize] ;

trans(exp, postexp) ;

printf(" 中 绥 表 达 式 :%s\n" ,exp);

printf(" 后 缀表达式:%sNn" ,postexp);

//将 exp 转换为postexp

// 输 出 exp

// 输出postexp

printf(" 表 达 式的值:

只 gN\n" ,compvalue(postexp));

//求postexp 的 值并 输出

return 1;

)}

5) 运行结果

运行 本 程序,得 到 对 应 的结果 如 下 :

中 组 表达 式:(56 一 20)/(4 十 2)

后 缀 表达 式 :56#20 间 一4#2# 十 /

表达式的值:6

1) 问题 描述

给 定 一个 MX

的 迷宫 图 , 求一条 从 指定入 口 到 出 口 的迷 富 路 径

。假

,其中的每个方块用空白
设 一 个迷宫图如图 3. 11 所 示 (这里M=8,N=8)

表示 通道 ,用 阴影 表示 障碍 物 。

一 般 情况下 ,所求迷 宫 路径 是 简单 路径 , 即 在求 得 的迷宫 路径上 不 会重复出现 同一 方

0123456789

块 。一 个迷宫 图 的迷宫 路径可能有多 条 ,这 些迷
宫 路径有 长有短 ,这 里 仅仅 考虑 用 栈 求一条 从 指 各

定 入 口 到 出 口的迷宫 路 径 。

2) 数据 组 织

为了表示 迷宫 ,设置 一个数组mg,其中每

个 元 素 表 示 一 个 方块 的 状态 ,为 0 时表示对应方

块是通道 ,为 1 时 表示 对 应 方块是障碍 物 ( 不 可

E)

。 为 了 算法 方便 ,一 般 在 迷宫 的 外 围 加 一 条

omaewmwewnb=

围墙 。图 3. 11 所 示 的 迷宫 对 应 的 迷宫 数组mg
(由 于 迷宫 四 周加 了 一 条 围墙,故 mg 数组 的 行 图3. 11 一 个迷宫的示意图

数 和 列 数 均加 上 2) 如 下 :

int mg[LM 十] [LN 十] 王

{人 111,1,1,1,1,1,1,1),{11,0,0,1,0,0,0,1,0,1),

{1,0,0,1,0,0,0,1,0,1},{1,0,0,0,0,1,1,0,0,1),

{1,0,1,1,1,0,0,0,0,1},{1,0,0,0,1,0,0,0,0,1),

{1,0,1,0,0,0,1,0,0,1}) ,11,0,1,1,1,0,1,1,0,1),

位 ,1,0,0,0,0,0,0,0,1), (111,1,1,1,1,1,1,1,1))};

数据 结构教程

[第人5 【版

另外 ,在 算法 中 用 到 的 栈 采用顺序 栈 存 储 结构,即将迷宫 栈 声明 如 下 ,

typedef struct

{人 int ii
int j;

int di;

) Box;

typedef struct

{

Box dataLMaxSize] ;

int top;

) StType;

3) 设计 运算 算法

// 当 前方块的行号
// 当 前方块的列号

//di 是下一 相邻可 走 方位 的 方位号
//方块类型

//栈顶指针

// 顺 序 栈 类 型

对 于 迷宫 中 的 每 个 方块 ,有 上 、 下 , 左 \ 右 4 个方块相邻,如图 3. 12 所示 ,第 守 行第7列

的 当前 方块的位置记 为(i,7) ,规定上 方 方块为 方位 0, 并 按 顺 时 针 方向 递增 编号。在 试探过

程中,假设按从方位0 到 方位 3 的 方向 查找 下 一 个 可 走的相 邻 方块。

求 迷 富 问题 就 是 在一个指定 的 迷宫 中 求 出 从 入

口 到 出 口 的一条 路 径。在求解时采用

“ 穷 举 法”,即从入 口 出发, 按 方位 0 到 方位 3 的 次 序 试探相 邻 的 方块,一 旦找到 一 个 可 走 的

相 邻 方块 就 继续走下 去,并记 下 所 走 的 方位 ; 若 某 个 方块 没有 相 邻的可 走 方 块 , 则 沿 原 路 退

回 到 前 一 个 方块, 换 下 一 个 方位再 继续 试探,直到 所 有 可 能 的 通路 都 试探 完 为止。

为 了 保证 在任何 位 置 上 都 能 沿 原 路退回 ( 称为回溯 ) ,需要 保存从人口 到 当前 位置的 路

径 上 走 过 的 方块,由 于 回溯 的 过 程 是从当前位 置退回 到 前 一 个 方块,体现 出 后 进 先 出 的特

点 ,所以 采用 栈 来 保存走 过 的 方块。

若一个非 出 口 方块(z,7) 是 可 走 的 ,将 它 进栈,每 个刚刚 进 栈 的 方块,其 方位di 置 为一1

(表示尚未试探它的周围) ,然后开始 从 方位 0 到 方位 3 试探这 个 栈 顶 方块 的四 周 , 如果找到

某 个 方位 d 的 相 邻 方 块(Ga ,广) 是可走的, 则 将 栈 顶 方块(Gi, 放 的 方位 di 置 为以 ,同时将方块

Ga , 方

) 进栈, 再 继续 从 方块(5 ' 访 ) 做相同的操作。若 方块 人 , 力 的四 周 没有 一 个 方位 是可 走

的,将它退栈,如图 3. 13 所 示 ,前 一 个 方块 (z,y) 变 成 栈 顶 方块 ,再从 方块 (z,y) 的 下 一 个 方

位 继续 试探。

《17 方位 0
、\、
|

入

方位 3
GD

,
DO

方位 1
FrD

前 一 个方志

方 人
CO 上 性
继 [| N\、_-
人
回 滑
可

当前 方块 “ZX

“ 马

Te 回湖 ,
1

S 愉|
回溯

、

路

图 3.12,迷富 方 位 图

图 3.13 方块 (, 力 的 四 周 没有一 个方位 可 走 的 情况

在 算法 中 应 保证 试探的相 邻可 走 方 块不是 已走路径上 的 方块 。如 方块(i,7 力 已 进栈,在

试探 方块(i 十 1,7 的相邻可 走 方 块时 又 会 试探到 方块 (i,7) 。 也 就是说,从 方块(i 力 出 发 会

试探方块(Ci十1,.7) ,而 从 方块(i 十 1, 力出 发 又 会 试探 方块(ij) ,这 样可 能 会 引起死循环 ,为

PASS和栈和队列 |

此 在 一 个 方块 进栈后将对 应的mg 数组 元 素 值 改 为 一1( 变 为不可 走 的 相 邻 方块 ), 当退 栈 时

(表示 该 栈 顶 方块没有可 走相邻 方 块)将 其 恢复为0。

求解 迷宫中从 入口 (xi,yiD 到 出

口 (xe*ye) 的 一 条 迷宫 路 径的过 程如 下 :

将 人 口(xi,yD 进 栈 (其初始 方位 设置 为 一1);
mg[xi [器 一一1;
while 〈 栈 不 空)

{ ,取 栈 顶 方块(i,j,di);

让 (Ci,j) 是 出 口(xe,ye))
{ 输出栈中 的 全 部 方块 构成一条 迷宫 路 径 ;

return true;

}

查找 (i,j,di) 的 下 一个相 邻 可 走 方块;

迁 (找到一个相邻可走方块)
{ 该 方块 为(il,jl) ,对 应方位 d;
将 栈 顶方块的di 设置为d;
,一1)进栈;
(iL,jl

mg[il] DI] 一一1;

}

迁 ( 没有找到 (i,j,di) 的 任何相邻可 走 方块)

{ 将(bj,diD出栈;
mg器划一0;

)}

)}

Teturn false;

// 没有找到迷宫路径

根据 上 述 过 程 得 到 求 迷 宫 问题 的 算法如 下 :

bool mgpath(int xi, int yi,int xe,int ye)

// 求解路 径 为(xi, yiD->(xe,ye)

{

Box path[LMaxSize] ,e;

int i,j,di,i,jl,k;

bool find;

StType * st;

JInitStack(Cst);

e.i一xi;i e.j一yii e.di一一1;

Push(st,e);

mg[xi] [y口一一1;

while (1StackEmpty(Cst))

{

GetTop(Cste);

// 定 义 栈 st

// 初 始 化栈顶 指针

// 设 置 e 为人口

/方块 e 进栈

// 将入口 的 迷宫 值 置 为 一1,避免 重 复走到 该 方块

// 栈 不 空时循环

// 取 栈 顶 方块e

// 找到 了 出 口 ,输出该路 径

i一e.i j一e.j; di一e.di;
i (i==xe && j= 一 ye)
{ printf("

一条迷宫路径如下:\n");

k 一 0;

while (!StackEmpty(Cst) )

PopCst,e);

path[k十十] 一 e;

//出栈方块 e
//将e 添加到 path 数组中

{

】}

while (k>一1)

人 一一;

数据 结构 教程 第人5人所

printfC"\t(%d, %d)",path[g]

让 ((k 十2)%5一一0)

printfC"N\n");

.path[k] .j);
// 每 输出 5 个方块后换一行

}

printf("\n");

DestroyStack(st) ;

Teturn true;

}

find 一 false;

// 销 毁 栈
// 输 出 一 条 迷宫 路 径 后 返回 true

while (di<4 && Ifind)

// 找 方块(i,j) 的 下 一 个相邻 可 走 方块(il ,jl)

{

di 十十 ;

switch(di)

{

】}

case 0: 这 一 i 一1; jl一j; break;

case 1:

; jj十1; break;

case 2: 十1; jl1王j; break;

case 3 :这一i; j 一 j 一1; break;

让 (mg[il] D]J] = 一 0) find一true;

// 找 到 一 个 相 邻 可 走 方块,设置 find 为真

】}

让 (find)

{

】}

else

{

】}

st-> data[st 一 > top].di一di;

e.i 一 计 ; e.j王jl1; e.di一一1;

Push(Cst,e);
mg[il] D匡一一1;

// 找 到 了 一 个 相 邻 可 走 方块Gil,j1)
// 修 改原栈 顶 元 素的di 值

// 相 邻 可 走 方块e 进栈

// 将 (il ,jl1) 迷 宫 值 置 为一1 ,避免重复 走 到 该 方块

PopCst,e);

mg[e.悦[e.沾一0;

// 没有路 径 可 走 , 则 退 栈
// 将 栈 顶方块退栈
// 让 退 栈 方块的位 置 变 为其他 路 径 可 走 方块

// 销 毁 栈
// 表 示 没有可 走路径,返回 false

}

DestroyStack(st) ;

return false;

)》

4) 设计 求解程序

建立以 下 主 责 数 调用上 述 算法 ,

int main()

让 (Imgpath(1,1,M,N))

printf("
该迷宫问题没有解!");

return 1;

{

)》

5) 运行结果

对 于 图 3. 11 所 示 的 迷宫 ,从 入 口(1,1) 到 出 口 (8,8) 的 求解结果 如 下 :

一 条迷宫路径如下 :

(1,1)

(1,2)

(2,2)

(3,2)

(3,1)

PASS和栈和队列 |

(4,1)

(6,4)

(5,1)

(6,5)

(5,2)

(5,3)

(6,3)

(5,5)

(4,5)

〈4,6)

(4,7)

(3,7)

(3,8)

(4,8)

(5,8)

(6,8)

(7,8)

(8,8)

上 述迷 富 路 径的显示 结果 如 图 3. 14 所 示 ,图

0123456789

中 路径上 方块 (7 力 中 的 箭头 表示 从 该方块 行走

入口

到 下 一 个 相 邻 方块的 方位,例如 方块 (1,1) 中 的 箭

头 是 ~”, 该 箭头 表示 方位 1, 即 方块(1,1) 走 方

位 1 到 相 邻 方 块 (1,2)。 显然这 个 解 不是最 优解,

即不是 最 短路 径 ,在 使 用 队列 求解 时 可 以 找 出 最

短路 径,这 将 在 后面介绍 。

实际 上 ,在使用 楼 求解迷宫 问题时 , 当 找 到 出

口 后 输出 一个迷宫 路径,然后可以 继续 回湖搜 索
下 一 条迷宫路径。采 用 这 种 回 淹 方法 可以 找 出 所
有 的迷宫路径。

一|一|

omacawmwrwnpb二=

天|一|一|一|一|

出口

图 3 14 用 本 求解的迷宫 路 各

队列也有 广泛 的应用 ,特别 是 在 操作 系统 的 资源分配和 排队 论 中 大 量

生 -昌

地 使 用 了 队列。本 节 主 要讨论 队列 及 其应用 。

,

321 队列的定义

队列 (queue)简称队 ,它也 是 一 种操作 受 限 的 线性表 , 其 限制 为仅允 许

让亲

在 表 的 一 端进行插入 操作 ,而 在 表 的 另 一 端 进行 删除 操作。把 进行插入 的 一 端 称为队 尾

进 队|

Ceaaj, 把 进行删除 的

一 端 称 为队头 或队首 Gont) ,如 图 3. 15 所示。

4 |队尾

号

4

|队头

中 队

向 队列 中 插入 新 元 素 称 为进队 或入队 (enqueue) ,新 元 素进队 后 就 成

为 新的 队 尾 元 素; 从 队列 中 删除 元 素 称 为出队 或离队 Cdequeue) ,元

素出队 后 ,其 直接后继 元 素 就 成为队 首 元 素 。

由 于 队列 的 插入和 删除操作 分 别是在 各 自 的 一端进行的,每个

元 素 必 然 按照 进入的 次 序出队 , 所以 又把队列 称 为先进 先出表 (First

In First Out,FIFO) 。

例如 ,若干个人驮

过 一 个 独木桥,下 桥 的 顺序和 上 桥 的 顺序 相

3.15 一个队列

同 , 在 这 里 该 独木桥 就 是 一个队列 。

队列 抽象数据 类 型 的 定义如下 :

ADT Queue

{ 数据对象 :

={ ai|1 过过 wz 全 0,a;

为 ElemType 类型}

//ElemType 是 自 定义类 型标识符

数据 结构教程

[第! 5版

数据 关系 :

及 一 (人 <aaiH> | aatED,i一1 ..., 一1)

基本 运算 :

InitQueue(&&

dg) : 初始化队列 ,构造一个空队列q。

DestroyQueue( 世 9g) : 销毁 队列 ,释放 队列 g 占用的存储空间 。

QueueEmpty(9): 判断队列 是 否 为空 , 若 队列 4 为 空,则 返回真; 否则 返回 假 。
enQueue(& aq,e): 进 队列 ,将 元 素 。 进 队作为队尾元素。

deQueue(区 g,&&e): 出 队列 ,从 队列 g 中 出 队 一 个 元 素 ,并 将 其 值赋给 e。

}

【例 3. 6】 若 元 素 的进队 顺 序为1234,能否得到 3142 的出队 顺 序 ?

若进队顺序为 1234, 不 同于栈 ,出 队 的 顺序只有 一 种 ,即 1234( 先进先 出) ,所以 不

能得 到 3142 的出队 顺 序 。
322 队列 的顺序 存储 结构 及 其 基本 运算 的 实现

打扫

最王出

队列 中 数据 元 素 的 逻辑 关系 呈 线 性 关系 ,所 以 队列 可 以 像 线性表 一样 “四 岂

采用 顺序 存储 结构 进行存储 , 即 分 配 一 块连续 的 存储 空间 来 存放队列中的 视顺计角

元 素 ,并 用 两 个 整 型变量 来反映 队列 中 元 素 的 变化,它们 分 别 存储 队 首 元 素

和 队 尾 元 素的下标位 置 , 分别称为队 首 指针 ( 队 头指针 ) 和 队 尾 指针 。 采 用顺序存储结构 的

队列称为顺序 队 (sequential queue) 。

假设 队列 中 元 素 个 数最多 不 超过 整数MaxSize,

所有的元素都具有 ElemType 数据类

型 , 则顺序队类型SqaQueue 声明如下 :

typedef struct

{

ElemType data[MaxSize] ;

// 存 放 队 中 元 素

int front, rear;

} SqQueue;

// 队头和 队 尾 指针

// 顺 序 队 类 型

队列 到 顺序 队 的 映射过 程如 图 3. 16 所 示 ,并 且约定 在 顺序队 中 队 头 指针 front 指向 当

前 队列中队 头 元 素 的 前 一 个 位 置,队 尾 指针 rear 指向 当前 队列中队 尾 元 素 的 位 置 。本 节 采

用 队列 指针 9 的 方式 建立和 使用顺序 队 。

直接殴射

顺序队

“0 了

MaxSize-l

g | | 轩 im 2

大

了

图 3.16 ”队列到顺序队的映射

data

front

Tear

伯 顺 序伏 下 实现 伏列的大木 运 千

图 3. 17 所 示 为 一 个 顺序 队 操作 过 程的示意 图 ,其中MaxSize一5。初 始时 front一

rear 一 一 1。图 3. 17(a)表示一个空队; 图 3. 17(b)表示进队 5 个 元 素 后 的 状态; 图 3. 17(c)

表示 出 队 两 个 元 素 后的状态; 图 3.17(d)

表示再出队 3 个 元 素后的 状态 。

从 图 中 可以 看 到 , 队 空的条 件为front=rear(图3. 17(a) 和 图 3. 17(d)都是这种情况);

PASS栈和队列 |

元 素进队 时 队 尾 指针 rear 总 是增 1, 所 以 队 满条件 是 rear 指向最大下标,即 rear 王 一

MaxSize一1(图 3.17(b)和图 3. 17(c)都是这种情况) 。

rear一一

4

3

2

1
0

front、rear 一一

一1

front 一一

rear 一一|

front 一一|

d

C

b

a

4

|3

2

|1

0
-1

rear 一 4

fronl 一一|

d

C

|3

2

1

0
-1

中

3

2

1

0
1

人 G) 室 队

(ba、b、c、d、e 进队

(e)

出 队 两 次

(d) 出 队 三 次

图 3.17 队列 操作 过 程 的 示意 图

综 上 所 述,对 于 g 所 指 的 顺序 队 ( 即 顺序 队 go) ,初始时设置"一> rear一g一> front一

一 1, 可 以 归纳出对 后 面 算法 设计 来 说非常重要 的 4 个 要 素 。

。 队 空的 条件: g一> front 王一g 一 > rear。

。 队满的 条件 : g一> rear 王一MaxSize一1(Cdata 数组的最大下标) 。

, 元素e 的 进 队 操作: 先将 rear增 1,然 后将 元素e 放在 data 数组的 rear 位置。

。

出 队 操作 : 先将 front 增 1,然后取出 data 数组中 front 位 置 的 元 素 。

在 顺序队 上 对 应 队列 的 基本 运算 算法 设计如 下 。

1) 初始化队列 InitOueue(&gq)

构造一个空队列 g ,将 front 和 rear 指针 均 设置 成 初始 状态 , 即 一1 值 。算法如下 :

void InitQueue(SqQueue * &q)
{

, q=(SqQueue * )malloc(sizeof(SqQueue)) ;

qd 一 front一q一> rear一一 1;

)}

2) 销毁 队列 DestroyQueue(&q)

释放 队列 9 占用的存储 空间。算 法 如 下 :

void DestroyQueue(SqQueue * &q)
{

free(q) ;

}

3) 判断 队列 是 否 为空QueueEmpty(g9)

若 队 列 d 为 空 ,返回真; 否则 返回 假 。算法如下 :

aa

bool QueueEmpty(SqQueue * q)

{

)》

Teturn(q 一 > front一一q一> rear) ;

4) 进 队 列 enQueue(C&q ,e)

在 队列 g 不 满 的 条件 下 先将队 尾 指针 rear 增 1, 然 后 将 元 素 e插入到该位置。算法如下:

数据 结构教程

[第! 5版

bool enQueue(SqQueue * 中 q,ElemType e)

{

让 (q一 rear 一一MaxSize一1)

// 队满上 溢出

Teturn false;

q一> rear 十十 ;

// 返 回 假

// 队 尾 增 1

q 一 data[q 一 rear]

一 e;

V/rear 位 置插入元素e

Teturn true;

// 返 回 真

)}

5)

出 队列 deOueue(&q ,&e)

在 队列 g 不 空的条件 下 先将队 头指针 front 增 1, 并 将 该 位 置 的元 素值赋 给 e。 算法

如 下 :

bool deQueue(SqQueue * &q,ElemType &e)

{

证 (q一 front 一 一94 一 rear)

// 队 空 下 溢出

return false;

q 一> front 十十;

e 一q一> data[q 一> front] ;

Teturn true;

)}

上述 5 个 基本 运算 算法 的 时 间 复 杂 度 均 为 O(1)。

在 前 面的 顺序 队 操作 中,元素进队时队尾指针 rear 增 1,元素出队时队

头指针 front 增 1, 当 队 满的条 件 (即 rear= 王 MaxSize 一1) 成 立时 ,表示 此 时

队 满 (上 浇 出)了 ,不 能 再进队元 素。实际上, 当 rear 一一MaxSize一1 成立

时 ,队列中可 能 还 有 空位 置,这 种 因为 队 满条件 设 置不合理 导致队 满 条 件 成立而队列 中 仍然

有 空位 置 的情况 称 为假洪 出 (false overflow) ,图 3.17(c)

所示就是假洪出的情况 。

可以 看 出 ,在 出 现 假 游 出时 队 尾 指针 rear 指向 data 数组 的 最大下标 , 而 另外 一 端还有

若干个空位置。解决的方法是把 data 数组 的 前端和 后 端 连接 起 来 ,形成 一 个环形 数组 , 即

把 存储 队列元 素 的 数组从 逮辑上 看 成 一 个环 , 称 为环形 队列 或者循环队列 (circular queue)。

环形 队列 首尾相连 后 , 当 队 尾指针 rear= MaxSize 一 1 后 ,再 前 进一个 位 置 就到 达 0 ,于

是 就可以 使用另 一 端的 空位 置存放 队列元 素了。 实际上 存储器中 的 地 址 总 是 连续 编号的 ,

队 头 指针 front 循环增 1: front一(front十1) 中 MaxSize

队 尾 指针 rear 循环增 1 : rear一(rear十1)%MaxSize

环形 队列的队 头指针 front 和 队 尾指针 rear初始化时都置 为

0,即 front=rear一0。在

进 队 元 素和 出 队 元 素时 , 队 尾指针 和 队 头 指针 分 别 循环增 1 。

那么,环形 队列 g 的 队 满和队 空 条 件 如 何 设置 呢? 显然队空条件是 4 一> rear一一4一>

front。 当 进 队 元 素 的 速度 快 于 出 队 元 素 的 速度时 , 队 尾指针 会回过 来 很 快 赶 上 队 首指针,

此时可以 看 出环形 队列的队 满条件 也是 9一> rear一一4一> front, 也 就 是 说 无法仅通过 这 两

个指针的当前位置区 分开队 空和队 满 。

100

PASS 和栈和队列 |

那么 怎样区 分 队 空和队 满呢? 改 为 以*“队 尾指针 循环增 1 时 等于队 头指针”作为 队 满 条

件 , 也 就是说 尝试进队 一 次 , 若 达 到 队 头 ,就认为 队满了 ,不 能 再进队。这 样环形 队列少用 一

个 元 素 空间 , 即该队列 中 在 任何 时 刻最多 只能有 MaxSize一1 个 元 素 。

因此,在环形队列 9 中设置队空条件 是go一 > rear王一dg一> front; 队 满 条 件 是(go一 >

rear 十1) % MaxSize一一g一> front。 而 进 队 操作和 出 队 操作 改 为 分 别将队 尾 rear 和 队 头

指针 front 循环进 1。

图 3. 18 说明了 环形 队列 操作 的 几 种 状态 ,这 里 假设MaxSize 等于 5。

Tear

[区 -人 凰

人 -动 -

(Ca) 空队

(b) a、b、c进队

(9)d进队,队满

front

位 ont

(d) 出 队 两 次

(e) 出队 两 次

,队空

图 3.18 环形 队列 操作 示意 图

在 这 样设计 的 环形 队列 中 ,实现 队列 的 基本 运算 算法如下 。

1) 初始化队列 InitQueue(&q)

构造一个空队列 g ,将 front 和 rear 指针 均 设置 成 初始 状态 ,即 0 值 。算法如下 :

void InitQueue(SqQueue * 中 q)

, q= 一(SqQueue * )malloc (sizeof(SqQueue) ) ;

qd 一 front一 q 一 rear一 0;

{

)}

2) 销毁 队列 DestroyQueue(&q)
释放 队列 9 占用的存储空间。算法如下 :

void DestroyQueue(SqQueue * &q)

{

}

free(q) ;

3) 判断队列是否为 空 QueueEmpty(q)

若 队列 为 空返回 真, 否则 返回 假 。算法如下 :

101

as

数据 结构教程

[第! 5 【版

bool QueueEmpty(SqQueue * q)

{

】}

return(q 一> front一一q一> rear) ;

4) 进 队 列 enQueue(&q,e)

在 队列 不 满的条件 下 先将队 尾指针 rear 循环增 1, 然 后 将元 素插和人到 该 位 置 。算法

如下:

bool enQueue(SqQueue * &q,ElemType e)

{

让 ((q-> rear 十1) MaxSize一一qd一 front)

// 队 满上溢出

Teturn false;

qd 一> rear 一(qd 一> rear 十1) MaxSize;

q 一> data[q 一> rear] 一 e;

Teturn true;

】》

5)

出 队列 deOueue(&q,&e)

在 队列 g 不 空的条件 下 将 队 首指针 front 循环增 1, 取 出 该 位 置 的元 素 并 赋给e。 算法

如下 :

bool deQueue(SqQueue * &&q,ElemType &e)

{

证 (q一front一一4 一rear)

// 队 空 下 溢出

return false;

qd 一 front=(q 一> front十1) 外 MaxSize;

e 一 qd-一> data[q 一> frontj ;

Teturn true;

】》

同样 ,上述 5 个 基本 运算 算法 的 时 间 复 杂 度 均 为O(1)。

说明: 在 环形 队列 中 , 队 头指针 front 指向队中队 头 元 素 的 前 一 个位 置 ,队 尾指 针 rear

指向队 中 的 队 尾 元 素 ,队列 中 的 元 素 个数= (rear 一 front十MaxSize) 只 MaxSize。

需要说明的是,环形 队列 解决 了假 洪 出 现象,更 充分 地 利用 了 队列 空间 。 那么是 不是在

任何情况 下 都 采用 环形 队列 呢 ? 答案是否定的。在 环形 队列 中 , 随着多 次元 素 的 进队和 出

队 ,出 队 元 素 的 空间 可 能 被新进队 的 元 素 覆盖 。 在 有 些情况下 ,起 要 利用出队的 元 素来 求解

(从 data 数组 角度 看 ,只 要 未 被 覆盖 ,出 队 的 元 素 仍 在其中 ) ,例如 用 队列 求解 迷宫 问题就 属

ee

于 这 种情况,所以 采用 环形 队列 还 是非 环形 队列 根据 实际 求解问题 来确定 。

【例3. 7】 对 于 环形 队列 来说,如 果 知道队 头指针 和 队列 中 的元 素个数 , 则 可 以 计算出
队 尾 指针 。 也 就 是说,可以用队列 中 的 元 素 个 数 代替 队 尾指针 。 设计 出 这 种 环形队列 的 初

始化. 进 队 .出 队 和 判队空 算法 。

依 题 意 设 计 的 环形 队列 类 型如 下 。

typedef struct

{

ElemType data[LMaxSize] ;

102

PASS 和栈和队列 |

int front;

int count;

) QuType;

// 队 头 指针

// 队 列 中 的 元 素个数
// 本 例 的 环形 队列 类 型

当 已知队列 的 队 头指 针 front

和 队列 中 的元 素 个 数 count 后,队 尾指针

rear 的计算 公式 是 rear= (front

十count)%MaxSize。 因此,这种队列的队空

条 件为count==0; 队满条件为count王一MaxSize; 元素 e 的进队操作是先

根据 队 头指针 和 元 素 个 数 求 出 队 尾指针 rear,将 rear 循环增 1, 然 后 将元 素 e
放置在 rear 处; 出 队 操 作 是 先将队 头指针 循环增1,然后取出 该 位 置 的元 素 。 二

对 应 的算法如下 :

void InitQueue(QuType * qu)

// 初始化 算法

{

qu=(QuType * )malloc(Csizeof(QuType) ) ;

qu 一> front一0;

qu 一 count一0;

}
bool EnQueue(CQuType * & qu,ElemType x)

{

int rear;

迁 (qu 一> count 一一MaxSize)

return false;

else

rear 一(qu 一 > front十qu 一> count) 外 MaxSize;
rear一(Tear 十1) %MaxSize;
qu 一> data[rear] 一 x;

qu 一 count 十十;

ITeturn true;

{

}

}
bool DeQueue(QuType * &qu, ElemType &x)

{

让 (qu-> count 一一0)

return false;

// 队 头 指针 设置为0

// 队 列 中 的 元 素 个 数 设置为0

//进队算法
// 临 时存放 队 尾 指针
// 队 满上溢出

// 求 队 尾 位 置
// 队 尾 指针 循环增 1

// 元 素个数 增 1

//出队 算法

// 队 空下溢出

十1)%MaxSize;
qu 一 front=(qu 一> front

// 队 头 循环增 1

else
{

}

Xx 一qu 一 data[Lqu 一> front] ;

qu-> count 一一;

ITeturn true;

}
bool QueueEmptyCQuType * qu)

{

}

return(qu 一> count一一0) ;

// 元 素个数 减 1

//判队空算法

注意: 采用 本 例设计 的 环形队列 中 最多可以 放置MaxSize 个 元 素 。

要--扫

323 队列 的 链 式 存储 结构 及 其 基本 运算 的 实现

队列 中 数据元 素的好 辑 关系 呈线 性 关系,所以队列 可 以 像线性表 一 样采 首

区

月晶链 式 存储结构。采

链 式存储 结构的队列 称 为链队 (linked queue) 。 链 表

视频讲解

103

数据 结构教程

[第! 5 【版

有 多 种 ,这 里 是 采用 单 链 表 来 实现 链 队 的 。

在 这 样 的链队 中 只 允许 在 单 链表 的 表 头 进行删除操作 (出 队 ) 和 在 单链表 的 表 尾 进行 插

和操作(进队),因此需要使用队头指针 front 和 队 尾指针 rear 两 个指针 ,用 front 指向队首

结 点,用 rear 指向 队 尾 结 点 。和 链 栈 一 样 ,链队 中 也 不 存在 队满上 溢出 的 情况 。

链 队 存储 结构 如 图 3. 19 所示。链 队 中 数据 结 点 的 类 型 DataNode 声明如下 :

typedef struct qnode

{

ElemType data;

//存放元素

Struct qnode # next;

// 下 一 个 结 点 指针

} DataNode;

// 链 队 数 据 结 点 的 类 型

队列

(al ap ap

ap)

ja

队 首 结 点

队 尾 结 点

一| al

一| 2

一

王| ar | 人

图 3. 19 链 队 存 储 结构

链 队 头 结 点 (或 链 队 结 点 ) 的 类 型 LinkQuNode 声明如下 :

typedef struct

{

DataNode * front;

DataNode * rear;

// 指 向 队 首 结 点

// 指 向 队 尾 结 点

LinkQuNode;

// 链 队 结 点 的 类 型

图 3. 20 说明了 一 个 链 队 9 的 动态变化 过 程 。图 3. 20(a) 是 链 队 的 初始状态 ,图 3. 20(b)是

在 链 队 中 3 个 元 素进队 后 的状态 ,图 3. 20(c) 是 链 队 中 一 个 元 素出队 后 的状态 。

4 链 队结 点

front| 从

rear| 入

{a) 链 队初 态

人 人

他ont

rear

|

一| 万 一 cc |入

人

(b) 3 个 元 素 进 队

个人

人font

rar|

站

一| 书

cc | 人

(c) 一 个 元 素出队

3. 20 ”一 个 链 队 的 动态变化 过 程

104

PASS栈和队列 |

在以 v 为链队 结 点 指针 的 链 队 (简称链队 g) 中 ,可以 归纳出对 后 面 算法 设计 来 说非常

眶

下要的 4 个要素 。

。 队 空 的 条件: g 一> rear王=NULL(也可以为 q 一> front==NULL)。

。 队 满的 条件 : 不 考虑。

。 元素e 的进队 操作: 新 建 一 个结 点 存放 元 素 e(由之指向它) ,将结点 户插 入 作为 尾结 点 。

。 出队操作: 取出队首结点的 data 值 并 将 其 删除 。

在 链队上 对 应 队列 的 基本 运算 算法 设计 如 下 。

1) 初始化队列 InitOueue(&q)

构造 一 个空队 ,即 创建一个 链 队 结 点 ,其 front 和 rear 域 均 置 为NULL。 算法如下:

void InitQueue(LinkQuNode * &q)

{ , q= 一(LinkQuNode * )malloc(Csizeof(LinkQuNode) ) ;

qd 一> front王q -> rear一NULL;

}

本 算法的时 间 复 杂 度为O(1)。

2) 销毁 队列 DestroyQueue(&q)

释放 链 队 占用 的 全 部 存储空间 ,包括 链 队 结点和 所 有 数据 结 点 的 存储 空间。算法如下:

void DestroyQueue(LinkQuNode * &q)
{

DataNode * pre一q一> front, x p;

//pre指向队首结点

这 (pre!l王NULL)

{ , p 一 pre一> next;

while (p!I=NULL)
free(pre);
{
pre 一 p;p 一 p

一 > nexti;

】}
free(Cpre) ;

}
free(q) ;

)}

//p 指向 结 点 pre 的后继 结 点

//p不空循环
// 释 放 pre 结点
//pre\p 同步后移

// 释 放 最 后 一个数据 结 点

// 释 放 链 队 结 点

本 算法的时 间 复 杂 度为 O(0z) ,其 中 7 为链队 中 数据 结 点 的个数 。

3) 判断队列是否为 空 QueueEmpty(q)

若 链 队 为 空 ,返回真; 否则 返回 假 。算法如下 :

bool QueueEmpty(CLinkQuNode * q)

{

)》

return(q -> rear 一一NULL);

本 算法的时 间 复 杂 度为O(1)。

4)

进 队 列 enQueue(&q,e)

创建 一 个新结 点 用 于 存放 元 素 e(由之 指向它)。若 原 队列 为 空 , 则 将 链 队 结 点 的 两个域

均 指向 结 点 刀 , 和 否则将结点 妃 链 接 到 单 链表 的 末尾 ,并让 链 队 结 点的 rear 域指向它。算法如下 :

Rs

数据 结构教程

[第! 5人版

void enQueue(LinkQuNode * &q,ElemType e)

{

DataNode * p;

p 一(DataNode * )malloc(sizeof(DataNode));

// 创建新结点

p 一> data一e;

p一> next王NULL;

让 (q一> rear一一NULL)

qd 一 front一q 一> rear一p;

// 若链队 为 空 , 则 新 结 点 既是 队 首 结 点 又是队 尾 结 点

qdq 一 rear一next一Di;

// 将 结点 p 链 到 队 尾 ,并 将 rear 指向 它

// 若 链 队 不 空

Qq

一 >Irear一Di;

else

{

}

》

本 算法 的时 间 复 杂 度为O(1)。

5) 出 队列 deOueue(&q,&e)

若 原队列为 空 , 则 下 游 出 返回假; 若 原队列不 空 , 则 将 首结 点 的 data 域值赋 给 e, 并 删

除 之 , 若原队列只有 一 个结 点 , 则 需 将 链 队结 点 的 两 个 域 均 置为NULL,表示队列已为空。

算法如下 :

bool deQueue(LinkQuNode * &q,ElemType &e)

{

DataNode * ti;

这 (q 一 rear一一NULL)

// 原来队列为空

return false;

t 一q 一 front;

/人t 指 向 首 结 点

让 (q 一 front一一q 一> rear)

// 原来队列 中 只 有 一 个 数据 结点时

qd 一 front一qd 一> rear一NULL;

else

// 原来队列 中 有 两 个 或 两 个 以上结 点 时

qd 一 front一q 一 > front 一 > next;

e 一 t 一> datai

free(t);

Teturn true;

)}

本 算法 的时 间 复 杂 度为O(1)。

【例3. 8〗 采用 一 个 不带头结 点只有 一 个 尾结 点指针 rear 的 循环 单链表 存储 队列 , 设

计 队 列 的 初始 化`. 进队和 出 队 算 法 。

本 例 的 链 队 如 图 3. 21 所示 , 用 只 有 尾结 点 指针 rear 的 循环 单 链 表 作 为 队列存储 结

构 , 其 中 每 个 结点 的类 型为LinkNode(LinkNode 为 单链表 结点类 型 ,在 第 2 章中已声明 ),

PE

rear 指针 用 于 唯一标识链 队 ,对 应 链 队 的 4 个 要 素 如 下 。

队头

rear |

队尾

一| 1

一| CD 一 on

图 3.21 用只有 尾 结 点 指针 的 循环 单链表 作为 队列 存储 结构

106

PASS 和栈和队列 |

。 队 空 的条件 : rear王=NULL。

。 队 满的条件 : 不 考虑 。

。 元 素 e 的进 队 操作 : 新 建 一 个结 点存放元素e(由了刀 指向它) ,将 结 点 丸 插入作为尾

结点,让 rear 指向这个 新 的 尾结点 。

出 队 操作 : 取出队头结点Crear 所 指结 点的后继结点 )的 data 值 并将 其 删除 。

需要 注意 的 是 ,在 该链队 进 队 和 出 队 操 作 后 链 队或 者 为 空 ,或者为 一个不带头结点的由

尾 结 点 指针 rear 唯一标识 的 循环单链表 ,不能 改变 其结构 特性 。

对 应 的 队列 基本 运算 算法 如 下 :

void initQueue(CLinkNode * & rear)

// 初 始化算法

rear一NULL;

本 enQueue(LinkNode * &rear,ElemType e)

//进队 算法

{

LinkNode * pi;

p 一(LinkNode * )malloc(sizeof(LinkNode)); /创建新结点

p 一 data一e;

这 (rear一王NULL)

, p 一 next一p;

rear 一 pi

{

)}

else

// 原 链 队 为空

// 改 为 循环链表

V/Vrear 指向新结点

// 原 链 队 不 空

{

, p 一 next一rear 一> next;

//将p 结 点 插入到 rear 结 点 之 后

Tear -> next一p;
rear 一 pi;

// 改 为循环链表
//rear 指向新结点

)}

)》

bool deQueue(LinkNode * &rear,ElemType &e)

// 出 队 算 法

{

LinkNode *ti

这 (rear一王NULL)

Teturn false;

// 队 空

else 计 (rear 一 > next一一Tear)

// 原 队 中只有 一 个 结 点

ee一rear 一> datai

free(rear) ;
rear一NULL;

{

}

else

//让 rear 为 空链表

// 原 队 中 有 两 个 或 两 个以上 的 结 点

{ t一 rear一> nexti

/Mt 指向 队 头 结 点

ss

e一t 一> datai;

Tear 一> next一t 一 > next;

free(t)

}

Teturn true;

)}

// 删除+ 结点

// 释 放 结 点空间

bool queueEmpty(LinkNode * rear)

// 判队空算 法

107

数据 结构教程

[第! 5版

Teturn(rear 一一NULL) ;

324 队列的应用举例

在 实际 应用中 ,队列 通常 作为 一 种存放 临时 数据 的 容器 。 如 果 先存和 的 元 素 先处理 , 则

采用 队列。本小 节 通 过 报 数 问题和迷宫 问题 的 求解过 程 介绍 队列 的应用 。

1) 问题 描述

设有宛

个 人 站 成 一排,从 左 向 右 的 编号 分 别为 1一7” 现在从左 往 右 报 数“1,2,1,2,...”,

数 到 “1?的人 出 列 , 数 到 “2 的 立即 站 到 队伍 的 最 右 端 。报 数 过 程 反复 进行,直到 个 人 都 出

列 为 止 。要 求给出 他 们 的 出 列 顺序 。

例如,当 7 一 8 时 初始序列 为 ;

12345678

则 出 列顺序为:

13572648

2) 数据 组 织

用 一 个 队列 解决 出 列问题,由 于 这 里 不 需要 使用已经出队 后 的 元 素,所 以 采用 环形

队列。

3) 设计 运算 算法

采用 的 算法思想是先 将交个 人 的 编号进队 ,然后反复 执行 以 下 操作 ,直到 队列 为空。

(1)

出 队 一 个 元 素 , 输出其 编号( 报 数为 1

的 人 出 列 ) 。

(2) 若 队列 不 空 , 再出队 一 个 元 素 ,并 将 刚 出 列 的 元 素进队 ( 报 数为 2 的人站 到 队伍的

最 右 端 ,即 队 尾 ) 。

对 应 的算法如下:

void number(Cint n)

{

inti; ElemType e;

SqQueue * qi
InitQueue(q) ;
一nii十十)
for (Gi=1;i<

enQueue(q,iD;

printf("

报数出列顺序:");

pe

// 环 形队列指针 q
// 初 始化队列 q
// 构 建初始序列

while (1QueueEmpty(q))

// 队 列 不 空 循环

{

deQueue(q,e);

//出队 一 个 元 素 e

printf("%d ",e);

// 输出元 素编号

让 (!QueueEmpty(q))

// 队 列 不 空

108

PASS 和栈和队列 |

deQueue(q,e);

enQueue(q,e) ;

//出队 一 个 元 素 e

// 将 刚出队 的 元 素进队

{

】}

}

printfC"\n") ;
DestroyQueue(q) ;

}》

//销毁队列q

4) 设计 求解程序

设计 一 个 主 函 数 调用上 述 算法 :

int main()

int in一8;
printf("初始 序列 :");
for (ji王1;i<一nii十十)

printf("%d ",iD;

printfC"N\n");

numberCn);

return 1;

{

)》

5) 运行结果

上 述程序 的 运行结果 如 下 :

初始 序列:12345678
报 数出列 顺序:13572648

1) 问题描述

参见 3.1.4 节 的问题描述 。

2) 数据 组 织

站

了

用 队列 解决求迷宫 路 径 问 题 。 使用一 个顺序队 qu 保存 走 过 的 方块,该

训帮

队列的类型声明如下 :

typedef struct

{

intij;

int pre;

)》 Box;

typedef struct

// 方 块 的位置

// 本 路 径中上 一 个 方块在队列 中 的 下 标
// 方块类 型

Rss

{

Box dataLMaxSize] ;

int front, rear;

) QuType;

// 队 头 指针 和 队 尾 指针
// 顺 序 队 类 型

这 里 使用的 顺序 队列 qu 不 是 环形 队列 ,因为 在找到 出口时 需要 利用 队列 中 的所有 方块

查找一条迷宫路径。如 果 采 用 环形 队列 ,出 队 的 方块可 能 被 新进队 的 方块覆盖 ,从 而 无法求

109

数据 结构教程

[第1 5 【版

出 迷 富 路 径。这呈

要求非环形队列qu 有足够大的空间 。

3) 设计 运算 算法

搜索 从 人 口(xi,yD 到 出 口(xe,ye) 路 径的过 程是,首先将人口(xi,yiD 进 队 , 在 队列 qu

不 为 空时 循环 ,出 队 一 个 方块 e( 由 于 不是环形 队列 ,该 出 队 方块 不 会被覆盖 ,其 下 标 为

front)。然后查找 方块 e 的所有 相 邻可 走 方块,假设

为 ea 和 es 两 个 方块,将 它们 进 队 ,它们

在 队列 中 的位 置 分 别为 rearl 和 rear2 ,并 且 将 它 介

因为在迷富路径
的 pre 均设 置为front(

上 e; 和 es 两 个 方块的前 一 个 方块都 是 方块e) ,如图 3. 22 所 示 。

方块e

front

人 万

方志取 Na

Tearl

人 四

rear2

(2, 亡)

方块el的pre置为front

方块ex的 pre 置 为 front

图

3.22 设置相邻方块的pre

当找 到 出

口 时 ,通过 出

口 方块的pre 值 前 推找到 出

口 ,所有经 过 的 中间 方块构成一条 迷

富 路 径。对 应 的 完整过 程如 下 :

将 人 口(xi,yiD的 pre 置 为 一1 并 进 队 ;
mg[xi] [yj 一 一 1;
while〈 队列qu 不空)
{

出 队 一 个 方块 。, 其在队列 中 的 位 置是front;

庄 (方块e是出口)

{ 输出一条迷宫路径;

return true;

}
for (对 于 方块e 的所有 相 邻 可 走 方块el)

{ 设置 el 的 pre 为 front;

将 方块el 进队;
将 方块el 的 迷宫 数组值设 置 为一1;

}

)}

Teturn false;

// 没有迷宫 路 径 , 返 回 假

实际 上,上 述 过 程 是从人口(xi,yD开始,利用队

列 的特点 ,一层一层 向 外 扩展 查找 可走

的 方块,直到找到 出 口 为 止,这 个 方法 就 是将在第 8

章 介绍 的 广度优先 搜索 方法 。

在找到 出 口后,输出 路 径 的 过 程 是根据 当前 方块 (即 出 口,其在队列 qu 中 的 下 标 为

front)的 pre 值 回 推 找到迷宫路径 。 对 于 图 3. 11 所 示 的 迷 富 ,在找到 出口后,队列 qu 中

data 的 全 部数据如表 3. 3 所示。当 前 的 front一40, qu 一 > dataL40]. pre 为 35,表示路径上

的 前 一 个方块为 qu 一> data[35]; 而 qu 一> dataL35]. pre 为 30, 表 示 路径的上 一 个方块为

qu一> dataL30]; qu一> dataL30]. pre 为 27,表示 路 径

上 的 前 一 个方块为qu一> dataL27],... ,以

此 类 推 ,找到入 口为qu一>dataL0]。 在 对 应 的 prin

t 函数 中 ,为 了 正 向 输出 路 径 ,在 前 面 的

110

人 3 名 久 栈和队列 |

回 推 过 程中修改 路径上 每 个 方块的pre 值 ,使该迷宫路径上的所有 方块的pre 值置为

一 1,然后从开头输出所有 pre 为一1 的 方块,从 而 正 向 输出了 一 条迷宫路径。

表 3.3 队列 qu 中 data 的 全 部数据

了

6

5

5

5

5

6

5

6

7

6

4

7

8

了

7

3

7

8

8

8

Pre

18

20

22

22

23

23

24

25

26

27

27

28

29

29

30

31

32

32

33

35

下 标

0

1

2

3

生

5

6

7

8

9

10

11

12

13

14

15

16

1]17

18

19

20

1

1

2

2

3

3

人4

3

5

3

5

6

2

5

7

1

2

6

1

2

6

了

1

2

1

2

1

2

1

3

1

人4

2

1

人4

3

1

4

5

3

5

6

生

pre

一 1

0

0

1

2

3

人4

5

6

7

8

8

9

10

]1

12

12

13

15

16

17

下 标

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

1

6

5

7

人4

5

8

4

5

8

8

4

5

6

8

8

3

人4

6

8

根据上 述 搜索 过 程 得 到以下用队列求解迷宫的算法 :

bool mgpathl(int xi,int yi,int xe,int ye)

// 搜 索 路 径 为(xi, yi)->(Cxe,ye)

{

Boxei;

int ij,j,di,i,jl1;

QuType * qui

JInitQueue(qu) ;

// 定 义 顺 序 队 指 针 qu

// 初 始化队列 qu

e.i一Xii e.j一yii e.pre一一1;
enQueue(Cqu,e);
mg[xi] [7趾 一一1;
while

(1QueueEmpty(Cqu))

/VCxi,yiD进队
// 将 其 赋值 一1, 以 避免回过 来重复 搜索
// 队 不 空循环

{

deQueue(Cqu,e);

//出队方块 e, 由 于 不 是 环形 队列 ,该出队 元 素 仍 在 队列 中

aa

1 一 e 一 e.Ji;
让 (ii 一一xe && j==一ye)

。 // 找 到 了 出 口 ,输出 路 径

{

, printCqu,qu-> front);

// 调 用 print 函数输出 路 径

DestroyQueue(qu);

//销毁队列

Teturn true;

// 找 到 一 条 路 径 时 返回 真

}

for (di=0idi<4;di 十 十) ,// 循环扫描 每个方位 ,把 每个可 走 的 方块 插入 到 队列 中

111

数据 结构教程

[第! 5版

{

switch(Cdi)

{

case 0: 这 一 i 一1; j1王j; break;

case 1 :这一i; j 一 j 十1; break;

十1; 这王j; break;

case 3 :这一i; j一j一1; break;

】}

计 Cmg[iljDI] 一 一0)

ee.i王ii e.j一j1;
e.pre 一qu 一> front;

// 指 向 路 径中上 一 个 方块 的下标

enQueue(qu,e) ;

//Gil,j1)方块进队

mg[il] DI一一1;

// 将 其 赋值 一1, 以 避免回过 来重复搜索

{

】}

】}

}

DestroyQueue(qu) ;

return false;

}

//销毁队列

// 未 找到 任何 路 径 时 返回 假

void print(QuType * qu,int front)

// 从 队列 qu 中 输出 一 条 迷宫 路 径

{

intk

一 front,j,ns一0;

printfC"N\n") ;

do

{

jj一ki

// 反 向 找到 最 短路 径 , 将 该 路径上 的 方块的pre 成员设置成一1

k一qu 一 > data[k] .pre;

qu 一> data[j] .pre 一一1;

} while (k!一0);

printf("

一条迷宫路径如下:\n");

kk一0;

while (k< MaxSize)

// 正 向搜索到 pre 为一1 的 方块 ,即构成正向的路径

{

这 (qu data[k] .pre 一 一一1)

ns 十十 ;

printfC"Nt(%d, %d)",qu 一> data[l.i,qu-> data[k] .j);
这 (ns%%5一一0) printf("\n");

// 每 输出 5 个方块后换一行

{

】}

上十十;

}

printfC"N\n") ;

}

4) 设计 求解程序

建立以下 主 函 数 调用上 述 算法 ,

int main()

{

让 (Imgpathl(1,1,M,N))

printf("

该迷宫问题没有 解 !");

return 1;

112

PASS 和栈和队列 |

5) 运行结果

对 于 图 3. 10 所 示 的 迷宫 ,求解结果 如 下 :

一 条迷宫路径如下 :

(1,1)

(2,1)

(3,1)

(4,1)

(5,1)

(5,2)

(5,3)

(6,3)

(6,4)

(6,5)

(7,5)

(8,5)

(8,6)

(8,7)

(8,8)

上 述 迷宫 路 径 的显示 结果 如 图 3. 23 所 示 ,图 中 路径上 方块Gi,7 力 中 的 箭头指向 路 径 的

前 一个相 邻 方块,例如 方块 (2,1) 的 箭头 是

“个

”, 表 示 路径上 前 一 个 方块 是 方块 (1,1), 即出

口 。显然这 个解是 最 优 解,也 就是最 短路 径 。

0123456789

入口

王|一|一|一

omaewmwewnpb=

图 3.23 用 队列 求解的迷宫 路 径

325 双 端 队列

所谓 双 端 队列(deque,double-ended queue)是 指 两 端都 可 以 进行进队

和 出 队操 作的 队列 ,如 图 3. 24 所示。将 队列 的 两 端 分别称 为 前 端和后 端 ,

两 端 都 可以 进队和 出 队 。 其 元 素 的 逻辑 关系 仍 是 线性 关系 。

前 端 进

和

前 端

后 端

L

后端进

后端出

图 3.24 一 个 双 端 队列

在 双 端 队列 中 进 队 时 ,前 端进的 元 素 排列在队列 中后端进 的 元 素 的前面 , 后 端进的 元 素
排列在队列 中 前 端进的 元 素 的 后 面 。在 双 端 队列 中出队时 ,无 论 前 端 出 还 是 后 端出, 先 出 的

aa

元 素 排列 在后出 的 元 素 的 前 面 。

例如有 a\b\c,\d 元 素进队 , 能 否产生 dcab 的出队序列呢? 答案是肯定的。其 操作 方式

为 a 后 端进,b 后 端 进,c 前 端 进,d 前 端 进,再 全 部 从 前 端出队 , 便 可以 得 到 这 样 的出队序

列 。 那 么 是 不是可以通过 双 端 队列得 到任意 次 序 的出队 序列呢? 答案是否定的,例如 ab、

c\d 元 素 进 队 就 不 能 产生 dacb 的出队 序列 ,因为 a 进队,b 从 后 端 进,c 无论从 前 端 进 还是从

后 端 进都不可 能 在 a\b 的中间 。

113

数据 结构教程

[第5 【版

实际 上 ,从 前 面的双 端 队列 可 以 看 出 ,从后端进 前 端 出 或者从 前 端 进 后 端 出 体现 先进 先

出 的特点,从 前 端进前 端 出 或从后 端 进 后 端 出体现 出 后 进 先 出 的特点 。

在 实际 使用中 ,还可以 有 输出 受 限的双 端 队列 ( 即 允许 两 端进队 ,但 只 人允许 一 端 出 队 的

双 端 队列)和 输入受限的双 端 队列 ( 即 允许 两 端 出 队 ,但 只 允许 一 端进队 的 双 端 队列 ) ,前 者

如图 3. 25 所示 ,后者如图 3. 26 所示。如 果 限定双 端 队列 中 从 某 端进队 的 元 素 只 能 从 该端

出 队 , 则 该 双 端 队列就赔 变 为 两 个 栈底相 邻 的栈了 。

前端进

人 后端

Pi

一 一 后 端 进

图 3. 25 ”一 个 输出受限 的 双端队列

前 光

吕 AFM

图 3.26 ”一 个 输入受 限 的 双 端队列

后中

压

【例3.9】

某 队 列 允许 在 两 端 进行人队 操作 ,但 仅 允许 在 一 端 进 行 出 队操作,若 a\b、c、

de 元 素 进 队 , 则以 下 不 可 能得 到 的 顺序 有 哪些?

(1) bacde

(2) dbace

(3) dbcae

〈4) ecbad

本 题的队列实际上 是 一 个 输出 受 限的双 端 队列 ,这样的双 端 队 列如 图 3. 25 所示 。

(1) a 后 端 进,b 前 端进,c 后 端 进,d 后 端 进,e 后 端 进,全 出 队 。

(2) a后端进,b 前 端进,c 后 端 进,d 前 端 进,e 后 端 进,全 出 队 。

(3) a 后 端 进,b 前 端 进,因 d 未 出 ,此 时 只 能进队 ,ec怎么进都不可能在ba 之间 。

(4) a 后 端 进,b 前 端进,c 前 端 进,d 后 端进,e 前 端 进,全 出 队 。

所以 不可 能得 到 的 顺序 为(3) 。

【例3. 10〗

如 果人允许 在 环形 队列 的 两 端 进行 插入和 删除 操作 (这 样的队列即为双端

队列) , 若 仍 采用 前 面定义的SqaQueue 队列 类 型 ,设计 “从 队 尾 删 除 ”和 ”从 队 头 搬入”的

算法。

从 前 面 介绍 的 环形 队列结构 可以 看 到 , 队 头指针 front 指向 队列 中 队 首 元 素 的 前 一

ee

个 位 置 ,而队 尾指针 rear 指向 队列 中 的 队 尾元 素。所以“从 队 尾 删除?运算 应 先 提取 队 尾 元
素 ,再 循环后退 一 个 位 置 ,而“从 队 头插入 ”运算 应 先在队 头插人 元素 ,再 循环 后退一 个 位 置 。

实现“从 队 尾 删除?运算的算法如下 :

bool deQueuel(SqQueue * &q,ElemType &e)

//从队 尾删除 算法

{

这 (q->front一一一> Tear)

// 队 空 返 回 假

return false;

e 一qd 一 data[q 一> rear];

// 提 取 队 尾 元 素

只MaxSize;
qd一> rear一(qd一> rear 一 1十MaxSize)

// 修 改 除 尾 指针

114

PASS 和栈和队列 |

Teturn true;

】}

实现“从 队 头插入 ”运算 的 算法如下 :

bool enQueuel(SqQueue * &q,ElemType e)

// 从 队 头 插入 算法

{

证 ((q-> rear十1)中 MaxSize一一a一 front)

// 队 满返回假

Teturn false;

q 一 > data[q 一 > frontj 一 e;

// 元素e 进 队

qd-

一 > front=(q 一 front 一 1十MaxSize) %MaxSize;

// 修 改 队 头 指 针

Teturn true;

一 本章小结 一一一

本 章 的 基本 学 习 要 点如 下 :

(1) 理解 栈和 队列 的特性以 及 它们 之间 的 差异。

(2) 掌握栈的两类 存储结构 ( 即 顺 序 栈 和 和链栈 ) 的设计特点 ,注意 顺序

栈 和链栈中材 满 和 栈 空 的 条件判断 。

(3) 掌握 在顺序 栈 和 和链 栈 中 实现 栈 的 基本 运算 的 算法设计 方法 。

(4) 掌握队列 的两类 存储 结构 ( 即顺 序队和链 队 ) 的设计特点 ,环形 队

列 和 非 环形 队列 的 差异 ,注意 各种 存储 结构中 队 满和 队 空的条件 判 断 。

(5) 掌握 在 顺序队 和链 队中实现 队列的基本 运算 的 算法设计 方法 。

十

(6) 理解 栈和 队列 的 作用 ,知道 在 何时 使 用 哪 一种数据结构 ,用 材 和 队列 求解 迷

蔬 问题

的 差异。

(7) 灵活地 运用栈 和 队列两种数据 结构解决 一 些综合 应 用问题 。

>, 练习题 3 一

1. 有 5 个 元 素 ,其 进 栈 次 序 为 A.B`C、D\ 丰 ,在 各 种 可 能 的 出栈次序中以 元素CD 最

先出栈(即 C 第 一 个 且 了 第 二 个出栈 ) 的 次序有 哪几个 ?

2. 在 一 个 算法 中 需要 建立多 个 栈 (假设 3 个 栈 或 以上) 时 可 以 选用以下 3 种方案之一,

试问这 些 方案 相比各有 什么 优 缺 点 ?

(1) 分别 用 多 个 顺序 存储空间 建立多 个 独立 的 顺序 栈 。

aa

(2) 多 个 栈 共 享一个 顺序 存储空间 。

(3) 分 别 建立多 个 独立 的 链 栈 。

3. 在以下几 种 存储 结构 中 哪个最 适合 用 作 链 栈 ?

(1) 带头结点的单链表 。

(2) 不 带头 结 点 的循环 单 链表 。

(3) 带头 结 点的双 链 表 。

数据 结构教程

昌@

4. 简 述以 下 算法 的 功能 (假设ElemType 为 int 类型) 。

void fun(ElemType a[] ,int n)

{

inti ElemType e;

SqStack * stl, * st2;

JInitStack(Cstl1) ;
JInitStack(Cst2) ;

for (i=0;i<ni;i十十)
过 (a跨%2 一一1)

了Push(stl,a[ 口 );

了Push(st2,a[癌);

else

i 一 0;

while (!StackEmpty(Cstl))

{

Pop(Cstl,e);

a[i 十 十] 一 e;

}
while (1StackEmpty(Cst2))

, Pop(Cst2,e);

a[i 十 十] 一 e;

{

}

DestroyStack(st1) ;

DestroyStack(st2) ;

5. 简 述以 下 算法 的 功能 (顺序 栈 的 元 素 类 型为ElemType) 。

void fun(SqStack * & st,ElemType x)

{

SSqStack * tmps;

ElemType e;

JnitStack(Ctmps) ;

while(!StackEmptyCst))
{

PopCst,e);

ii(e!一x) Push(tmps,e);

}

while (!StackEmptyCtmps) )
{

Pop(tmps,e);

Push(st,e);

}

DestroyStack(tmps) ;

6. 简 述以 下 算法 的 功能 ( 栈 st 和 队列 qu 的 元 素 类 型 均为ElemType)。

bool fun(SqQueue * &aqu,int iD)

{

ElemType ei int j一1;

int n 一 (qu 一> rear一qu 一 > front十MaxSize) 中 MaxSize;

证 (Gj<1 | j>n) return false;

for (j王1;j<

一 njj十十)

{

deQueue(Cqu,e);

让 0j!一iD

116

PASS和栈和队列 |

enQueue(qu,e) ;

}

Teturn true;

)}

7. 什么是环形队列? 采用 什么 方法 实现 环形 队列 ?

8. 环形 队列 一 定 优 于 非 环形队列吗? 在什么 情况 下 使用非环形 队列 ?

9. 假设 以I和 O 分 别 表示 进栈和 出 栈操作 , 栈 的 初态和 终 栈 均 为 空 , 进栈和 出 栈 的 操

作 序 列 可 表示 为 仅由I 和 O 组 成 的 序列。

(1) 在 下 面 所 示 的 序列 中 哪些是合法的?

A. IOIIOIOO

,B. IOOIOIO

C. IIOIOIO

,D. IIOOIOO

(2) 通过 对 (1) 的 分 析 , 设计 一 个 算法 判定所 给 的 操作 序列 是 否 合法 , 若合法 返回 真,否

则 返回 假(假设 被判定的 操作 序列 已存人 一 维 数组 中 ) 。

10. 假设表达 式 中 允许 包含圆括号 \ 方 括号和大 括号 3 种 括号 ,编写一个 算法 判断 表达

式 中 的 括号 是 否 正确配对 。

11. 设 从 键盘 输入一 序列 的 字符 al ,az ,...,av。 设 计 一 个 算法 实现 这 样 的 功能 : 若 w

为 数字 字符,ai 进队; 若 ai 为小写字 母,将 队 首 元 素 出队; 车 ai; 为 其他 字符 ,表示输入结

东。要 求 使用环形队列 。

12. 设计 一 个 算法 ,将 一 个 环形 队列 (容量为”元 素 下标 从 0 到 "一 1) 的 元 素 倒置 。例

如 ,图 3.27(a)

中 为倒置 前的队列 (z 王10), 图 3. 27(b) 中 为倒置 后的队列 。

Tear

(a)

front

@)

图 3. 27 ”一 个 环形 队列 倒置 前 后 的状态

13. 编写 一 个 程序 ,输入 z( 由 用 户 输入) 个 10 以 内 的 数 ,每输入zi0 入 i 过 9) 就 把 它插入

到第 ;号队列中,最后把 10 个队中 的非空队列 按 队 列号从小 到 大 的 顺序 串 接 成一条 链 ,并
输出 该 链 的所有 元 素 。

ee

实验题1: 实现 顺序 栈 的 各种 基本 运算 的 算法

目的: 领会顺序 栈 存储 结构和 掌握 顺序栈中 的 各 种 基本 运算 算法 设计 。

117

数据 结构教程

[第! 5版

内 容 : 编写一个程序 sqstack. cpp, 实 现 顺序 栈 (假设栈中 元 素 类型ElemType 为 char)

的 各 种基本运算 ,并 在 此 基础上设计 一 个 程序exp3-1. cpp 完成以下功能。

(1) 初始化栈。

(2) 判断栈 * 是 否非空 。

(3) 依次进栈元素ab、c、d、e。

(4) 判断栈* 是 否 非 空 。

(5) 输出出栈序列。

(6) 判断栈 * 是 否非空 。

(7) 释放栈。

实验题2: 实现 链 栈的各 种 基本 运算 的 算法

目的: 领会链栈 存 储 结构和 掌握链 栈 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序 listack. cpp ,实现 链 栈 (假设栈中 元 素 类型ElemType 为 char)的

各 种 基本 运算 ,并 在 此 基础上 设计 一 个 程序exp3-2. cpp 完成以下功能 。

(1) 初始 化栈s。

(2) 判断栈 * 是 否非空 。

(3) 依次进栈元素ab、c.d、e。

(4) 判断栈 * 是否非空 。

05) 输出出栈序列。

(6) 判断栈 * 是 否非空 。

(7) 释放栈。

实验题3: 实现 环形 队列的各种 基本 运算 的 算法

目的: 领会环形 队列 存储 结构和 掌握 环形 队列 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序 sqqueue. cpp, 实 现 环形 队列 (假设栈中 元素类型ElemType 为

char) 的 各 种基本运算,并 在 此 基础上 设计 一 个 程序exp3-3. cpp完成以下功能。

(1) 初始化队列 v。

(2) 判断队列 g 是否非空。

(3) 依次进队元素a\b、c。

(4)

出 队 一 个 元素, 输 出 该元素 。

(5) 依次进队元素 de \f。

(6) 输出出队序列。

(7) 释放 队列 。

peee

实验题4: 实现 链 队 的 各 种 基本 运算 的 算法

目的: 领会链队 存储 结构和 掌握链队 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序 liqueue. cpp, 实 现 链 队 (假设 栈 中 元 素 类型ElemType 为 char)的

各 种 基本 运算 ,并 在 此 基础上 设计 一 个 程序exp3-4. cpp 完成以下功能 。

(1) 初始化链队 5。

(2) 判断 链 队 g 是 否非空。

(3) 依次进链队元素 a\b、c。

118

PASS 和栈和队列 |

(4)

出 队 一 个 元 素 ,输出 该元素 。

(5) 依次进链队元素de、f。

(6) 输出出队序列。

(7) 释放链队 。

人设计性实验

实验题$: 用 栈 求解迷宫问题 的所有 路 径 及 最短路 径程序

目的: 掌握栈 在 求解迷宫问题中的 应 用 。

内 容: 编写一个程序exp3-5. cpp ,改进 3.1.4 节 的 求解迷宫问题 程序,要 求输出图3. 28

所 示 的 迷宫 的所有 路 径 ,并 求第一 条 最 短路 径 长度及 最 短路 径 。

0

1

2

3

4

5

实验题 6: 编写病人 看 病模拟 程序

目的: 掌握队列 应用的 算法 设计 。

一

内容: 编写一个程序exp3-6. cpp, 反 映病人 到 医院

排队看医生的情况。在病人 排队 过程中 主要 重复 下 面

二

|, 两 件 事 。

(1) 病人 到 达 诊 室 ,将 病历 本 交 给 护士, 排 到 等 竺

队列中候诊。

(2) 护士 从 等待队列 中 取出 下 一 位病人 的 病历 ,该

图 3.28 迷宫 示意 图

病人进入诊室就诊。

要 求 模拟病人 等 待 就诊这 一 过 程 。程序采用 菜单 方式,其 选项及 功能 说 明 如 下 ,

: 排队 一 一输入 排队 病人 的 病历 号 ,加 入 到 病人 排队 队列 中 ,

: 就诊一“病人 排队 队列 中 最 前 面 的病人 就 诊,并 将 其 从 队列 中 删除;

: 查看排队 一一从 队 首 到 队 尾 列 出所有 的 排队病人 的 病历号;

: 不 再排队,余下依次就诊一从 队 首 到 队 尾列 出所有 的排队 病人 的 病历 号 ,并 退出 运行 。

: 下班一退出运行。

人口

0

1

2

3

4

5

an上oo

实验题7: 求解栈元 素 排序问题

目的, 掌握 本 应 用 的 算法 设计 。

内 容 : 编写一个 程序 exp3-7. cbp, 按 升序对-个 |, ,,,,,,,

字符 栈 进行排序, 即 最小 元 素位于 栈 顶 ,最多 只 能使 ,

莹

用 一 个 额外 的 本 存放 临时 数据 ,并 输出 栈排序 过 程 。 ,

驶 综合 性 实验

3

杰

用 术 求解"皇后问题

实验题8:
目的。 深入 掌握楼 应 用 的 算法 设计 。
内容: 编写一个程序exp3-8. cpp 求解 双 皇 后问
题 ,即 在 六 7 的 方 格棋盘 上 放置 个 皇后,要 求 每 罗

4
:区

洽

杰

个 皇后 不 同行\不 同列 、 不同左右对 有角 线 , 图 3. 29 是
八 皇 后 问题 的 一 个 解 。(1) 皇 后 个 数 冯 由 用 户 输入,
其 值 不能超过 20 ,输出所有 的 解(2) 采 用 类 似 于 用 杰 本
求解迷宫问题 的 方法。

图3. 29 作 皇 后 问题

举

119

,

,

3

4

“

本

数据 结构教程

[第! 5 【版

实验题9: 编写停车场管理 程序

目的: 深入 掌握栈和 队列 应 用 的 算法 设计 。

内容: 编写 满足以下要 求 的 停车场管理 程序exp3-9. cpp。 设 停车 场 内只有 一 个 可 停放

寻 辆 汽车 的 狭长 通道,且只有 一 个 大门 可 供 汽车 进出 。

汽车 在 停车场内 按 车 辆 到 达 时间 的先

后 顺序 依次 由 南 向 北 排列 (大门 在 最 北端 ,最先到

达 的 第 一 辆 车停放 在 停车场 的最南端) , 若

停车场内已 停满, 辆 车 , 则 后 来 的 汽车 只 能 在门

外 的 便道 (即 候车 场上) 等 候 , 一 旦有车 开 天

E , 则 排 在 便道上的 第一辆 车即 可开和人;, 当 停车 场

内 某 辆 车 要 离开时 ,在 它 之 后 进入的 车 辆

必须 先退出 停车场 为 它让 路 , 待该辆车开 出 大 门

外 ,其 他 车 辆 再 按 原 次 序 进入停车场,每 辆

停放 在 停车场 的 车 在 它 离开停 车场时 必须 按 停留

的 时 间 长短交 纳 费 用。整 个停车场的示意

图 如 图 3. 30 所示 。

出

进
7

上|

ee 9

二

候车场

图 3. 30

停车场示意图

120

字符串 简称 为串,

串 是 由 字符 元 素构成的, 其中元 素 的 远辑 关

系 也 是 一 种 线性 关系。 串 的 处理 在计算机 非 数 值 处 理中 占有 重要

的地 位 , 如 信息 检索 系统 ,文字 编辑 等都 是 以串 数据作为 处 理 对 象 。

本 章 介 绍 串 的 基本 概念、串的 存储 结构、 串 的 基本 运算 和模式

匹配 算法设计 。

数据结构教程 SEASARR

串 的基本 概念

洒

(string) 是 由零 个或 多 个 字符组 成 的 有限 序列。含零个字符 的 串 称为 空 串 , 用 所 表
出

示。串 中 所 含 字 符 的个数 称为 该 串 的 长度(或 串 长 )。通 常 将一个 串 表 示 成 "aa ...a "的 形

式 ,其 中 最 外 边的双 引 号 (或 单 引 号 ) 不 是 串的内容 , 它们 是 串 的标志 ,用 于 将 串 与标识 符 ( 如

变量名等)加以区别。每个 wuiG 近 i 过 办 代 表 一 个 字符 ,不 同的机器和 编程 语言对合法字符

〈 即 允许 使用 的 字符)有 不 同 的 规定。但 在一般 情况下 ,英文 字母.数字 (0,1,...',9)和常用的

标点 符号以 及空格 符 等 都是合法 的 字符 。

两 个串相等当上且 仅 当 这 两个串 的 长度相 等并且 各 对 应 位置上 的 字符 都

扫-- 要

相同。一 个 串 中任意 个连续 字符组 成 的 序列 称 为 该 串 的 子串(substring) ,

|

例如 串"abcde" 的 子囊有"a"、"ab" abc" 和 "abcd" 等 。 为了表述清楚 ,在串

中 空格字符 用 * 呈 符 号 表示 ,例如"ab" 是 一 个 长 度为4 的 串 ,其 中 含有两

个空格 字符。空串是 不 包含 任何 字符 的 串,其 长 度为 0, 空串是任何串的

子串。

串的抽象数据 类 型描述如 下 :

ADT String
{ 数据 对 象 :

={ ai| 1和受i 乏 z 全0,ai 为 char 类型}

数据 关系 :

及 一人 <aaiH> | asarED,i一1 ,7一1)

基本 运算 :

StrAssign(&s,cstr): 将字符串常量 cstr 赋 给 串 s, 即生成其值等于 cstr 的串 s。
DestroyStr(&&s): 销毁串 ,释放 为串* 分 配 的存储空间 。
StrCopy(C&s,D: 串 复制,将 串 上 赋 给 串 s。
StrEqual(s,D: 判断 串 是 否 相等 , 若 两 个串 * 与上相等则返回真; 否则 返回 假 。
StrLength(s): 求 串 长,返回串 * 中字符的个数。
Concat(s,D: 串 连接,返回由两个串s 和 上 连接 在 一 起 形成 的新串 。
Substr(s,z7): 求 子串, 返 回串 * 中从第 i0 和未 思 个 字符 开始的由 连续 字

个字符组成的子串。

JInsStr(sl,i,s2): 子 串插入 ,将串 2 插 和人到串 sl 的第 ;1 近 i 生 2 十1) 个 位 置 ,

并返回产生的新串。

DelStrGs,交力: 子 串 删除,从 串 * 中 删去从 第 i 肥还 站 个 字符 开始 的长度为7 的

子 串 , 并 返回产生 的 新 串 。

RepStrCsiDD: 子 串 蔡 换 ,在串 * 中 将 第 ;i(1 近过 罗 个 字符 开始 的 7 个 字符 构

成的子串用串 上 替换 ,并 返回 产生 的 新 串 。

DispStr(s): 串 输 出 ,输出串 * 的所有字符值。

串 的 存储 结构

漆

和线性表 一 样,串也有 顺序 存储结构和链式存储结构。前 者 简称 为 顺序 串 , 后 者 简称 为

链串。

122

亿 O人AR

421 串 的顺序 存储 结构

顺序 串

顺序 串 中 的 字符 被依次 存放 在 一 组 连续 的 存储 单元 里。一 般 来说 ,一个字节 (8 位)可

以 表示 一 个 字符 (存放其ASCII码) 。而 计算 机 内 存是按 字 编 址 的 ,即以 字 为存储 单位 ,一

个 存储 单元指 的 是 一个字。而 一 个 字 可 能 包含 多 个 字 节,其所包含的字节 数随机器而异。

顺序 串 的 存储 方式 有 两种: 一种是 每个字 只 存 一个字符 ,如 图 4.1 所示(假设 一个字 包

含 4 个字节) ,这 称 为 非 紧 缩格式 (其 存储 密度 小); 另 一 种 是 每个字 存 放 多 个 字符 ,如 图 4.2

所 示 ,这 称 为紧缩 格式(其 存储 密度 大) 。 在 这 两 个图中 ,有 阴影的字 节 为 空闲部 分 。

1001 | 4

1002 | 了3

1003 | C

1004 | 万

1005 | 已

1006 | 严

1007 | G

100g |[丈

1009|

7

100a | /7

扫 --扫

100114

138|clPp

1002| 瑟 |下 | Gc| 喜

1003|

7 | >/

图 4.1

非 紧缩格式 示例

图 4.2 紧缩格式 示例

串 的 紧缩格式 节省 存储 空间 ,但处理 单个 字符 不 太 方 便 ,运算 效率 低 ,因为需要 花费 时

间 从同一个字中 分离字 符 ; 相反 ,非 紧缩 格式比较 浪费 存储空间 ,但处理 单个 字符 或 者一组

连续 字符 方便。后 面主要讨论后者。

对 于 非 紧缩格 式 的 顺序 串 , 其 类 型 声明如 下 :

typedef struct

{

char data[MaxSize] ;

int length;

} SqString;

// 存 放 串 字 符

// 存 放 串 长
// 顺 序 串 类 型

下 面 讨论 在顺序串上 实现 串 基本 运算 的 算法 ,其中 顺序 串 参 数 采 用 直接传递 顺序 串 的

方法 ,不同于 第 2 章 的 顺序 表 算 法 采用 的 是 顺序 表 指 针 。

1) 生成串 StrAssign(&s ,cstr)

将 一个CVC++字符串常量cstr( 以\0 ' 字 符标识 结尾 ) 赋 给 顺序 串 *, 即生成一个其值等

于 cstr 的串*。 算 法如下 :

void StrAssign(SqString &s,char cstr[])

//s 为 引用 型 参数

{

intis
for (ji一0;cstr品! 一\0'i十十)

s.data[j] 一 cstr[D ;

s.length 一 i;

// 设 置 串 s 的 长 度

123

数据 结构教程

[第! 5版

2) 销毁串 DestroyStr(&s)

由 于 本 章 的 顺序 串 是 直接 采用 顺序 串 本 身来表示 的 ,而不是 顺序 串指针 , 它的存储空间
在 超出 作用 域时 释放 其 存储 空间 ,所 以

由 操作 系统 管理, 即 由 操作 系统 分配其 存储 空间 ,并

这是

的 销毁 顺序 串 运 算 不 包含 任何 操作。算 法如 下 :

void DestroyStr(SqString &s)

{

3) 串 的 复制 StrCopy(&s,t)

将 顺序串 :复制给顺序 串 *。 算法如下:

void StrCopy(SqString &s,SqString t)

//s 为 引用 型 参数

{人 inti

for (i=0;i<t.length;i十十)

// 复 制+的所有字符

s.data[让一 t.data[ ;

s.length 一 t.length;

)》

// 设 置串 s 的 长 度

4) 判断串相等StrEqual(s,t)

若两个顺序串* 与上 相等返回 真; 否则 返回 假 。算法如下 :

bool StrEqual(SqString s,SqString t)

{

bool same一truei int ii;

计 (s.length!王 t.length)

// 长 度不相等时返回 0

same一false;

else

for (i王0;i<s.length;i十十)

寺 (s.data[i]! 一 tdata[]) 。 // 有 一 个 对 应 字符 不相同 时 返回 假
{ same一false;

break;

】}

Teturn Same;

)》

5) 求串长 StrLength(s)

返回 顺序 串 * 中字符的个数。算法如下 :

int StrLength(SqString s)

{

)》

return s.length;

6) 串 的 连接 Concat(s,t)

返回 由 两个顺序串* 和:上 连接 在 一 起 形成 的结果 串。算 法如 下 :

SqString Concat(SqString s,SqString t)

{

, SqString str;

// 定 义结果串

124

个OA

int i;

str.length一s.length十t.length;

for (i王0;i<s.length;i十十)

//将 s.data[0..s.length一二复制到 str

str.data[ 品一s.data[ ;

for (i一0;i<t.length;i十十)

//将tdata[0..t.length 一二 复制到 str

str. data[s.length 十 口 一 t.data[癌 ;

Teturn StT;

7) 求 子串SubStr(s,六旋

返回 顺序串 *

中从第;1 近 ; 肥 四 个 字符 开始的由 连续 7 个字符组成的子串。当 参数 不

正确时返回一个空串。算法如下 :

SqString SubStr(SqString s,int i,int j)

{

intk;

SqString str;

str.length一0;

// 定 义结果串
// 设 置 str 为空串

i计 (Ci<一0 |‖ i>s.length | j<0 |

i 十 j 一1>s.length)

Teturn StT;

for (k 一 i 一1;k<i 十 j 一1;k十十)

str. data[k 一 i 十] 一 s.data[k] ;

// 参 数不正确 时 返回空串
//将s.data[i..i

二j一巧复制 到 str

str.length一j;

Teturn StT;

8) 子 串 的 插入 InsStr(s1,.1,s2)

将 顺序 串 2 插入到顺序串 sl 的第 ;iG 近 ;和受2十1) 个 位 置上 ,并 返回 产生 的 结果 串。当

参数 不 正确时 返回 一 个 空 串。算法如下

SqString InsStr(SqString sl,int i,SqString s2)

{

intj;

SqString str;

str.length一0;

// 定 义结果串
// 设 置 str 为空串

这 (i<=0 | i>sl.length十1)

// 参 数不正确 时 返回空串

ITeturn StT;

一1;j十十)
for (Gj=0;j<i

//将sl.data[0..i

一人复制到 str

str.data[

让一s1.data[j] ;

for (j 王0;j<s2.length;j十十)

//将 s2.data[0..s2.length 一 二 复制 到 str

str. data[i十j 一 避 一 s2.dataD] ;

for (j一i一 1;j<sl.length;j十十)

//将sl.data[i 一 1..sl.length一器复制 到 str

aa

str.data[s2.length 十 门一s1.dataDj] ;

str.length一s1.length 十s2.length;

Teturn StT;

9) 子 串 的 删除 DelStr(s ,), 尹

在 顺序 串 * 中 删去从 第 ;1 所 ;和 2 个 字符 开始 的 长 度为7 的 子串, 并 返回产生 的 结果

数据 结构 教程

[第! 5人版

串。当 参数不正确时 返回一个 空 串。算 法如 下 :

SqString DelStr(SqString s,int i,int j)

{

intk;

SqString str;
str.length 一 0;

// 定 义结果串
// 设 置 str 为空串

让 (Ci<一0 |‖ i>s.length |

i 十 j>s.length十1)

return str;

// 参 数 不 正确 时 返回空串

for (k一0;k<i 一1;k十十)

//将s.data[0..i一]复 制 到 str

str. data[k] 一 s.data[k] ;

for (k 一 证 j 一 1;k< s.length;k十十) //将 s.data[i十j 一 1..s.length 一菇 复制到 str

str. data[k 一 门一s.data[k] ;

str.length一s.length一j;

Teturn StT;

10) 子 串 的 替换 RepStr(s,六六t)

在 顺序 串 * 中 将第;1 近 i 运 四 个 字符 开始 的 连续 7 个 字符 构成 的 子串用 顺序 串 : 蔡换,

并 返回 产生 的结果 串。当 参数 不 正确时 返回 一 个 空 串。算法如下 :

SqString RepStr(SqString s, int i, int j,SqString t)

{

intk;

SqString str;

str.length 一 0;

// 定 义结果串

/设置 str 为空串

让 (Ci<一0 |‖ i>s.length |

i 十 j 一1>s.length)

Teturn str;

// 参 数 不 正确 时 返回空串

for (k一0;k<i 一1;k十十)

//将s.data[0..i一人复制到 str

str. data[k] 一 s.data[k] ;

for (k一0;k<t.length;k十十)

//将 t.data[L0..t.length一二复制到 str

str. data[i十k 一 二 =一t.data[k] ;

for (kk一ij 一 1;k<s.length;k十十) //将s.data[Li十j 一 1..s.length 一切复 制 到 str

str. data[t.length十k一 门一s.data[k] ;

str.length一s.length一j十 t.length;

ITeturn StT;

11) 输出串 DispStr(s)

输出 顺序 串 * 的所有 元 素 值 。算法如下 :

ee

void DispStr(SqString s)

{

inti

计 (s.length>0)

(人

GEOsissiendihoidHH)

printf("%c",s.data[i]);

printf(C"\n");

126

【例4.1]】 假设串采 用顺序 串 存储, 设计 一 个 算法 Stremp(s,按字典顺序比较两个串

个OA

sx和:z 的 大小 。

本 例 的 算法 思路 如 下 。

(1) 比较s 和: 两 个串共 同 长 度 范围内的 对 应 字符

@ 若* 的字符大于: 的 字符 ,返回 1;

@ 若* 的字符小于: 的 字符 ,返回一1,

@@ 若 * 的字符等于: 的 字符 ,按上 述 规则 继续 比较 。

(2) 当 (1) 中 的 对 应 字符 均 相 同时 比较 和 : 的 长度:

g@ 两者相等时返回0,

@*的长度大于上 的 长 度 ,返回 1;

@ xs的长度小于z 的长度,返回一1。

对 应 的算法如下 :

int Strcmp(SqString s,SqString tb

{

int icomlen;

这 (s.length<t.length) comlen一 s.length;

// 求s和 t 的 共同 长 度

else comlen一t.length;

for (i一0;i< comlen;i十十)

// 在 共同 长度内 逐个 字符 比较

十 (s.data[口> t.data[j)

return 1;

else if (s.data[ij<t.data[癌)

return 一 1;

一一t.length)
计 (s.length

/Vs一一t

Teturn 0;

else 过 (s.length>t.length)

return 1;

else return 一 1;

)}

//s>t

/Vs<t

【例4.2〗 假设串采 用 顺序 串 存储 ,设计 一 个 算法 求串 * 中 出 现 的 第 一 个 最 长的连续

相同 字符 构成 的平台 。

用 index保存最长的平台在* 中 的开始位 置,maxlen 保存 其 长 度,先 将 它们 初始化

为 0。 扫 描 串 ,计算 局 部 重复 子 串 的 长度 length,若比 maxlen 大 , 则 更新maxlen,并用

十maxlen一1]为第一个最长的平
index 记 下 其开始位置。扫 描 结 束后,*. data[Lindex..index

台。对 应 的算法如下 :

void LongestString(SqString s,int &index,int 路 maxlen)

{

一1,start;
int length,i

//length 保存 局 部平台 的 长 度

index一 0,maxlen一1;

/Vindex保存最长平台在 s 中 的开始位 置 ,maxlen 保存其长度

whbile (i< s.length)

{

start 一 i 一 1;

// 查 找 局 部 重复 子 串

length王1;

while (i< s.length && s.data[] 一一s.data[i一]])

{

i十十 ;

127

数据 结构教程

[第! 5 【版

length 十十 ;

】》
迁 (maxlen< length)

{

maxlen一length;

index一start;

】》
i十十;

// 当 前 平台 长度大 , 则 更新maxlen

422 串 的 链 式存储结构一一链串

串 采用 链 式 存储 结构 存储时 称 为 链串 ,这 里 采用 带头结 点 的 单链表作

为链 串。链 串 的组 织 形 式 与一般 的 单链表 类似 , 主 要 区 别在于 链 串 中 的 一

个 结 点 可以 存储 多 个 字符。通 常 将 链 串 中 每个结 点 所 存储 的 字符 个 数 称 为

视频 讲解

结点大小。图 4.

3 和图 4. 4 分 别 表 示 同 一 个 串"ABCDEFGHIJKLMN

"的结点大小为4(存

储 密度 大)和 1( 存 储 密度小)时 的 链 串结构 。

和

和| AIBICID

”|E|F|GIH

一 | 工本 区 [|

二 一定MIN|#|#|人

图 4.3 结点大小 为4的 链 串

呈| A

二 B

一

一 M

二 | 和

图 4.4 结点大小为 1 的 链 串

当 结 点 大 小 大 于 1( 例如 结 点 大小为 4) 时 ,链串的 尾结 点 的 各 个 数据 域 不一定 总能全 被

字符 占 满,此 时 应在这 些 未 占用 的 数据 域 里 补 上 不属于 字符 集 的特殊 符号 (例如 '# '字符),

以示区 别 ( 参 见图 4. 3 中 的 尾 结 点 ) 。

在 链 串 中 ,结 点 大小 越 大 ,存储 密度 越大,但 一些基 本 操作 (如 插入 、 删除、 替 换 等)有 所

不便, 且 可 能 引起 大 量 字 符 移动,因此 它 适 合 于 串很少修改 的情况; 结 点 大小 越小 (如 结点

大小 为 1 时 ) ,相关 操作 的实现 越方便 ,但 存储 密度 下 降。为 简便 起见, 这里 规定 链 串结 点 大

小 均为1。

链串的结点类 型 LinkStrNode 的声明 如 下 :

typedef struct snode

{

char datai;

Struct snode xx nexti

}》 LinkStrNode;

//存放字符
// 指 向 下 一 个 结 点 的 指针
// 链 串的结 点 类 型

下 面讨 论 在链串上 实现 串 基本 运算 的 算法 设计 。

1) 生成串 StrAssignC&s ,cstr)

将 一个C/C++字符串常量 cstr( 以\0 '标识结尾) 赋 给链串*, 即 生成一个 其 值 等于 cstr

128

个 O人AR

的 链 串 *。 以 下 算法 采用 尾 插 法 建立链 串 *。

void StrAssign(LinkStrNode * &s,char cstr[])

{

intii

LinkStrNode *T, <p;

s 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;
IT 一 S;

//r 始 终 指向尾结 点

for (ji一0;cstr品! 一\0'i十十)

{ ,p= 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

p 一> data一cstr[D癌 ;

TI一 > next一p; I一pi;

}

T一> next一NULL; //尾结点的 next域置为空

2) 销毁串DestroyStrC&s)

该 运算和 销毁 带头 结 点 单链表 运 算 的 实现 过 程 相 同。算法如下:

void DestroyStr(LinkStrNode * &s)

{

LinkStrNode * pre一s,* p 一 s 一> next;

//pre 指向 结 点 p 的 前驱结 点

while (p!=NULIL)

// 扫 描 链 串 s

freeCpre);
pre 一 Di;

p 王 pre 一> next;

{

}

// 释 放 pre 结点
//pre、p同步后移一个结点

free(pre) ;

// 循 环 结束时p 为 NULL,pre 指向 尾 结点,释放它

3) 串 的 复制 StrCopy(&s,t)

将 链 串 上 复制给链 串 *。 以 下 算法 采用 尾 搬 法 建立复制 后的链 串 >。

void StrCopy(LinkStrNode * &s,LinkStrNode * t)

{

LinkStrNode * p 一 t 一> next, 关 q,,关 I;

s 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;
IT 一 Si

//r 始 终 指 向尾结 点

while (p!I=NULL)

//扫描链 串的所有结点

,q=(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;
q 一 data 一p -> datai
IT人> next一q; I 一 q;
p 一 p 一 nexti

// 将 p 结 点 复制到 q 结 点
//将 q 结 点链接到链串 s 的 末尾

{1

}

IT一> next一NULL;

//尾结点的 next 域 置为空

Rs

4) 判断串相等 StrEqual(s,t)

若两个链串 * 与上的 长度相 等是对 应 位 置的字符 均 相 同 , 则 返回 真; 否则 返回 假 。算法

如下:

129

bool StrEqual(LinkStrNode * s,LinkStrNode * t)

{

LinkStrNode * p一s一 next, x* q一t-> next;

//p、q 分 别扫描链串 s

和 t 的 数据 结 点

while (p!王NULL &玉 q!王NULL && p 一 data一一q一> data)

{《

p 王 p 一 next;

q一q 一nexti;

}
if (p==NULL && q==NULIL)

ITeturn true;

else

return false;

)}

5)

求 串长StrLength(s)

//s和上t 的 长度相等且对 应 位 置的字符 均 相同

通过 遍历 链 串 * 的所有 数据结 点 求 其个数 并

返回。算 法如 下 :

int StrLength(LinkStrNode * s)

一 0;

inti
LinkStrNode * p一s -> next;

//i 用 于 累计 数据 结 点 的个数

, //p 指向 链 串 s 的 首 结 点

while (p!王NULL)

// 扫 描所有 数据 结 点

ii十十;

p一p 一> next;

{

}》

Teturn ii

{

)}

6) 串的连接 Concat(s ,t)

由 两个链串* 和 : 的 数据结 点 连接 在 一 起 形成结果 串

。以 下 算法 采用 尾 插 法 建立 连接

后 的结果链串 str 并返回它。

LinkStrNode * Concat(LinkStrNode * s,LinkStrNode * t)

{

LinkStrNode * str, * p 一 S 一> next, 关 q, 关 Ti

str 一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;
TI 一 str;

while (p!=NULIL)

//r 指 向结果 串 的 尾 结 点
//用p 扫描 s 的所有数据结点

,q= 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;
q -> data 一p 一 > datai
T 一> next一qi;I一qi;

//将p 结 点 复制到q结点中
//将q 结 点链接到 str 的 末尾

p 王 p 一> next;

{1

}

aa

pP 王 t 一> next;
while (p!I=NULL)

//用p 扫描 t 的所有数据结点

{1

, q= 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q -> data 一bp -> datai
IT next一qir一qi

p一p 一> next;

}》

IT-> next一NULL;

ITetuIn StT;

//将p 结 点 复制到 q结点中
//将 q 结点链接到 str 的 末尾

//尾结点的 next 域 置为空

130

亿 O人AR

7) 求 子串SubStr(s,六放

返回 链 串 *

中 从 第 ;所 i 委 思 个 字符 开始 的 由 连续 7 个字符组成的子串。当 参数不正

确 时返回一个空 串

。以下采用尾插法 建立结果链 串 str 并返回它。

LinkStrNode * SubStr(LinkStrNode * s,int i,int j)

{

intk;

LinkStrNode * str, #* p 一S一> next, 关 q, 关 I;

str 一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

str -> next一NULL;
IT 一 str;
计 (i<=0 |‖ i> StrLength(s) | j<0 | ij一 1> StrLength(s))

//置结果串 str 为空串
//r 指 向 结果 串 的 尾 结点

return str;

// 参 数不正确 时 返回空串

for (k 一 1;k<iik十十)

// 让 p 指 向 链 串 s 的 第 i 个 数据 结 点

p王p 一>next;

for (k一1;k < 一j;k十十)

//将s 的从第 i 个 结 点开始的j 个 结 点 复制到 str

,q= 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q 一> data一p 一 > data;

TI一>next一qi;T一q;

p王p 一>next;

{1

}

IT一> next一NULL;

Teturn StT;

//尾结点的 next域置为空

8) 子 串 的 插入 InsStr(s1,1,s2)

将 链 串 s2 插入到链串 1 的第 ;所 i 委 xz十1) 个 位 置 上 ,得 到 一 个结果 串。当 参数不正

确 时返回一个空 串

。以下采用尾插法 建立结果链 串 str 并返回它。

LinkStrNode * InsStr(LinkStrNode * s,int i,LinkStrNode * t)

{

intk;

LinkStrNode #* str, * p 一 S

一 > next, # D1一t 一 > next, 关 q, 关 IT;

str 一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

str -> next一NULL;
IT 一 str;

这 (i<=0 |‖ i> StrLength(s)十1)

Teturn StT;

// 置 结果 串 str 为空串
//r 指 向 结果 串的尾 结点
// 参 数 不 正确 时 返回空串

for (k=1;k<iik 十十)

//将s 的前i 个 结 点 复制到 str

,q=(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q 一> data一p -> data;

IT一 > neXxt一qiT一qj;

p王p 一>next;

{1

}

while (pl!=NULL)

//将t的所有结点复制 到 str

{1

,q= 一(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q 一> data一pl 一> data;

TI一>next一qiTr一q;

pl1 王 pl 一> next;

131

数据 结构教程

[第1 5 【版

while (p!=NULIL)

//将p 结 点 及 其后的 结 点

复制到 str

{

,q=(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q 一 data一p -> data;

TI一>next一qi;Tr一q;

p王p 一>next;

}

Tr一 next一NULL;

Teturn StT;

//尾结点的next域置为空

9) 子 串 的 删除 DelStrCs,)刀

在 链 串 * 中 删去从 第 ;所 ;和 四 个 字符 开始 的 长 度为7 的 子串,得 到 一 个结果 串。当

参数 不 正确时 返回 一 个 空 串

。以 下 采用 尾 插 法 建立结果 链 串 str 并返回它。

LinkStrNode * DelStr(LinkStrNode * s,int i,int j)

{

intk;

LinkStrNode * str, * p一S 一> next, 关 q, 关 Ti;

str 一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

str 一 next二NULL;
// 置 结果 串 str 为空串
/人 指向 结果 串的尾 结点
IT 一 str;
迁 (i<=0 |‖ i> StrLength(s) | j<0 | ij一 1> StrLength(s))

Teturn stri

// 参 数 不 正确 时 返回空串

for (k 一 1;k<iik十十)

//将s的前ii 一 1 个 结 点 复制到 str

{ , q=(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

qd 一> data一p -> data;

TI一 > next一qi;T一q;

p一p 一> next;

}

for (k=0;k<j;k十十)

//让p 沿 next跳j 个结点

p王p 一> next;

while (p!王NULL)

//将p 结 点 及 其 后的结 点 复制 到 str

{ , q=(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

q 一 data一p 一 > data;

IT 一 next一qir一qi

p王p 一> next;

)}

IT 一 next一NULL;

Teturn str;

)}

//尾结点的 next域置为空

ee

10) 子 串 的 替换 RepStr(Cs,六六t)

在 链 串 * 中 将 从 第 ;1 近 i 受 四 个 字符 开始 的 7 个 字符 构成 的 子 串 用 链 串 上 蔡换。当参

数 不 正 确时 返回 一 个 空 串

。以 下采用尾插法 建立 链 串 str 并返回其地址。算法如下:

LinkStrNode * RepStr(LinkStrNode * s,int i,int j,LinkStrNode * t)

{

intk;

LinkStrNode #* str, * p 一 S 一 > next, # D1一{t 一 > next, 关 q, 关 Ti;

str 一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

132

亿 O人AR

str -> next一NULL;

// 设 置结果串 str 为空串

IT一StT;

//r 指 向 新建链 表 的 尾 结 点

计 (Ci<一0 |‖ i> StrLength(s) | j<0 |

i 十 j 一1> StrLength(s))

Teturn StT;

// 参 数不正确时 返回空串

for (k 王 0;k<i一1;k十十) //将s的前i 一 1 个 数据 结 点 复制 到 str

{

, q=(LinkStrNode * )malloc(sizeof(LinkStrNode)) ;

q 一> data一p -> data;q 一> next一NULL;

T 一>next一qi;T一q;

p一p 一>next;

}》

for (k一0;k<j;k十十)

// 让 p 沿 next 跳 j 个 结 点

p王p 一> next;

while (pl!=NULL)

//将t 的所有 数据 结 点 复制 到 str

{

, q=(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

qd 一 data一pl 一 data;iq 一 next 一NULL;

T 一 next一qir一qi;

pl1

一pl 一>next;

}

while (

p!=NULL)

//将p 所 指 结 点 及 其 后的结 点 复制 到 str

{

, q=(LinkStrNode * )malloc(Csizeof(LinkStrNode) ) ;

q 一 data一p -> dataiq 一 next一NULL;

TI一 > next一qi;T一q;

p 王 p 一> next;

}

IT 一> next一NULL;

//尾结点的next 域 置 为空

Teturn StT;

)》

11) 输出 中 有 DispStr(sS

)

输出串 * 的所有 元 素 值 。算法如下 :

void DispStr(LinkStrNode * s)

{

LinkStrNode * p 一 s 一> nexti;

while (p!I=NULL)

V//p 指向 链 串 s 的 首 结 点

// 扫 描 s 的所有数据结点

{

printf("%%c",p
一> data);

// 输出 p 结 点 值

p王p 一> next;

}
printfC"N\n") ;

)》

【例4.3】

假设串采月日 链 串 存 储 , 设 计 一 个 算法把串* 中 最 先 出 现 的 子 串"ab" 改 为

人

XVYZ 。

在串 s 中找到 最 先 出 现 的 子 串"ab", 即 户指向 data 域 值 为'a' 的结 点,其 后 继结 点 是

data 域 值 为 中 ' 的结点。将 它们 的 data 域 值 分别 改 为'x' 和 "'z"..., 再 创建 一个data 域 值 为 y' 的结

点 (由 9 指向 它) ,将 其 插入到 馆 所指 的结 点 之 后。算法如下:

aa

void Repl(LinkStrNode * &s)

{

LinkStrNode * p 一 s 一> next, x qi

133

数据 结构教程

[第! 5版

bool find一false;
while (p!I王NULL && p -> next!l王NULL && !find)

// 查 找 'ab'子串

{

这 (p 一 data 一一'a'&& pb 一 next 一 data 一 一'b)

// 找 到 了 这 样的子 串

{

, p 一> data一'x';i p 一> next 一> data一'Z';

// 蔡 换

q一(LinkStrNode * )malloc(sizeof(LinkStrNode) ) ;

qd 一 data一'y'; q 一 next一pD -> next; p 一> next一qi

find一true;

】}
else p 一 p 一> next;

// 尚 未 找到 时 继续 查找

串 的模式 匹配

洒

设有两个 串* 和 上 ,串 上 的定位就是要在串s 中找到一个与:相等的子串。通 常把 * 称

为 目标串(target string) ,把 : 称为 模式串(pattern string) ,因此 串 定位 查找 也 称为模式匹配

(Cpattern matching)。模 式匹配 成 功 是指 在 目标串* 中 找到 了 一 个 模式串:; 不 成 功 则 指 目

标串 * 中 不 存在 模式串:。

模式 匹配是 一 个 比较 复杂 的 串 操作 ,许多人 对 此 提出 了很 多 效率 各 不 相同 的 算法。在

此 介绍 两种算法 ,并 设 串 均 采用 顺序 存储 结构 。

431 BruteForce 算法

Brute-Force(

暴力)简称为BF算法,也称简 单 匹配算法 ,采用穷举方法,其 基本思路 是

从 目标串 一 "sos...s-i "的 第 一 个 字符 开始 和 模式 串 :一 "oo ...z-i "中 的 第 一 个 字符 比较,

若 相等 , 则 继续逐个比较 后 续 字 符 ; 否则从目标串* 的 第 二 个 字符 开始重新

要-要

与模式 串 : 的 第 一 个 字符 进行 比较。依 此 类 推,若 从 模式 串 * 的第; 个 字符

开始 ,每个字符 依次和 目标串: 中 的对 应 字符 相等 , 则 匹配 成功,该算法 返

回 位置 ;( 表 示 此 时 :的

第 一 个字符在* 中 出 现 的 下标 );, 和 否则 ,匹配失败 , 即

! 不是* 的 子 串 , 算 法 返回 一 1( 这 里为了 简便 , 均 使用 物理 下标 ) 。

例如设目标串 一"aaaaab" ,模式 串 :一"aaab",BF 模式 匹配的直观过

程如 图 4.5 所示。

saaaaab

1 aaab

从 s 的 第 1 个 字符 开始 匹配 咏 失败

aaab

从 * 的第2 个 字符 开始 匹配 号 失败

三:

a a ab 从 s 的第3 个 字符 开始 匹配 成功

图 4.5 BF模式匹配的直观过程

假设 目标 串 * 中 含有 7 个 字符 ,模式 串 上 中含有 m 个 字符 ,用 ;扫描 目标串* 的 字符 ,用

7 扫描 模式 串 : 的 字符:

(1) 第 2 从 1 开始)趟匹配是从* 中 的 字符 s-;: 与上中 的 第一个 字符 如 比较开始 的 。

134

四 O人AR

(2) 在 某一趟 匹配中出 现 *: 一恬 , 则 守7 后 移 继续 字符比较 ,即 执行 ;十 十,7 十十。

(3) 在 某一趟 匹配中 出 现 # 夫 廊 ( 称 为“失 配?) ,如 图 4.6 所 示 , 则 有 5 一 si 一

3, 即 总 一 -1的7个 字符 依次 与 目标 串 *

中 s; 之 前 的 7 个 字符 相同 。也 就 是

说 ,本 趟 匹配 是从目标 串 * 的-字符比较开始的,即为第 ;一?十 1 趟 匹配,由 于 匹配 失败 ,

下 一 趟 匹配 应 该 是第 ;一 ?十2 趟 匹配 ,即 从 目标串 * 中的si与m 比较 开始 。所以,无论

当前 是 第 几 趟 匹配 ,只 要 出 现 失 配 , 即 * 夫 六, 则 执行 ;一 ;一/十1( 表 示 开 始 下 一 趟 匹配,从 目

标串 * 中的s:开始比较,即守 回溯 ) ,7 一 0( 每 趟 匹配 都 是从w 开始的) 。

和有 轩

| |

本 是 匹配,从s 与n 比较 开
合,直 到s 与! 不相等为上

8 081.8SP SDH SP SSH1.Sor1

|

...

下 一 趟 匹配: 从 s与f

在 比较 开始

图 4.6

BF 模式 匹配的 一 般 性 过 程

(4) 在 匹配中一旦7 超 界 G 一 2) ,表示 模式 串 上 的所有 字符 与 目标 串 *

的 对 应字符均相

同,则:是s 的 子串, 即 模式匹配 成 功,并 且 上 在* 中 的 位 置是;一 mm。

(5) 如 果 按 上 述 过 程 匹配 ,出现; 超 界(i一2) ,表示模式 匹配失败 。

(6) BF算法过程是从 /=1 开始 的 , 若 模式匹配 成 功 则 返回 ,和 否则 :一2,...。 由 于 穷 举

了 所 有 的 情况 ,所 以 BF 算法是正确的。

对 于 前 例 ,目标串 :一"aaaaab" ,模式串 :一"aaab"。s 的 长度z 王 6, 的 长度思 一 4。i 7

分 别 扫描 目标 串* 和 模式 串 上 。BF模式匹配的过程如图 4.7 所 示 ,总共需要 12 次 字符 比较

(恰好 为 字符间 纵 向 连接 线条 数 ) 。

第 1 趟 匹配

:

让

b

1 aaab
全

广 3

六

六 翔1=1

六

第 2 趟 匹配
(OF 开始 | P 敌人为

4

大六片1=2

7

于
s:aaaaab

7

1 aaab
本
计

第3 趟

CO S “人 , 6 成功,返回 六 LIength-2

六

,

1 aaab

六4

全

图 4.7 BF模式匹配的过程

aa

对 应 的 BF 算法如下 :

int BF(CSqString s,SqString t)

{

inti

一 0,j一0;

while (i< s.length &&& j<t:length)

// 两个串 都 没有扫描 完 时 循环

数据 结构教程

[第! 5人版

让 Cs.data[丫一一t.data[门)

// 当 前 比较 的 两个字符 相同

{

ii 计 十 ;j 十十;

}

else

// 依 次 比较后续 的 两个字符
// 当 前 比较 的 两个字符 不相同

{ 过 这 ji十15j=一0; )}

// 扫 描 目 标 串 的 i 回 退 , 子串从 头 开始匹配

{

}

让 Gj>=t.length)

return(i 一 t.length);

else

return( 一 1);

)}

//j超界,表示 t 是 s 的 子 串
// 返回+ 在 s 中 的 位 置

// 模 式匹配失败

// 返 回一1

这 个 算法 简单且 易 于 理解 ,但 效率不高,主要 原因 是 主 串 指针 ;在 若干个字符 比较 相等

后 ,若有 一 个 字符 比较不相等 ,就 需 回溯(即 ;一 ;一 /十1)

。 该 算法 在 最 好 情况 下 的 时间 复 杂

度为 OC0z) , 即 主 串 的 前 靖 个 字符 正好 等于模式 串 的 mm 个 字符。在 最 坏 情况 下 的 时间 复 杂

度为0(2zXz)。可 以 证 明 其 平均时间 复 杂 度 也是 O(zXm) ,也 就是说 ,该 算法 的平均时 间

性 能 接近 最 坏 的 情况 。

432 KVP 算 法

KMP 算法是D. E. Knuth、J. H. Morris 和 V. R. Pratt 共同 提出 的,称 之为Knuth-

Morris-Pratt 算法 ,简称KMP 算法。该 算法与Brute-Force 算法 相 比有较 大 的 改进,主要是

消除 了 主 串指针 的 回溯 ,从 而 使算法 效率有了 某 种 程度的 提高 。

在 KMP 算法 中 ,通过 分 析 模 式串上 从 中 提取 出 加 速 匹配 的有用 信息。这 种信息是对

于 “的 每个字符 与(0 过) 过 一1) 存 在 一 个 整数&(R<7) ,使得模式 串上中 开头的& 个 字符

Coau-i)依次 与 广 的 前面& 个 字符 (et 5-1,,这里第一个字符-最多 从 羡 开

始,所以&<7力相同。 如 果 这 样 的上&有 多 个 , 取 其 中 最 大 的 一 个 。模 式 串 /

中 每 个位 置) 的 字符都有这 种 信息 ,采用 next 数组 表示 , 即 next[ 让 一

MAXI{A)}。

例如 模式 串 :一 "aaab" ,对于) 一3一'b', 有心 =0='a'( 即 的 前 面

有 一 个 字符 和 开头 的 一个字符 相同 ) ,4 一 1; 又有 20 三 0 一 "aa"(即总的
前 面有两个字符 和 开头 的 两个字符 相同),A=2; 所以,next[3]王

MAX{1,2}一2。

归纳起来,求模式串 上 的 next数组的公式如下 :

ee

一 1

next[ 门二 MAXIE 10<&R<j 上且"0a2 一 "OPaa...02"》

0

next 数组 的 求解过 程如 下 :

当 了 一 0 时
当 此集合非空时

其他情况

(1) next[0] 王 一1,next[1]=0G=1,在1 一 ) 一1 的 位 置 上 没有字符 ,属于 其 他 情况 ) 。

(2) 如果 next[ 让 王 ,表示有

"41 一人

十1一人十1。
@@ 若 六 二与 ,即有"0和 让-二-5显然有 next[7

加 若 记 夫 二 ,说 明太 之 前 不存在长度为next[7门十1 的 子囊和 开头 字符 起 的 子串相同 ,

136

亿 O人AR

那么是 否 存在 一 个 长度较 短 的 子囊和 开头 字符 起 的 子 串相同呢? 设 &'=next[LA](回退),

则 下 一 步 应 该将志 与 妈 比较: 若 扇 三生 , 则说 明 访 之 前存在长度为next[LAJ]十1 的 子囊和

开头 字符 起 的 子串相 同; 否则 依 此 类 推找更 短 的 子 串,直 到 不 存在可 匹配 的 子串, 置

next[7

十]王0。所以,当记 天 六 时 ,置人 一 next[k]。

对 应 的求 模式串 上 的 next数组的算法如下 :

void GetNext(SqString t,int next[])

// 由 模式串 t 求出next 数组

intj,k;
j 一0;k 一一1;
next[0] 一 一 1;

//i 扫描 tk 记录 t[D站 之 前 与+开头 相同 的 字符 个 数
// 设置next[O]值

while (Gj<t.length一1)

// 求+所 有 位 置的next值

{

证 Gk= 一 一1 ‖ tdata四= 一 tdata[g]) /人为一1或比较的字符 相等 时

jj十十;十十;

next[让 一 k;

{

】}

/ij 依次 移 到 下 一 个 字符

/设置 next[]为上

else k 一 next[k] ;

/VE 回退

{1

)}

【例4. 4】〗 求 模 式 串 :一"aaab" 的 next 数组。

一一1,next[1]一0。
next[0]

57一2 时 ,1~7一1 的 位 置上只 有 一 个 字符 'a' 与 上 的 开头 字符 相同 ,所以 next[2]一1。

Jj一 3 时 ,1一7一1 的 位 置 上 的 前 面有字符 串"a" 和 "aa" 均与:的

开头 字符 串 相同 ,所

以 nextL3]王2。

归纳起来 ,模式串上 对 应的next 数组如表 4. 1 所 示 。

表 4.1 模式串上 的 next 数组

了了

慧

next[ 让

0

人

一 1

1

人

0

2

人

1

3

b

2

2 全 天 的 各 二 天 和 各

当 求 出 模式串 上 的 next 数组 表示 的 信息 后 ,就 可以 用 来 消除 主 串 指针 的 回溯。这 里 仍

以 目标串 * 王"aaaaab" ,模式串 :一"aaab"为例说明。

第 1 趟 匹配 是从 ;一 0 一 0 开始 的,失 配 处 为;=3,j 一 3。尽管本 趟 匹配失败了 ,但得

到 这 样的“部 分 匹配?信息 : sss 与 2 相同 ,如 图 4.8(a)所示。

而 模式串上 中有 next[3]王2 ,表明 关 =00 ,所 以有ss一2 ,如图4.8(b)所示。

原来第 2 趟 匹配是从 ;二1 =0 开始 的 ,即需要 回溯。现 在 既然有 sis一25 成立,第 2

趟 匹配 可 以 从 i3 二 2(王next[L3]) 开 始 ,如图4.8(c) 所 示 ,即保持 主 串 指针 守 不变, 模 式

串 上 右 滑 一 (=) 一 next[L 门)个位 置 ,让 s 和 cas对齐进行比较。

下 面讨 论一般 情 况 , 设 目标 串 = "sosl...s-i" ,模式串 :一"oli" ,在 进行第;一 /十

] 趟 匹配(从 si 一 开始 ) 时 出 现如 图 4.9 所 示 的 失 配 情况Cs 天方 ) 。

137

数据 结构 教程

\B@OG

站

证

和

S:alaajla ab

S:ala ala ab

s: alaala ab

二
tala ajb
人

(a) 5 于 廊

二
1:[a ala b
必
(b) si5=抽在

1:

[aajlab

人
(c) : 右滑

图 4.8 利用 next 值消除主串 指 针 的 回溯

目标串s: ss ss

模式串二

|
有

图 4.9 目标串和 模式 串 匹配的 一 般 情况

这 时 的部 分匹配 是 "oa 6- 一-Rs ,显然 在A<7时有:

1 (4.1)

因为 next[7门一&,即,

1 (4.2)

由以上 两 式 说 明 "oo 有-二 -eicsii "成立 。下 一 趟 就 不 再从 si+ 开 始 匹

配,而是从 %-*开始匹配 ,并且直接将 * 和 六 进行比较,这 样可以 把 第 ;一)十1 趟 比较“ 失

配?时 的模式串: 从 当前 位 置 直接 右 滑 7 一上个 字符 ,如 图 4. 10 所 示 。

目标串$: ss

SSPr1 SI SSPE SP SS

部 分 匹配 :

大 个字符 相同

模式串 1

有

1在

由 100

目标串 8: soS1 ... SSPr1 SI SEE SP Sr

模式串

而

几 下 一趟从we 开始

目标串 8, so sl

...。 SSHF1 SEE SHESPE 3 号 31

\

比较: 上 右 滑 .六 个 字符

模式串 上

而 在

图 4. 10 ”模式串右滑7 一A个 字符

上 述 过 程 中 ,从第 ;一7十1 趟 匹配(从 si-开始)直接转到第;一上十1 趟 匹配(从 %-*开

始) ,中间 可 能 遗漏 一 些 匹配趟 数 (即 第 ;一7十2 趟 一第 ;一&趟) ,那么 KMP 算法是否正确

呢? 实际上 ,因为 next[让 =A, 容 易 证明中 间 的 匹配 趟 数 是 不必要 的 。

拉--扫

通过 一 个 示例进行 验证 。设 目标串一"sosszssstssse", 模 式 串 一
"6nttsa6" nextL5]王2。从 S 开 始 匹配 (第 2 趟 ) , 失 配 处为ss 天 上 ,这里

1 一 6,j 一 5,A 一 2, 下 面说明 第 ;一7 十 2(=3) 一 第 ;一上(一4) 趟 是 不 必

要的。

138

人@O人AR

如图4. 11 所 示 ,部 分匹配 信息 有 "zex "一

"sasss4s"。 因为next[5]一2,有"oa "一

"52 同时有"oatz "天 "26u"( 若 相等 ,则 next[5]一

4 而 不是2) ,从 而 推出"sasastss "天

"656a"。 所以 从 %> 开 始 匹配(第 3 趟 ) 是 不必要的。

目标串s: so wm

|

四

| |

态

旋

让 全

next[S]=2

模式串 二

目标串s: ss 5 5

模式串 4

有 有

图 4.11

没有 必要 从 % 开始匹配

同样 ,因为 nextL5]

王2,有"oat "天 "tu "(若相等,

则 next[5]=3 而 不是 2) ,推出从

5 开始匹配 (第 4 趟 ) 是 不 必要的。下 一 趟 应 该从 % 开始

匹配 (第 5 趟 ) ,而且直接将 se与 六

进行比较 。

所以 , 当 模式串上 中 心与目标串 * 中 某 个 字符 *; 失 配时 ,用 nextL0]一一1 表示 上 中 已经

没有字符与当前 字符 ?进行 比较了 。: 应 该 移动到目标串s 的 下 一 个 字符 ,再和 模式 串 上 中

第 一 个字符进行比较。

另外 ,BF 算法 的 匹配 过 程 是第 1 趟从 % 和 ww 比较开始 ,第 2 趟从s 和

4 比较 开始 ,第 3 趟从 > 和 ww 比较开始 , 依 此 类 推 。而 KMP 算法 的 第 1 趟

从 se 和 比较 开始 ,第 2 趟 不 一 定从 s 开始,所以 和 BF算法相比可能会

减少 匹配 的 趟 数 。

因此 KMP 过 程如 下 :

这 0; j 一 0
while (s 和 t 都 没有扫描完)
{

诗人 G= 一 1 或 者 它们 所 指的字符 相同 )

i 和 j 分 别 增 1;

else

即模式串右滑);
i 不变,j 回 退 到 j王next[i](

}
这 (j 超界) 返回 i 一 t 的 长 度 ;
else 返回一1;

对 应的KMP 算法如下 :

// 模 式 匹 配成功
// 模 式 匹配失败

int KMPIndex(SqString s,SqString t)
{

,i一0,j一0;
int next[MaxSize]

//KMP 算法

GetNext(t,next);
while (i< s.length && j<t.length)
{,

诺 G== 一 1

| s.data[ 口王=t.data[D])

ii寺十;
j 十十;

{

】}

//ij 各增 1

139

数据 结构 教程

[第! 5版

else j 一 next[门 ;

/Vi 不变,j后退

}

迁 (j >一t.length)

return(i 一 t.length);

else

return( 一 1);

)}

/匹配成功
// 返 回子串位置

/匹配不成功
// 返 回一1

设 主 串 * 的 长 度 为 , 子 串 上的长度为六 ,在 KMP 算法 中求next 数组 的 时间 复 杂 度 为

O(Cz) ,在 后 面 的 匹配中因目标 串 * 的下标; 不 减 ( 即 不 回溯 ) ,比较 次 数 可 记为所以人 MP

算法 的 平均时间 复 杂 度为O(z十mm) ,优于 BF 算法 。但 并 不等于说任何 情况下 KMP 算法

都 优于 BF 算法 , 当 模 式 串的 next 数组中 next[0] 王 一1, 而其他 元 素 值 均为 0 时,KMP 算

法退化为 BF 算法。

【例4.5] 设 目标串 * 王"aaaaab" ,模式 串 :一"aaab" ,给出KMP 进行 模式 匹配的过程。

模式串上 对 应的next 数组如表 4. 1

所 示 , 采 用 KMP 算法 的 模式 匹配过 程如图 4. 12

所 示 。 首 先 用 ;) 分 别 扫描 和 :初始时;一 0.J=0), 若 当前比较 的 字符 相同 则 均 增 1,比

较到 3,)一3 失败 为 止;; 值 不变(不 回溯 到 前 面) ,修改 )一nextL3] 王 2; 下 一趟从 ;一

3/1=2 开始 比较,这 之 后所有 字符 均 相同 ,ij 递增到z 扫描 完毕,此 时 ;一 6,7一4,返回
1 一4. length一2,表示 :是* 的 子 串 , 且 位 置为 2, 总 共需 要 8 次 字符 比较 (恰好 为 字符间 纵 向

连接 线条 数 ) 。

第 1 趟匹配
(从冯0, 产0开始)
关0,产

sS: aaaaab
|
|
|
aaab

加

友3
加

六

失败 ,修 改 为 ?不 变
守 不 变

败 , 修 改为

六 next[3]-2

第 2 趟 瑟 配
(从-3,六2 开始)

让
s:aaaaab

leneth=2
| 有

大6

_、,

1 aaab

人

图 4.12 KMP 算法 的 模式 匹配过 程

3 进的WP 算 关

上述KMP 算法中定义的 next 数组 仍然存在缺陷。例 如设 目标串

为"aaabaaaab" ,模式 串 : 为"aaaab" ,模式串 :对 应 的 next 数组如表 4. 2

所示。

ee

表 4.2 模式 串 / 的 next 数组 值

了

碟 让

next[ 让

0

色

一 1

1

Q

0

2

Q

1

3

Q

2

4

已

3

这 两个串 匹 配 的 过 程如图 4. 13 所 示 , 从 中 可以 看 到 , 当 这 3/一3 时,ss 天 6 ,由 next[ 门可

知还需要 进行 ;一3/=2,i=3/=1,=3/=0 的 3 次 比较 ,总 共需 要 12 次 字符 比较 。

140

个 0人AR

实际上 ,因为模式串上 中的za sz 字符 和 字符 都 相等,所 以 不需要 再 和 目标 串 中 的

ss 进行 比较,可以 将 模式 一 次 向 右 滑动 4

个 字符 的 位 置 ,即 直接 进行 ;一4/=0 的 字符 比

较 ,对 应 图 4. 13(a)

和(f) ,总共需要 9 次 字符 比较 。

3

目标 串 , 人 ” 失败

问3

模式 串, aaa | b

修改为 关next由-2

大

3

(Ca) 第 1 趟 匹配

目标 中 : 人 失败

避 3

模式 串:

aaaab
4 普

修改为next-1

(b) 第 2 趟 匹配

业3

目标串: aaabaaaab

失败

3

模式 串 :

aaaab
4

修改 为

next[1=0

(c)

第 3 趟 匹配

3

目标串: aaabaaaab

炎 几

癌 3

修改 为

模式串

aaaab
0

修改 为

next[/ -1

(d) 第 4 趟 匹配

目标圳: aaabaaaab

Ra

站9

人 7

(e) 第 5 趟 匹配 ,返回 王 rlength=4

图 4.13 KMP 算法的模式 匹配过 程

和 计 1=4

疡 /+1=0

这 就 是 说 , 若 按 前 面 的定义得 到 next[ 门 一&, 在 模式串中 有 万 一生 : 当 目 标 串 中 的 字符 s

和模式串中的字符六 比较不相同时,* 一 定 和 忧

也 不 相同 ,所以 没有必要再将* 和 总 进行

比较 ,而是直接将 * 和 tescq进行比较。为 此 将 next[L7门修正为nextval[L7门。

nextval数组的定义是nextval[0] 王 一 1, 当 万 二 men中 时 nextval[让王 nextvalLnext[7门] ,否则

nextval[ 门二next[7门。

用 nextval 取代 next,得到改进的KMP 算法如下 :

void GetNextval(SqString t,int nextval[])

// 由 模式串 + 求出nextval 值

{1 intj一0,k一一1;

nextval[0] 一 一 1;

141

数据结构教程 SEASAR

while (j <t.length)

{

这 (k= 一 一1 1‖ tdata[四= 一 tdata[l])

{ 计 十 ;KETTi

这 (t.data[j]!

一

t.data[k])

nextval[j] 一 k;

nextval[] 一 nextval[k] ;

else

】}

else

上一nextval[k] ;

》}

}》

int KMPIndexl(SqString s,SqString t)

// 改 进 后的KMP 算法

{

int nextvalLMaxSize] ,i一 0,j 一 0;

GetNextval(t, nextval) ;

while (i< s.length &&&& j<t.length)

{,

计 G== 一 1

口二=t.data[D])
1 s.data[

i计十;

j十十;

{

】}

else

j 王 nextvalD];

》}

迁 (j >一t.length)

return(i一 t.length);

else

Teturn( 一1);

与 改进 前的KMP 算法 一 样,本 算法的时间 复 杂 度 也是OC0z十mm) 。

【例4.6〗 设 目标 串 * 王"abcaabbabcabaacbacba" ,模式串 上 一"abcabaa"

,计算模式串 “

的 nextval 函数值 ,并 给 出 利用 改进KMP 算法 进行 模式 匹配的 过 程 。

模式串 上 的 nextval 值如表 4. 3 所 示 。

表 4.3 模式串上 的 nextval 函数值

了了

0

1

2

3

作

5

6

红 让

悍

b

C

日

b

人

next[ 让

一 1

0

0

0

1

2

1

nextval[ 让

一1

一1

0

2

利用 改进KMP 算法 的 匹配过程如图 4. 14 所 示 。

142

亿 O人AR

第 1 趟 匹配 s: abcaabbabcabaacbacba =4

失败 码4
产4 修改为 “广 nextval[4]-0

一一一

|

|

|
|
大 人

第2趟匹配 s: abcaabbabcabaacbacba i=6

失败

产 2 修改为 ” 产 nextval[2]=0

F6
/

订

|

abcabaa

4

第 3 趟匹配 s: abcaabbabcabaacbacba FF6 失败 6

6 abcabaa

人

六0 修改为 “产 nextval[oj=-1

修改为“天 二 1=7
ee

六 +1-0

第4趟匹配 s: abcaabbabcabaacbacba

到 14

|

|

|

|

|

|

|

四 ea

成功,返回 天 zlength=7

图 4.14 KMP 算法 的匹配 过 程

一 本章 小 结 一 一 一

本 章 的 基本 学 习 要 点如 下 :

(1) 理解 串 和 一般线性 表 之间 的差异 。

(2) 掌握 在顺序 串 上 和 和链串 上 实现串 的 基本 运算 算法设计 。

(3) 掌握串 的 简单 匹配 算法 ,理解 KMP 算法 的 高 效 匹配 过 程 。

(4) 灵活 地 运用 串 这 种 数据结构 解决一些 综合 应 用问题 。

一 练习题 4

一 和 一

1. 串 是 一种特殊 的 线性表 , 请 从 存储和 运算 两 方面分析 它 的 特殊 之处。

2. 为什么在模式匹配中 BF 算法是有回溯 算法 ,而KMP算法是无回溯算法?

3. 在 KMP 算法 中计算 模式 串的next 时 , 若 7)一0, 为 什么要四 next[0]王一17

4. KMP 算法 是 简单 模式 匹配算法 的 改进 ,以 目标串 一"aabaaabc"、模式串:一

"aaabc"为例说明的 next 的 作用 。

5. 给 出以 下模式串的 next 值和 nextval 值:

(1) ababaa

(2) abaabaab

6. 设 目标 串 * 王"abcaabbabcabaacbacba'",模式串 :一"abcabaa'"。

(1) 计算 模式 串 :的 nextval 数组。

(2) 不 写 算法 ,给 出 利用 改进的KMP 算法 进行模式 匹配的过 程 。

(3) 总 共 进行了多 少 次 字符 比较 ?

7. 有 两个顺序串 1 和 >2 ,设计 一 个 算法 求顺序 串 3 ,该串中 的 字符 是 1 和 2 中 的 公

数据 结构教程

[第! 5 【版

共 字 符 ( 即 两个串都包含的字符 ) 。

8. 采用顺序结构 存储 串 ,设计 一 个 实现 串通 配 符 匹配 的 算法 pattern_index() ,其中的通

配 符只有 '?'", 它 可以 和 任何 一 个 字符 匹配 成 功 。例如,pattern_index("? re","there are")返

回的结果是 2。

9. 设计 一 个 算法 ,在 顺序串 *

中 从 后 向 前 查找 子串 上 , 即 求:在 * 中 最后一 次出现 的 位 置 。

10. 设计 一 个 算法 ,判断 一个字符 串 * 是 否 为形如 "序列 1@ 为 序列 2" 模 式 的字符序列,

其 中 序列 1

和 序列 2 都 不 含有 '@ ' 字 符 , 且 序列 2 是 序列 1 的 逆序列。例 如"a 十2@2 十a" 属

于 该 模式 的 字符 序列 ,而"1 十3@3 一 ] "不 是 。

11. 采用 顺序结构 存储 串 ,设计一个算法求串* 中 出 现 的 第 一 个 最 长重复子 串的下标

和 长 度 。

12. 用 带头 结 点 的 单 链表 表示 链 串 ,每个结点 存放一个 字符。设计 一 个 算法 ,将 链 串

中 所 有 值为z 的 字符 删除 。要求 算法的 时间 复 杂 度 均为 O0z) 空间 复杂 度为O(1)。

一>- 上 机实验题 4 一生

实验题1: 实现 顺序串的 各种 基本 运算 的 算法

目的: 领会顺序 串 存储 结构和 掌握 顺序串中 的 各 种 基本 运算 算法 设计 。

内 容: 编写一个程序sqstring. cpp,实现顺序串的 各 种基本运算,并 在 此 基础上设计 一

个 程序exp4-1. cpp 完成 以 下 功能。

(1) 建立串 *= 王"abcdefghefghijklmn"和串 s1 一 "xyz"。

(2) 输出串 >。

(3) 输出串 的长度 。

(4) 在串* 的第 9 个字符位置插入串 sl1 而 产生 串 2 。

(5) 输出串 2 。

(6) 删除串* 的第 2 个 字符 开始 的 5 个字符而产生串 *2。

(7) 输出串 >2。

(8) 将串* 的第 2 个 字符 开始 的 5 个 字符 替换成串 sl 而 产生 串 *2。

(9) 输出串 >2。

(10) 提取串 * 的第 2 个 字符 开始 的 10 个字符而产生串 3。

(11) 输出串 3

(12) 将串 sl 和 串 2连接起来而产生串 4。

(13) 输出串 >4

实验题2: 实现 链 串的各 种 基本 运算 的 算法

目的: 领会链 串 存 储结构和 掌握 链串中 的 各 种 基本 运算 算法设计 。

内容: 编写一个程序 listring. cpp, 实 现 链 串 的 各 种 基本 运算 ,并 在 此 基础上 设计 一

程序 exp4-2. cpp 完成以下功能。

(1) 建立串 = 王"abcdefghefghijklmn"和串 s1 一"xyz"。

GE

PMAsSJ |

(2) 输出串s。

(3) 输出串* 的长度 。

(4) 在串* 的第 9 个字符位置插入串 1 而 产生 串 2 。

(5) 输出串 2 。

(6) 删除串* 的第 2 个 字符 开始 的 5 个字符而产生串 *2。

(7) 输出串 2 。

(8) 将串s 的第 2 个 字符 开始 的 5 个字符蔡换成串 1 而 产生 串 :2。

(9) 输出串 2 。

(10) 提取串 * 的第 2 个 字符 开始 的 10 个字符而产生串 3。

(11) 输出串 s3。

(12) 将串s1 和 串 s2连接起来而产生串 s4。

(13) 输出串 4。

实验题3: 实现 顺序 串的各种模式匹配 算法

目的: 掌握串 的 模式 匹配 算法 (即 BF 和 开 MP 算法)设计。

内容: 编写一个程序exp4-3. cpp,实现顺序 串的各 种 模式 匹配 运算 ,并 在 此 基础 上 完成

以下功能。

(1) 建立 目标串* 王"abcabcdabcdeabcdefabcdefg"和模式串 :一"abcdeabcdefab"。

(2) 采用 简单匹配 算法 求:在s 中的位置。

(3) 由 模式 串 上 求出 next 数组值和 nextval 数组值 。

(4) 采用 KMP 算法 求:在* 中 的 位置。

(5) 采用 改进的KMP 算法 求上在* 中 的 位 置 。

人设计 性 实验

实验题4: 文本 串 加 密 和 解密 程序

目的: 掌握串 的 应 用 算法 设计 。

内容: 一 个 文本 串 可 用 事先给定的字母映射 表 进行加 密。例如, 设字母映射表为:

abcdefghijklmnopqrstuvwxyz

ngzqtcobmuhelkpdawxfyivrsj

则 字符 串"encrypt"

被加密为"tkzwsdf"。 编 写 一 个 程序exp4-4. cppb ,将 输入 的 文本 串 加 密

后 输出 ,然后进行解密 并 输出 。

实验题$: 求 一 个串中 出现 的 第 一 个 最 长重复 子 串

目的: 掌握串的 模式 匹配 应 用 算法 设计 。

内 容 : 采用顺序 结构 存储 串 ,编写一个 程序exp4-5. cpp, 利 用 简单模式匹配 方法 求串

ss

中 出 现 的 第一个 最长重复子串的下标和 长 度 。

观 综 合性实验

实验题 6: 利用 KMP 算法 求 子串在 主串中 出现 的 次 数

目的: 深入 掌握KMP 算法的应用。

内容: 编写一个程序exp4-6. cpp, 利用KMP 算法求子串 上 在 主串*

中 出 现 的 次数,并

以 :="aaabbdaabbde" ,上 :一"aabbd"为例, 显示匹配过程。

在 算法设计 经 常需要 用递归 方法 求解, 特别是后 面 的 树 和 二

又树、

算机科

\ 查 找 及

排序等章节 中 大 量地

用 到 了 递归 算法。递归 是计

学 中 的 一 个 重要工具 , 很 多程序设计语言 如 C/C++) 都 支持

递归程序 设计 。

本 章 介绍 递归的 定义 和 递归 算法设计 方法等, 为后面 的学习 打

下 基础 。

PASS着 归 |

什么是递归

米

511 递归的定义

在 定义一个 过 程或本 数 时 出 现调用 本 过 程 或本郴 数 的 成分称 为递归 (recursion) 。 若调

用 自身 , 称为直接递归 (direct recursion)。若 过 程 或函数 训 调 用 过 程 或 函数9 ,而

又 调用

妃 , 称 为间接递归 (indirect recursion)。在 算法 设计 中 ,任何 间接递归 算法都可 以 转换为直

接递归 算法 来实现,所以 后 面主要讨论 直接 递归 。

递归 不 仅 是数学 中 的 一 个重要 概念,也 是计算 技术中 的 重要 概念 之 一。在 计算 技术中 ,

与 递归有 关 的 概念有递归 数列 、`递 归 过 程.递 归 算 法 .递归 程序和 递归 方法 等 。

(1) 递归 数列 指 的是由 递归关系 所 确定 的 数列 。

(2) 递归 过 程指的是直接 或 间接 调用 自身 的 过 程 。

(3) 递归 算法 指 的是包含递归 过 程 的 算法 。

(4) 递归 程序指的是直接 或 间接 调用 自身 的程序 。

人

(5) 递归 方法 指 的 是 一 种 在 有限步又 内 根据 特定 的 法 则 或公式 对 一 个 视顺讲角

或 多 个 前 面 的 元 素 进行运算 ,以确定 一 系列 元 素(如 数或机 数 ) 的 方法 。

如 果 一 个递归 过 程 或递归 函数 中 的 递归 调用 语句 是 最后一 条 执行 语句, 则 称 这 种递归

调用为尾递归(tail recursion) 。

【例 5.1〗

以 下 是求24(z 为 正 整数) 的递归 函数 , 它属于 什么 类 型 的递归 ?

int funCint n)

{ 计 Cn==一1)

Teturn(1);

else

// 语 名 1

// 语 名 2

// 语 名 3

return(fun(n一1)* n); // 语 名 4

}

在 函数 fun(z)

的求解过程中调用 fun(z一1) (语句 4) , 它 是 一个直接递归函数 ,又

由 于 递归 调用 是 最 后一条语句 ,所以它又属于 尾递归 。

递归 算法 通常 把 一个大 的 复杂问题 层层转化 为一个 或 多 个 与原问题 相似 的 规模 较 小 的

问题来求解 ,递归 策略 只 需 少 量 的代码 就可以 描述 出 解 题 过程中所 需要 的 多 次 重复 计算 ,大

大 减少了 算法 的代码 量 。

一 般 来说 ,能够用递归 解决的 问题 应 该 满足以下 3 个 条件 :
(1) 需要 解决 的 问题可 以 转化 为一个或多 个 子 问题 来 求解,而 这 些 子问题 的 求解方法

Sn

与 原 问 题 完全相同,只 是 在数量规模 上 不 同 ;

(2) 递归 调用 的 次数必 须 是 有限 的 ;

(3) 必须 有 结束 递归 的 条件 来 终止递归 。

递归 算法 的 优点 是 结构 简单 清晰 ,易于 阅读 ,方便 其正确性证 明 ; 缺点是算法执行中

占用 的 内 存 空间 较 多 ,执行效率 低 ,不 容易 优化 。

147

数据 结构教程

[第! 5版

512 何 时 使用递归

在以下 3 种 情况下 常常要 用 到 递归 方法 。

有 许多 数学 公式 .数列 等 的定义 是递归 的。例如,求21和 Fibonacci 数

认 而 和

列等 。 对 于 这 些问 题 的 求解可以 将 其递归 定义 直接 转化 为对应 的递归 算法。例如,求z4可

以 转化 为例 5. 1 的 递归 算法。求 Fibonacci 数列 的递归 算法如下 :

int Fibl(int n)
{(

这 Cn==一1 1 n 一一2)

Teturn(1);

else

// 求 Fibonacci 数列 的第 n 项

return(Fibl(Cn 一1)十Fibl(Cn 一2));

}

显然,上 述递归 算 法属于 尾递归 算法 。

2 数据 结构是递归 的

有 些 数据结构 是递归 的。例 如 第 2 章 中 介绍 的单链表 就 是 一 种递归 数据结构,其 结 点

类 型声明如下,

typedef struct LNode

{

ElemType data;

Struct LNode * next;

)》 LinkNode;

// 存 放 结 点 数据

// 指 向 下 一 个 同类 型 结 点 的 指针
// 单 链表 的 结 点 类 型

其中,结构体LNode 的声明用到了 它 自身 , 即 指针 域 next 是一种指向 自身 类 型 结 点 的 指

针 , 所以 它 是 一 种递归 数据结构 。

对 于 递归 数据结构 ,采用 递归 的 方法 编写算法 既 方 便 又有效。例 如 求 一 个 不带头 结点

的 单 链表 工 的所有 data 域 (假设为int 型 )之和 的 递归 算法如 下 :

int Sum(CLinkNode * 工)

{

让 CL==NULL)

Teturn 0;

else

return(L 一 > data 十Sum(L 一 > next)) ;

)》

PE

有 些 问题 的解法 是递归 的 , 黄 型 的有 Hanoi 问题 求解,该问题 的 措 述是,设有 3 个 分 别

命名为XY 和 2 的 塔座,在 塔座 X 上 有 ) 个 直径 各 不 相同 的盘片 ,从小到 大 依次 编号为1、

2... we。 现 要 求 将 六 塔座上 的 这 , 个 盘 片移到 塔座Z 上 并 仍 按 同 样的顺序 苹 放 ,航片移动

时 必须遵守 以 下 规则 : 每次只 能 移动 一 个 禾 片; 和 片 可 以 揪 在 X、Y 和 2 中 的 任一塔座; 任

何 时 候 都 不 能 将 一 个较大 的 盘片放 在较小 的 盘 片上。 图 5.1 所 示 为 一 4 的 Hanoi 间 题 。

(es

设计 求解该问题的算法 。

第人5 人间

皇|| 一解研

了 2

三 了

忆

图 5.1

Hanoi 问题(*一4)

Hanoi 问题 特别 适合采用递归 方法 来 求解 。设 Hanoi(Cz,z,y,z)表示将半 个 盘 片从工

塔座借助 塔座移 动到> 塔座上 ,递归 分 解 的 过 程如 下 :

Hanoio xy 相 | 一一一 | moveo r, 5: 将 第 个 圆盘从 x移 到 =,

Hanoi0z-1, y,x, 卫

Hanoi(z-l,, x,=z, 刀;

其 含义是首先将工塔座上的2 一 1 个 盘 片 借助 = 塔 座 移动到>y 塔座上; 此时并 塔座上

只 有 一 个 盘 片,将 其 直接 移动到 > 塔座上; 再将 >塔座上的2 一 1 个 盘 片借助 x塔座移动到

z 塔 座上。 由 此得 到 Hanoil 递归 算法 如 下 :

void Hanoil(int n, char X,char Y,char Z)

{

这 (n=一一1)

// 只 有 一 个 盘 片的情况

printfC"\t将第%%d 个 盘 片从5c移动到ce\n",n,X,Z);

else

// 有 两 个或多 个 盘 片 的 情况

{ HanoilCn
一1,X,Z,Y);

printfC"\t 将 第 吧 d 个 盘 片从%%c 移动到%c\n",n,X,Z);

Hanoil
Cn一1,Y,X,Z);

)》

设 HanoiCz,z,y,z)

的执行时间为T(z) ,由 Hanoil 递归 算法得 到 以 下 递推式 :

T(z) 一 1

T(O) 一 2T(2 一1) 十 1

当 7 一 1 时

当 7 一 1 时

则: To) 三2T(2

一1) 十 1

一 2(02T(C2

一 2)十1)十1

22T( 一2)十2十1一2 (2T(2

一3) 十1) 十 2 十 1

一3)十22十2十1
二 2T(O2z

十2于十......十22十2十1
二21TGD)

一 2 一1=O(029)

513 递归模型

递归 模型 是递归 算法 的 抽象 ,它反 映 一 个递归 问题 的递归 结构 ,例如 , 例 5.1 的递归 算

法 对 应 的递归 模型如 下 :

Ca) 一 1
(GODD) 一 人 x< Fa2一 1)

一
1 己
7>1

149

数据 结构教程

[第! 5版

其 中 ,第 一 个 式 子 给 出 了 递归 的 终止条件 ,第 二 个 式 子 给 出了7) 的

值与fCz一1)的值之

间 的 关系 ,把 第 一 个 式 子 称 为递归 出

口 ,把第二 个 式 子 称 为递归 体 。

一 般情况 下 ,一 个递归 模型由递归 出 口和递归 体 两 部 分 组 成 。递归 出口(recursive

exit) 确 定 递归 到 何 时 结束 , 即指出 明确 的递归结束 条 件。递 归 体 (recursive body)确定递归

递归 出 口 的 一 般 格式如下 :

这 里 的 % 与 ma 均 为 常量,有 些递归 问题可能 有 几 个递归 出 口 。递归

Js) 一 7

(5. 1)

体 的 一 般 格 式如 下 :

5

GD = grJGDcycnyeyco)

(52)

其 中 ,六ma 均 为 正 整数 。这上

的 % 是 一 个 递归"大 问题 ”ss+l,...ys-1 为 递归"小 问

题 ",cj ,ci+l,...'cn 是 若干 个可以 直接 (用 非 递归 方法) 解 决 的问题,8 是 一 个非递归 函 数 ,可

以直接求值。

As)

-一

JS)

Js

加

Js

实际 上 ,递归思路 是 把一个 不 能 或 不好 直接

求解 的“大问题?转化 成一个 或 几 个 *小 问题”来解

决 ,如 图 5.2 所 示 , 再把这 些小 问题?进一步分解

成 更 小的“小 问题 ?来 解决 ,如此分解,直到每个

“小 问题 ?都可 以 直接 解决(此 时 分 解 到递归 出

图 5.2

把 大 问题 FCs,)转化成几个

口)。但递归 分 解不是 随意 的 分解,递归 分解要 保

小问题来解决

证 “大 问题"与“小 问题”>相似 , 即 求解过 程 与环境

都 相似 。

为 了讨论 方便, 设 简化 的递归 模型 (即将 一 个“大 问题"分解 为一个“小问题”> 如 下 :

Cs) 一 7

Js) 一 SCFC iT) co)

(5.3)

(5.4)

在求/Cs)

时 的 分解过 程如下 :

Cs)

+

Cs1)

+

+

Cs)

+

CS)

一 旦 遇 到 递归 出

口 ,分解过程结束,开始求值过 程,所以 分解过 程

是 量变” 过 程 ,即 原来

的 “大 问题 在 慢 慢 变 小 ,但 尚未 解决,遇 到 递归 出 口后便 发生了 ”质变”, 即 原递归 问 题 便 转

化 成 直接问题 。 上 面 的 求值过 程如 下 :

PASS着 归 |

Js)一7
y

CS)一8gCFGS) cl)

y

ss)一5CFCsa) cz)

y

y

Cs 一 SC ii) co li)

这样 /Cs ) 便计算出来了。 因 此 ,递归 的 执行过 程由分 解和求 值两部 分 构成,分解部 分

就 是 用 递归 体 将“大 问题”分解 成 “小 问题”*,直 到 递归 出 口 为 止 ,然后进行 求 值 过 程 , 即 已 知

“小 问题 ”计算 “大 问题 ”。前 面的fun(5)

的求解过程如图 5. 3 所 示 。

fun(5)

AN

fun(4)

AN

fonG3)

fn(5)=120

图 5.3 fun(5)的求值过程

在递归 算法 执行中 最 长 的递归 调用 的 链 长 称 为该算法 的递归 调用 深度 。例如 求 zl! 对

应 的递归算法在求fun(5)

时递归调用深度是 5 。

对 于 复杂 的 递归 算法 ,其 执行过程可 能 需要 循环反复 的 分 解和求值才能 获得 最 终 解 。

例如 ,对于前面求Fibonacci 数列的Fibl 算法,求 Fib1(6) 的 过 程 构成 的递归 树 如 图 5.4 所

Fib1(6)

区

、

Fibl(5) | 5

Fibl(4) | 3

Fibl(4) | 3

Fibl(G3) | 2

FiblG) |2

、

FiblO)

Fibl(G3)

|2

Fibl(C) | | FiblO)

Fibl(D | | Fibl02)

Fibl(D)

2AA EN

1

1

1

1

1

FiblC) |1

| FiblG) |1

图 5.4 求 Fib(6)
对应的递归树

151

数据 结构教程

[第! 5版

示 ,向 下 的 实 箭头 表示 分 解 ,向上 的 虚 箭 头 表 示 求 值,每 个 方 框劳边 的 数字 是 该 方 框 的求什

结果 ,最 后 求得Fib1(6) 为 8。 该递归 树 的高度为 5, 所以递归 调用 深度 也 是 5。

514 递归与数学归纳法

从 递归 体 可 以 看 到 ,如 果 已知ss sl就可以确定 %%。 从 数学

归纳 法 的 角度 来看,这 相当 于 数学归纳 法 归纳 步又的 内 容。但仅有 这 个 关

系 还 不 能 确定 这 个 数列 , 若 使 它完全 确定,还应给出这 个 数列 的 初始值 * 。

例如 ,采用 数学 归纳 法 证明下 式 :

1 十?十 ... 十 见一 22 十 1

2

当 一1 时, 左 式 一1, 右式 一一1, 左 、 右 两 式 相等,等式成 立 。

假设当一&一1 时 等 式 成 立,有 1 十 2 十 ... 十 (CD 一 全 全

当时 ,在 式 一 1 十 2 十...... 十 一 1 十 2 十 沪 十 (一 1 十4 一 全 帮 二 世上十 A(R十1)

2

2

等 式 成 立

。即证。

数学 归纳 法 是 一种论证 方法 ,而递归 是 算法和 程序设计 的 一 种实现 技术 ,数学归纳 法 是

递归 求解 问题 的 理论 基础 。可 以 说递归 的 思想 来自数学归纳 法 。

栈 和 递归

521 函数 调用 栈

函数 调用 操作 包括 从 一 块代码 到 另 一 块代码 之间 的 双向数据传递和执

行 控制 转移。数 据 传递通过 函 数 参数和 返回 值 实现, 另 外 还需要 在 进入天

数 时 为 函数 的 局 部 变量 分 配 存 储 空 间 ,并且在退出 函数时收回 这 部 分 空间 。

视频 讲解

大 多 数 CPU 上 的 程序实现 使 用 栈 来支持 函数 调用 操作。单个函数调用

操作所使用的

函数调用 栈被称 为 栈 帧(stack frame)结构。每次函数调用 时 都 会 相应地 创建 一 帧,保存 返

回 地 址 、 函 数 实参和 局 部 变量 值 等,并 将 该 帧 压人调用 栈。若 在该函数 返回 之 前 又 发生了 新

的 调用 , 则 同样要 将 与新函数 对 应 的 一 帧进栈 ,成 为 栈 顶。枯 数 一旦执行 完毕,对 应 的帧便

出 栈 ,控制 权 交还 给 该函数 的上层 调用 函数 ,并 按照 该帧中 保存 的 返回地 址确定 程序中 继续

EEEE

执行的位置。

例如 ,若有 以 下 程序 :

int main()

{

int m,ni

fm,n);

// 后 面第一个语句的地 址为dl

152

PASS着 归 |

return 1;

}

void fint s,int t)

int i;

gCiD;

{

}》

void gCint d)

int X,y;

{

)》

// 后 面 第一个 语句 的 地 址为d2

在 执行 上 述 程序时 ,假设 main 函数的返回地址为 do

。 当 执行 main 丽 数时 ,将栈帧中

进栈。在 main 丽 数 中 调用 矿 本 数时 ,将 栈帧@ 进 栈。在 矿 丽数中 调用 8g 末 数时 ,将栈帧四

进栈,如图 5.5 所 示 。 当 g 函数 执行完毕 ,将 栈 帧田退 栈 ,控制权 交 回 到

太 函 数 ,转向其中

的 ds 地 址 继续 执行,其 余 执 行 过 程 类似 。

栈顶

只

而

而

x,

| 栈帧9)

殉, 天

栈帧2

7 下

| 栈帧了

返回地址 。。 实参 局 部 变量

图 5.5 函数 调用 栈

522 递归 调用 的 实现

递归 是 函数 调用 的 一 种特殊情况 ,即它是 调用 自身 代码。因 此 ,也 可以 把 每 一 次递归 调

用 理解 成调用 自身 代码 的 一个复制 件 。巾 于 每 次调用时 , 它 的 参数和 局部 变量 可 能 不相同 ,

因而 也 就 保证 了 各 个 复制件执行 时 的 独立 性 。

但 这 些 调 用 在 内 部 实现时 并 不 是 每 次 调用 真正 去 复制 一个复制 件存放 到 内 存 中 ,而 是

采用 代码 共享 的 方式,也 就 是 它们 都 是 调用 同一个函数 的代码 ,系统 为 每一次调用 开辟 一组

存储 单元 ,用 来存放 本 次 调用 的 返回 地 址 以 及 被 中 断 的 函数 的 参数 值 。这

些 单元以栈的 形式 存放 ,每调用 一 次 进 栈 一 次,当 返 回时 执行 出栈操作 ,把

当前 栈 顶 保留 的 值 送 回相应 的参数 中 进行 恢复 ,并 按 栈 顶 中 的 返回 地 址 从

断 点 继续 执行 。下 面通过 计算 fun(5) 的值介绍递归 调用 过 程实现的内 部

机理。

表 5.1 给 出 了 求解 fun(5) 的递归 调用 过程中 程序 的 执行 及 栈 的 变化情

况 , 设 调用 fun(5) 的 返回 地 址为do。

在 调用 fun(5)

时,先把返回地址 do 以 及 参数 5 进栈,然后执行语句 1.3、.4, 当 遇 到 其 中

的 fun(5-1)(即 fun(4)) 时 ,必须 中 断 当 前 执行 的 程序 , 转 去调用 fun(4) ,记录下其返回地址

为 中 ; 在 调用 fun(4)

时,先把返回地址w 以 及 参数 4 进 栈 ,然后执行 语句1.3、.4,当遇到其

中的 fun(3)时转去调用 fun(3) ,记录 下 其 返回地 址为党; ...。 一 直到 调用 fun(1) ,把 返回

153

数据 结构 教程

9@

地 址 g 以 及 参数 1 进 栈 。

表 5.1 fun(5)的执行过程

序号

调用 /执行 返回地址 进/出栈

栈 内 情况

返回 地址”实参

执行语句

说明

调用 fun(5)

do

进栈

ad

5

1,3,4

调用 fun(4)

四

进栈

调用 fun(3)

de

进栈

调用 fun(2)

da

进栈

调用 fun(1)

进栈

执行 fun(1) 返回 ds

出栈

执行 fun(2) 返回 ds

出栈

[1

e

四|呈|ww
上|上|ol已-
上||ole

必|ww

1,3,4

1,3,,4

1,3,4

1,3,,4

1,2 求得fun(1)一1

求得fun(2)一2

执行 fun(3) 返回 ds

出栈

求得fun(3)一6

EEE

9

10

执行 funC4) 返回 必

出栈

求得fun(4)一24

执行 fun(C5) 返回 ww

栈 雇
全

求得fun(5)一120

然后 执行 fun(1) ,执行 语句 1.2 ,返回 1 并 出 栈 一 次; 执行 fun(2),

执行 语句4, 返回 2

并 出 栈 一 次; ...。 一 直到 执行 fun(5)

,此时栈空 ,返回 120 并 转向 do 。

例如 ,已 知 程序如 下 :

int SCint n)

{

return (n<一0) ?0

: SCn一1)十n; }

154

PASS着 归 |

int main()
{

printf("%dNn" ,SG1));

return 1;

}

程序 执行时 使用 一 个 栈来保存 调用 过 程 的信息 ,这 些信息用 main()、SCO)和 SC1)表

示 ,那么 自 栈底到 栈 顶 保存 的信息 的 顺序 是 怎么 样的?

首先从main()

开始执行程序,将 main() 信息 进 栈 , 遇 到 调用 SC1) ,将 SC1)信息进栈,在

执行递归 函数 SC1) 时 又 遇 到 调用 SC0) ,再将SC0)信息进栈。所以,自 栈底到 栈 顶 保存 的信

息的顺序是main()->SC1)-~S(CO)。

扫一扫

523 递归 到 非 递归 的 转换

一 般情况下 , 尾递归 算法 可 以 通过 循环 或者迭代 方式转换 为 等 价 的 非

递归 算法。例如 ,前 面求Fibonacci数列的递归算法 Fibl 可 以转换如下 : 视员HH册

int Fib2(int n)

//求Fibonacci 数列 的第 n 项

int a一1,b一1,i,s;
让 Cn 一 一1 ‖ n一一2)

Teturn(1);

else

一nii十十)
{ for(i=3;i<

s 一 a 十 bi;

a一bi;

b一s;

{

}

Teturn Si;

}

{

)》

对 于 不 是 尾递归 的 复杂 递归 算法 ,在 理解递归 调用 实现 过 程的基础 上 可以 用 栈来模拟

递归 执行 过 程,从 而 将 其 转换 为 等 价 的非递归 算 法 。

例如 ,在 将 前 面 求解Hanoi 问题的递归算法 Hanoil 转换 为 等价的非递归 算法时 ,需要

使用 一 个 栈 暂时 存放 还 不能直接 移动 盘 片 的 任务 / 子任务 。

首先将任务 HanoiCz,z,y,z)

进栈,栈不空循环: 出 栈 一 个任务 Hanoi(z,z,y,z),如果

它 是 可 直接 移动的,就 移动 盘 片;否则该任务转化为 Hanoi(z 一1,z,z,y)、moveCzyzyz)、

HanoiCz 一1,y,zyz),

按相反顺序(即将 3 个任务 Hanoi(z 一1,y,zyz)、moveCzyz)和

HanoiCz

一1,z,z,y))依次进栈,其中move(z,z,z) 是可 直接 移动的 任务。为此 ,设计一个

typedef struct

{

int ni

char x,y,z3

bool flag;

》 ElemType;

typedef struct

//盘片个数

//3 个塔座

// 可 直接 移动盘片时 为 true, 否则 为 false

// 顺 序 栈 中 元 素 的 类 型

{

, ElemType dataLMaxSize] ;

// 存 放 元 素

数据结构教程 SEASARR

int top;

) StackType;

//栈顶指针

// 顺 序 栈的类 型

栈 中 的 每 个元素 对 应 一 个 求解任务 ,flag 标识 该 任务是 否 可以 直接 移动 盘 片 。采 用 第

3 章 的 原理 设计 好 顺序 栈 的 基本 运算 算法 (除了 将 SqStack 改为StackType 以 外 ,其他代码

都是相同的) 。对 应 的 求解 Hanoi 问题 的非递归 算法如 下 :

void Hanoi2(Cint n,char x,char y,char z)

{

StackType x sti

// 定 义顺序栈指针

了ElemType e,el,e2,e3;

让 Cn<一0) return;

InitStack(st);

// 参 数 错误 时 直接 返回
//初始化栈

e. n 一 ni e.Xx一Xi e.y 一 yi e.Zz一zi e.flag一false;
了PushCst,e);

// 元素e 进栈

while (1StackEmpty(Cst))

{

PopCst,e);

// 栈 不 空循环

//出栈元素e

证 (e.flag一一false)

// 当 不 能 直接 移动盘片 时

{ el.n一e.n一1; el.x一e.yi el.y一e.Xxi el.z一e.Z;

让 (el.n一一1)

// 只 有 一 个 盘 片时可 直接 移动

el.flag一true;

else

// 有 一 个 以上盘 片时不 能 直接 移动

el.flag一false;

了Push(st,el);

一1,y,x,z)步又
// 处 理 Hanoi(n

e2.n一e.n;i e2.x一e.xi e2.y一e.y;i e2.z一e.z; e2.flag一true;
了Push(st,e2);

// 处 理 moveCn,x,z)步又

e3.n一e.n一1; e3.x一e.Xi e3.y一e.Z; e3.z一e.yi

计 (e3.n一一1)

// 只 有 一 个 盘片时 可 直接 移动

e3.flag一true;

else

e3.flag 一 false;

了Push(st,e3);

// 有 一 个 以上盘 片时不 能 直接 移动
一1,x,z,y)步又
// 处 理 Hanoi(n

】}
else

printf("\t将第%d 个 盘 片从%c 移动到中c\n",e.n,e.x,e.z);

// 当 可 以 直接 移动 时

》}
DestroyStack(st) ;

// 销 毁 栈

递归 算法 的设计

兴

531 递归 算法设计 的步骤

递归 算法 设计 的 基本 步骤是 先 确定 求解 问题 的递归 模型,再 转换 成对应的C/C++语言

函数。由 于 递归 模型反映 递归 问题 的“本 质”, 所以 前 一 步是关键,也 是 讨论 的 重点 。

递归 算法 的 求解过 程 是先将 整个问题 划分 为 若干 个子问题 ,然后 分 别 求解子问题 ,最 后

获得整个问题的解。这 是 一种分 而治之 的 思路 ,通常由 整个问题 划分 的 若干 子 问题 的 求解

156

PASS着 归 |

是 独立的,所以 求解过程 对 应 一 棵递归 树。如 果 在 设计 算法 时 就考虑递归 树 中 的 每 一个分

解/求 值部分 会 使 问题复杂化 ,不 妨 只 考虑递归 树 中 第 1
题”和 *小问题”的 关系 ,其 他 关系 与之相似 。

层 和 第 2 层 之 间 的 关系 ,即“ 大 问

扫-扫

由 此 得 出获取 求解 问题递归 模型(简化递归 模型)的步骤 如 下 :

(1) 对 原问题 fCs ) 进 行 分析 ,假设 出 合理的 小 问题FCs,-: )。

(2) 假设 小问题 FCs ~- ) 是 可 解的 ,在 此 基础 上确定大问题 FCs,)的解,

即给 出 As)与 fCs%-i) 之 间 的 关系 ,也就 是确定 递归体 ( 与数学归纳法中假 视上讲解

设 ;一"一 1 时 等 式 成 立 , 再 求证 ;一允时 等 式

成 立的 过程相似) 。

(3) 确定 一 个特定情况 (如 Fl1)或 Co)) 的解,由 此 作为 递归 出 口 ( 与 数学归纳法 中 求

证 ;一1 或 ;=0 时 等 式 成 立相似 ) 。

一1中的最小值。
【例 5. 2〗 采用 递归 算法 求实数数组A[0..”

假设 F(A,i求数组元素A[0..详(共 ;十1个 元 素)中 的 最小 值 。当 ;=一0 时,有

一1D),A[CD),其中
7CADD=AL[o]; 假设 FCA, 一1) 已 求 出 ,显然有 FA,DD=MINCACA,

MIN() 为 求 两 个 值中较 小 值的函数。因 此得 到以 下递归 模型 :

Ar[0]

当 ;i = 0 时

JAD 一

MINCAFCA 沪 一1D),A[i) 其他情况

由 此 得 到以 下 递归求解算法 :

double Min(Cdouble AU] ,int iD

{

double min;

计 (i 一一0) return ALO];

else

{人 min一Min(A,i一 1);

让 (min> AD

上品) return(AD);

else returnCmin) ;

)》

例如 , 若 一 个 实数 数组为double a[]={9.2,5.5,3.8,7.1,6.5}, 调用Min(a,4)返回最

小 元素 3. 8。

【例5.3】〗

求 顺 序 表 (oa ,as ,... ,as) 中 的 最 大 元 素 。

将 顺序 表 分 解 成 (al ,az ,...:,aw)(左子表)和 (an+l,...,as)( 右子表 ) 两 个子表 , 分 别

求 出子表 中 的 最 大 元素 w

和 oj ,比较 w 和 ai 中 的 大 者 ,就 可以 求 得 整个顺序 表 的最大 元

素。求 解子表 中 的 最 大 元 素 的 方法 与 总 表 相 同 , 即 再将它们 分 成 两个更 小 的子表 , 如 此 不 断

aa

分 解,直 到 表 中 只 有 一 个 元 素 为 止(当 只 有 一 个 元 素时 ,该元素 便 是该表 的最大 元 素 )。对应

的递归算法如下:

ElemType Max(SqList L,int iint j)

//求顺序表 L 中 的 最 大 元 素

{

int mid;

ElemType max, maxl ,max2;

让 (i一=一)

// 顺 序 表 中 只 有 一 个 元 素,即递归 出 口

157

数据 结构教程

[第! 5 【版

max一L.data[ji] ;

// 该 元 素 就 是最大 元 素

else

(1 mid一(iTj)/2;

maxl 一 Max(L,i,mid);
max2一 Max(L,mid 十1,j);

// 顺 序 表 中 有 多 个 元 素
// 求中间 位 置
// 递 归 调 用 求 左子表 中 的 最 大 元 素 maxl
// 递 归 调 用 求 右子表 中 的 最 大 元 素 max2

max 一(maxl > max2)?maxl:max2;

// 求 整个表 的 最 大 元 素 max

}

TeturnCmax) ;

532 基于 递归 数据 结构 的递归 算法 设计

具有 递归特性 的 数据结构 称 为递归 数据结构。递 归 数 据结 构 通 常是采用 递归 方式定义

的。在 一 个 递归 数据结构 中总会包含一个 或者多 个递归 运算 。

例如 , 正 整数的定义 为1是 正 整数 ,若是 正 整数 (二 1) , 则 "十1 也 是正 整数 。从中可

以 看 出 ,正整数 就 是一种递归 数据结构。显然, 若羡是 正 整数 (二 1) , 闷 一

扫-归

一1 也 是 正整数,也 就 是 说 ,对 于 大 于 1 的 正整数 wx 一 1 是 一 种递归 运算 。

所以在求 x! 的 算法中,递归体 Fa) = 一2x 2 一1) 是 可行的,因为 对

于 大 于 1

的 zz 和 7 一 1 都 是 正整数 。

一 般情况下 ,对 于 递归 数据结构

RD=(D,Op)

上

视频讲朋

其中,D=(d)

GO所;i过2共7 个 元 素 ) 为 构成 该 数据结构 的所有 元 素 的 集合 ,Op 是递归 运算

的 集合 ,Op 一 {opj} (< 入7 共产 个 运算) 。 对于 wED,不妨设op; 为 一 元 运算 符 , 则 有

opi(di) EDD, 也 就是说 ,递归 运算 具有 封闭 性 。

在 上 述 正整数 的 定义中 ,D 是正整数 的 集合 ,Op= {opl ,op}由两个基本 递归 运算 符 构

一2十1(02二1) 。
成,op 的 定义为opy (2) 王 2 一 1(02 二 1); op; 的 定义为opz(2)

对 于 不 带头结 点 的 单链表 ,其结点类 型为LinkNode,每个结点的 next 域为LinkNode

类 型 的指针 ,这 样 的 单链表 通过 首结 点 指针 来标识。采 用 递归 数据结构 的 定义如 下 :

SL=(D,OPp)

其中,D 是 由 部 分 或 全 部 结 点 构成 的 单 链表 的 集合 ( 含 空 单 链表 ),Op={opl}) ,opi 的 定义

如下:

opl(L) 一 二 一> next

//L 为 含一个 或 一 个 以上结 点 的 单 链表

显然这 个递归 运算 符 是 一元 运算 符,且 具有 封闭 性 。也 就是说 , 若 工 为 不 带头结点的

非 空 单链表,则工 一> next 也 是 一 个不带头结 点 的 单链表 。

实际 上 ,递归 算法 设计 步骤中 的 第 2 步是用 于 确定递归 模型中的递归 体。在假设原问

题 /Cs) 合 理 的小 问题 fCs ) 时 ,需要 考虑递归 数据结构 的递归 运算。例如 ,在 设计 不 带头结

点 的单链表 的递归 算法时 ,通常设 * 为 以工 为 首结 点 指针 的 整个单链表 ,* 为 除 首结 点以外

158

ES5AsSJ着 归 |

余下 结 点 构成 的单链表 (由 工 一> next 标识 ,而该运算 为递归 运算 ) 。

【例 5. 4】 假设有一 个不带头结 点 的 单 链表 工 , 设计 一 个 算法 释放 其 中 的所有 结 点 。

设 FE)的功能是释放 a 一au 的所有 结 点 , 则 7 工 一> next)的功能是释放 as

一 a。

的所有 结 点,如 图 5.

6 所示。假设 太志 一 > next)是可实现的,则 太(EL) 的 功能 是先调用

7( 工 一>next) ,然后释放 工 所 指 的 结 点 。

有站) 释 放m 到 aw 的所 有 结点

工 一=|

一|

症| on | 人

\一|

帮[>nexb释放w到own的所有结点

工 ->next

图 5.6 一 个 不 带头 结 点 的单链表

对应的递归 模型如下 :

(EL) 不 做 任何事件
JCL) EL一>nexb; 释放工所指的结点 其他情况

当 工 =NULL 时

其中,””? 表 示 功 能 等 价 关系。对 应 的算法如下 :

void release(LinkNode * &L)

让 CLI=NULL)

release(L 一> next);

free(L) ;

{

)}

{

}

说明: 在 对 单 链表设计 递归 算法 时 通常采用 不 带头 结 点 的 单链表 。以图 5. 6 为例,

了 一> next 表示 的 单链表 一 定 是 不带头 结 点 的,也 就 是说“小问题"的单链表 是 不带头 结 点

的 单链表 ,所以“大问题 ”(即 整个单链表 ) 也 应设计 成 不带头 结 点 的 单链表 。

所 以 在 设计 递归 算法 时 ,如 果 处 理 的 数据 是递归 数据结构 ,需要 对 该数据结构及 其递归

运算 进行 分析, 从 而 设计 出 正确 的递归 体。再 假设 一种特殊 情况,得 到 递归 出 口 。

533 基于 递归 求解 方法 的 递归 算法 设计

当 求解问题 的方法 是递归 (如 Hanoi 问题)的 或者可 以 转换 成递归 方法

求解时(如皇后问题) ,可以 设计 成递归 算法 。

例如,求 FCozo) 三 1 十 2 十 ... 十 2 全 1) ,这 个 问题可以 转化 为递归 方法 求

ee

解 ,假设“小问题?是 fx 一1)王1 十 2 十 ... 十(2 一1) ,是 可 求 的 , 则 /oo 一 COz 一1) 十2。

对 于 采用 递归 方法 求解的问题 ,需要 对问题本身 进行分析 , 确定大 .小问题 解之间 的 关

系 , 构 造合理 的递归 体 。

【例 5. 5】 采用 递归 算法 求解迷宫问题,并 输出从和人口 到 出 口 的所有迷宫路径。

迷宫问题 在第 3 章 中 介绍过,设 mgpath (Cint xi, int yi,int xe,int ye, PathType

path) 是 求从(xi,yi) 到 (xe,ye) 的 迷宫 路径, 用 path 变量 保存一条 迷宫 路径, 其中 PathType

159

数据 结构教程

[第! 5版

类 型 的声明 如 下 。

typedef struct

{

inti

int j;

}》 Box;

typedef struct

// 方块的 行 号

// 方 块 的 列 号

// 方 块的类 型

{

Box data[MaxSize];

// 存 放 一 条 路径上 的所有 方块

int length;

} PathType;

// 迷 富 路 径 的 长 度
// 迷 富 路 径的类 型

当 从 (xi,yi) 方 块找到 一 个 相 邻 的 可 走 方 块 (四 后,mgpath(i,j,xe,ye,path)表示

求从(7门 到 出 口 (xe,ye)

的迷宫路径。显 然,mgpath(xi,

是“大问题”,
yi, xe, ye,path)

而 mgpath(i,j,xe,ye,path)

是“小问题”“即大问题三试探一步十小问题) 。求 解 上 述 迷 富

问题的递归模型如下 :

mgpath(xi, yi, xe, ye,path) 将 (xi,yi) 添加到 path 中 ;输出 path 中 的迷宫路径;

mgpath(xi,

yi, xe, ye, path) ”对 于 (xi,yi) 四 周 的 每 一 个相邻 方块(i,j): 若(xi,yiD不是 出口且 可 走

若 (xi,yD 一 (xe,ye)即找到出口

@ 将 (xi,yiD添加到 path 中 ;

Q@ mg[x [中 一 一 1;
@ mgpath(i,j, xe,ye, path);
@ path 回 退 一 步 并置mg[xi] [y 品一0;

mgpath(xi, yi, xe, ye,path) 不 做 任何 事情 ;

若 (xi,yiD 不 是 出 口且不 可 走

在 上 述递归 模型中, 当 完 成 “小 问题”mgpath (i,j,,xe, ye, path) 后将 path 回退并 置

mg[xi][y襄为 0(对应轿),其目的 是 恢复 前 面求迷宫 路 径 而 改变的环境 ,以 便找 出所有 的 迷

富 路 径 。对 应 的递归 算法 如 下 :

void mgpath(int xi, int yi, int xe,int ye, PathType path)

// 求解迷 富 路 径 为

(xi,yiD)->(xe,ye)

{

int dik,i,j;

这 (xi 一一xe && yi一一ye)

// 找 到 了 出 口 ,输出 一个迷宫 路 径

{

.ji一xi;
path. data[path.length]

// 将 (xi,yD添加到 path 中

path. data[path.length] .j 一 yi;

path.length十十;

printf("

迷富路径%d如下 :\n" ,十十count);

// 输 出 path 中 的迷宫路径

for (k一0;k< path.length;k 十十)

printf("Nt(%d, 中 d)",path.data[k] .i,path.data[g] .j);

printf(C"\n");

}

else

//Gxi,yiD不是出口

{

庄 Cmg[xj[z宫一一0)

是一个可走方块
//Gxi,yD

{ di一0;

whbile (di< 4)

// 处 理 (xi,yi) 四 周 的 每 一 个相邻 方块(ij)

{

path. data[path.length] .i一xi; //@将(xi,yiD 添加到 path 中

160

PASS着 归 |

path. data[path.length] .j一yi;

path.length十十;

// 路 径 长 度增 1

switch(di)

{

case 0:i一xi一1; j一yi;

break;

case 1:

xii j一yi十1; break;

case 2:i一xi十1; j一yii

break;

case 3:i一xii j一yi一1; break;

}
mg[xi] [7 口一一 1;
mgpath(i,j, xe, ye,path) ;

mg[xi] [y口一0;
path.length 一 一 ;
di十十;

/GOmg[][y一一1
//Q@mgpath(i,j, xe,ye,path)

//@四恢复(xi,yi)为可走
// 回 退 一 个 方块
// 继 续处理 (xi,yiD下 一个相 邻方块

)》

本 算法 输出所有 的 迷宫 路 径,对 于 如 图 5.7(a)所示的迷宫 ,指定和人口 为(1,1),出 口为

(4,4) , 求 出 的所有 迷宫 路 径 有 4 条 ,如 图 5.7(b)所示,可 以通过 比较 路 径 长 度 求 出 最 短 迷

宫 路 径 ( 可 能 存在 多 条 最 短 迷 宫 路 径 ) 。

mw一呈

口访于对谋

路
径
4

一候标珀也

路
径
3

(b) 求 出 的所 有 迷宫 路径

图 5.7 一 个 迷宫 及 其所有 的 迷宫 路 径

一 本章小结 一一一

本 章 的 基本 学 习 要 点 如 下 ;

(1) 理解递归 的 定义和递归 模型。

161

数据 结构教程

[第! 5人版

(2) 理解 递归 算法 的 执行 过程 。

(3) 掌握 递归 算法设计 的 一 般 方法 。

(4) 灵活地 运用 递归 算法解决 一 些较 复 杂 的应用问题 。

1. 有以 下递归琢数:

void fun(int n)

{

让 Cn 一一1)

printf("a: %d\vn",n);

else

{

printf("b:%dvn",n);

funCn 一1);
printfC"c: %dNvn" npn);

)》

分 析 调 用 fun(5)的输出结果。

2. 已知 A[0..2 一 菇 为 整数数组,设计 一 个递归 算法 求这?个

元 素 的平均值。

3. 设计 一 个 算法 求 正 整数, 的 位 数 。

4. 上 楼 可以 一步上 一 阶 , 也 可以 一步上 两阶, 设计 一 个递归 算法 ,计算 共有 多 少 种不同

的 走 法 。

5. 设计 一 个递归 算法 ,利用顺序 串 的 基本 运算 求串* 的 逆 串 。

6. 设有一 个 不带表 头 结 点 的单链表 工,设计一个递归算法count(CL)求以工 为 首 结 点 指

针 的 单 链表 的 结 点 个 数 。

正向输出单链
7. 设有一 个 不 带 表 头 结 点 的 单链表 工 , 设 计 两 个递归 算法 ,traverse(L)

表 工 的所有 结 点 值,traverseR(EL)

反向输出单链表工 的所有 结 点 值 。

8. 设有一 个 不 带 表 头 结 点 的 单 链表 工 , 设 计 两 个递归 算法,del(CL,z)

删除单链表 工 中

第 一 个 值为zx 的 结 点,delall(L,z)

删除单链表工 中所有 值为z 的结 点 。

9. 设有一 个 不 带 表 头 结 点 的 单链表 工 , 设计 两 个递归 算法,maxnode(L)

返回单链表工

中 的 最 大 结 点 值,minnodel(L)

返回单链表工 中 的 最小 结 点 值 。

10. 设计 一 个 模式匹配 算法,其 中 模板 串 :含有通配符 '*

'", 它 可 以 和任意子 串 匹配。

对于目标串*, 求其中 匹配模板 : 的 一 个子串 的 位 置 ('* 不 能 出 现在: 的 开头和末尾) 。

驶验证性实验

实验题 1: 采用 递归和 非递归 方法 求解 Hanoi 问题

目的: 领会基本 递归 算法 设计和 递归 到 非递归 的 转换方法 。

内 容 , 编写 程序 exp5-1. cpp,采 用 递归 和 非 递归 方法 求解 Hanoi 问题 ,输出 3

个 盘 片 的

162

EX5AsSZ 着 归 |

移动过程。

实验题 2: 求 路 径 和 路 径 条 数问题

目的: 领会基本 递归 算法 设计 和 递归 执行过程 。

内容: 编写 程序exp5-2. cpp, 求 路径和 路 径 条 数 问题 。有 一个记 X7的网格,图5.8 所

示 为 一 个2X5 的 网 格。现 在 一个机器人 位 于左上 角 ,该 机器人 在任何 位 置上时 只 能向下 或

者 向右移动 一 步 ,问机器人 到 达 网 格 的右下 角 (1,1) 位 置的 ,5)

所 有 可 能 的 路 径 条 数 ,并 输出所有 的 路 径 。以 关一2, 一 2 为 世
例 说 明 输出 所 有 的 路 径 的过程 。
从设计 性 实验

避 可 ,,
)

实验题 3, 恢复 IP 地址

图 5.8 一 个2X5 的 网 格

目的: 掌握基本 递归 算法 设计 。

内容: 编写 程序exp5-3. cpp, 恢 复 IP 地 址。给 定 一 个 仅仅 包含数字 的 字符 串 ,恢复它

的所有 可 能 的有效 IP 地 址 。例 如 ,给 定 字符 串 为 "25525511135"

,返回"255. 255. 11. 135"

和 "255. 255. 111. 35"( 顺 序 可 以任意 ) 。

实验题4: 高 效 求解 立

目的: 掌握基本 递归 算法 设计 。

内 容: 编写 程序exp5-4. cpp ,高效 求解 阅 ,要求最多使用O(logz)次递归调用。

实验题$:

用 递归 方法 逆 置带头 结 点 的 单 链表

著正

的: 掌握单链表 递归 算法 设计 方法 。

容: 编写一个程序exp5-6. cpp, 用 递归 方法 道 置一个 带头 结 点 的单链表 。

实验题6: 用 递归 方法求单 链 表 中 的 倒数 第 大 个 结 点

著下

的: 掌握 单链表递归 算法 设计 方法 。

容: 编写一个程序exp5-6. cpp, 用 递归 方法 求单链表 中 的 倒数第 & 个 结 点 。

入司

合性实验

实验题7: 用 递归 方法 求解慰皇 后问题

目的: 深入 掌握递归 算法 设计 方法 。

内 容: 编写一个程序exp5-7. cpp, 用 递归 方法

求解六皇后 问题 ,对 皇后 问题 的描述 参见

第 3 章 的实验题8。

实验题8: 用 递归 方法 求解0/1 背包问题

目的: 深入 掌握递归 算法 设计 方法 。

内 容: 编写一个程序exp5-8. cpp, 用 递归方法求解0/1 背包 问题 。0/1 背包 问题是, 设

有 不 同价值.不同 重 量 的 物品 件 , 求从这 交 件 物品中 选取 一 部 分 物品 的 方案 ,使 选中物品

的 总 重量 不 超过 指定 的 限制重量 态 ,但 选中物品 的 价值之和 为 最 大。注 意 ,每种物品 要 么

被 选中 ,要 么 不 被选中 。

163

数组 (array) 是 具有 相同 类 型 的 数据 元 素 的 有限 序 列 ,

可 以 将 它

看作 是线性 表 的 推广, 稀疏 矩阵 是 一 种特殊的二维数组。广义表也

可 以 看 成 是 线性 表 的 推广,

它 是 采用 递归 方法 定义 的 。

本 章 介绍 数组 稀 朴 矩 阵 和 广义 表 的 存储 结构 及 相关 算法

设计。

6 人7放。。。。。 歼组Dr广x表 |

数

组

米

611 数组的基本概念

从 逮 辑 结构上 看 ,一 维 数组 A 是”(z 二 1)个相同 类 型数据元素 wa ,

am...an 构成的有限 序列,其 逻辑 表示 如 下 :

A 一 (alyaz,...an)

视频讲解

其 中 ,ai 和 过 7) 表示 数组A 的第; 个 元 素 。

一 个 二 维 数组 可以看作 是 每个数据 元 素 都 是相同 类 型 的一维 数组 的 一 维 数组。依此类

推 ,任 何 多 维 数组都 可以看作 一 个 线性 表 ,这 时 线性 表 中 的 每个数据 元 素 也 是 一 个 线性 表 。

推广到 dd 三 3) 维 数组 ,不 妨 把它看 作 一 个 由 4d一 1 维 数组 作为 数据 元 素 的 线性 表 ; 或

者 可以 这 样 理 解,它 是 一 种 较复杂 的 线性结构,由 简单的数据 结构 ( 即线性 表 ) 思 转 合成 而

得。所以 说 数组 是线性 表 的 推广。在 4 维 数组中 ,每个元 素 的 位 置由 & 个整数的d 维 下 标

来标识 。

< 维数组的抽象 数据类 型描述如下 :

ADT Array
{ 数据对象:

也 一 (ai | 庆 二1012 // 第 i 维 的长度 为 访

数据 关系 :

下 一 人 mra ,ra
六 二八国 > |

基本 运算 :

1 委 关 和和 ,14 且 4 天 i1 委 关切 一

1,i2..., 直

initarray(&A) : 初始化数组 , 即 为数组 A 分配存储空间

Destroyarray( 芷A) : 销毁 数组 , 即 释放 数组 A 的 存储 空间

Value(A,index ,indexs

,...,indexz): A是已存在的df 维 数组 ,indexi ,indexz ,... ,indexs 是 指定 的

维

下 标 ,这 些 下 标 均 在有效 范围内.其

运算 结果 是 返回由 该下标指定的A 中 的 对 应 元 素

的值

Assign(4A,e,indexi ,index ,...,indexs): A 是 已存在的4d 维 数组,e 为 元 素 变量 ,index \index 、...、

indexs 是 指定 的 qd 维 下 标 ,这 些 下 标 均在有 效 范围内.其 运算 结果 是将。 的 值 赋给A 中 由
该下标指定的元素

从 上 可以 看 出 ,数组除了 初始 化 和 销毁以外 ,在 数组中 通常只有 下 面 两种操作 。
。 读 操作 : 给 定 一组 下标,读 取 相 应 的数组 元 素 。
。 写 操作 : 给 定 一 组下 标 ,存储或 者 修改相应 的 数组 元 素 。

aa

几乎所有 的 计算 机 高 级 语言 都 实现了 数组 数据 结构 ,并 称 之 为 数组类 型 。这 里 以

CVC++ 语 言 为例, 其 中 数组 数据 类 型具有以 下 性 质 :

(1) 数组中的数据元素数 目固定, 一旦 定义了 一 个 数组 ,其 数据 元 素数 目 不 再有增 减 的

变化。

《2) 数组中的 数据 元 素具有 相同 的 数据 类 型 。

数据 结构教程

[第! 5版

(3) 数组中的 每个数据 元 素都和 一组 唯一 的 下标 对 应 。

(4) 数组 是 一种随机 存储 结构 ,可 随机 存 取 数组中 的任意 数据元 素 。

因此 ,用 户 可以 在 C/C++ 程 序 中 直接 使用数组 来存放 数据 ,并 使用数组 的 运算 符来完

成相应的功能。

【例 6. 1〗 利用 数组 求解约瑟夫 问题: 设有交 个人站 成 一圈, 其编号为 1 一2。 从 编号

为 1 的人开始 按 顺时 针 方向“1,2,3,4,...?”

循环报数,数到关 的 人 出 列 ,然后 从 出 列者的 下

一个人 重新 开始 报 数 , 数 到 闷 的人又 出列 , 如 此 重复 进行,直到 允 个人都 出 列 为 止,要 求 输

出 这 交 个人的 出列顺序 。

例如 ,有 8 个人的 初始 序列 为

12345678

当疡=4 时,出列顺序为

48521376

采用一维数组 并 ] 存 放 人 的 编号 ,先 将 郊个人 的 编号 存人到 思 [0] 一zLz 一 匡 中。从

编号为1 的人(下标 :二 0) 开 始循环 报 数 , 数 到 2 的人思 [ 门(下标 :二(十一1) %庆表示当

前 未 出列 的人数 ) 输 出 并 将其从 数组 中 删除 (即将 后 面 的元 素 前 移一个 位 置) ,因此 每 次 报 数

的 起 始 位 置 就是上 次 报 数 的 出 列 位 置 。反 复 执行 直到 出列 ,个人为止。算法如下:

void josephus(int n,int m)

{

int p[MaxSiza;

int i,j,t;

for (Ci一0;i<ni;i十十)

// 构 建 初始 序列(1,2,...,n)

p口一i十1;

t 一 0;
出列顺序:");
printf("
一1;i一一)
for (i=nii>=

{ t=(t+m一1)%i

printf("%d ",p[昌);
一i一15j十十)
for (一 t+1;j<

pD 一 忆 =p虽;

》}》

printfC"N\n") ;

}

// 首 次 报 数 的起始位置

//i 为 数组 p 中 当前 的人数 ,出 列 一 次,人 数减 1

//t 为 出 列 者 的 编号
// 编 号 为 的 元 素 出 列
// 后 面 的元素前移 一个位 置

EEEEE

需要注意 的是,本 章 的 数组是作为一种 数据结构讨论 的 ,而 C/C++ 中 的数组是一种数

据类 型 ,前者可 以借助后者来存储, 像线性表 的 顺序 存储结构 ( 即 顺序 表 ) 就 是借助一维 数组

这 种 数据类 型 来 存储 的 。但 二 者 不 能混淆 。

612 数组的存储结构

在 设计 数组 的 存储 结构时 ,通常将数组 的所有 元 素 存储 到 存储 器 的 一

块地址连续的内存单元中, 即 数组特别 适合 采用顺序 存储 结构 来存储 。

扫-- 扫

时

视员if邮

166

[第人6 人章 忆

ET

对 于 一 维数组Ca ,az ,...',,a,...,,a),

按元素顺序存储到一块地址连续的内存单元中。

假设第一个元素 wm 的存储地址用 LOC(ai ) 表示 ,每个元素占用 & 个 存储单元 , 则任 一 数组

元素 ui 的存储地址LOC(a;)即可 由以 下公式求出:

) 十G一1) X
LOCCai) = LOC(Ca

(2 去 ;过 四

(6.1)

该式说 明 一 维 数组中任 一 元 素 的 存储 地 址 可 直接 计算 得 到 , 即一维 数组中 的任 一 元 素

可 直接 存 取 , 正 因为如 此 ,一 维 数组具有 随机 存储 特性 。

2 二 从数组的存储结禁

对 于 一个闷 行 怀 列 的 二 维 数组Aux,:

将 Aux,简记 为 A,A 是 这 样的一 维 数组 :

aa

A=(A AAA)

其中,A;=王(aai an) (1 所;过加)

对 于 二 维 数组 来说,其 存储 方式主要 有 两 种 ,即 按行优先 存放 (或 者 以 行 序 为 主序存放 )

和 按 列 优先存放 (或 者 以 列 序 为 主 序 存 放 ) 。

1) 二 维 数组 按行优先存放

二 维 数组 按 行优先 存放 的 示意 图 如 图 6. 1 所 示 , 即 先存储第 1 行,紧 接着存储第 2 行 ......

依此类 推,最后存储第 王行。

|

|

|

an

ov | 共产1 行 ,(-Dxz个元素

or

...|

ao 第 z行 中前面有(广D)个元素

世

aa |

Gas |

|

ai

oa|

an1|an2 |

|

|

几

aa 0410 0 0

1

第 1行

第 2行

第 ; 行

第六行

图 6.1 二 维 数组 按 行优先存放 的 示意 图

ws

假设第一个元素 ac 的 存储地址用LOC(ai,t) 表示 ,每个元素占用4 个存储单元,则该

二 维 数组 中 的任 一 元 素 civ 的 存储地 址 可 由 下 式 确定 :

LOCCai) = LOCCa) 十 [G一1) X2 十GO 一1)]XA

(6.2)

上 式 推 导 的 思路 是 ,在 内 存 中 元素 ov 前面有 ii一 1 行 , 每行2 个 元 素 ,即 已 存放了

(一 1) X7 个 元 素 ,占用了 (一1) XzX& 个 内存单元; 在第 守行中元 素 aiv 前 面有7 一 1 个元

素 ,即 已 存放了 7 一1个 元素, 占用了 G 一1) XA 个 内 存单元; 该数组是从基地址LOCCa)

167

数据 结构 教程

虹 第人5 【版

开始 存放 的 。所以 ,元素 cv 的 内 存 地 址 为上述 3 个 部 分之和 。

以 上讨论 假设二 维 数组 的 行 , 列下界为1。 在 更 一 般 的 情况 下 ,假设二 维 数组 的 行下界 是

cu,行上界是由 ,列 下界是c,

列 上界是 心 ,即 数组AL .di cz.ds]@,则式(6. 2) 可改写为:

LOCCa) = LOCCaae) 十 LG 一 c)X(ds 一c十 1) 十 (一 c)]X

(6. 3)

2) 二 维 数 组 按列 优先 存放

当 二 维 数组 采用以 列 序 为主序 的 存储 方式时, 先 存储 第 1

列 , 紧 接着 存储 第 2 列 ,......依

此 类 推 , 最后存储第” 列。

与式(6.2) 的推导 过 程相似 ,得 出以 列 序 为主序的存储 方式下 元 素 cv 的 存储地址可由

下 式 确定 :

LOC(Cai) 二 LOC(Ca) 十 [LOG 一1) 久 六 十 G 一1)] 勾 人

(6. 4)

同样 ,在 更一般 的 情况下 ,假设二维 数组 的 行下界是c , 行上界是w ,列下界是 c ,列 上

界是4 , 则 式(6.4) 可 改写为:

LOC(Cay) = LOCCaae) 二 LOG 一 c) X(d 一 c 十 1 十 (一 c)]X

(6.5)

从 中 可以 看出,二 维 数组 无论按行 优先存储 还是按 列优先存放 存储 ,都 可以在O(1) 的

时间内 计算 出 指定 下标 元 素 的存储 地 址 ,体现出随机 存储特性 。

可以 将 以上二 维 数组 存储 方法 的 思路 推广 到 三 维 数组和 更 高维数组 。对 于 高 维 数组 , 按

行优先 存储 的 思路 是 最 右边 的 下标 先 变化 , 即 最右下标 从 小 到 大 ,循环一遍 后 ,右边第二个下

标再变化 ,......, 依 此 类 推,最 后是最 左下标。按 列 优先 存储 的 思路 是 最 左边 的 下标 先 变化 , 即

最 左下标 从小 到 大 ,循环一遍 后 ,左边第二 个 下标 再 变化 ,...',依 此 类 推,最 后 是 最右下标 。

613 特殊矩阵的压缩存储

特殊矩阵是指非零元 素 或零元 素 的 分 布有一 定 规律 的 矩阵,为了节省 存储 空间 ,特别是在

高 阶矩阵 的情况下 ,可以利用 特殊 算 阵 的 规律 对 它们 进行 压缩存储 ,以 提高存储 空间 效率 。

特殊矩阵 的主要 形式 有 对 称 和 矩阵、 对 角 拖 阵 等 。它们 都 是 方阵, 即行数和 列 数 相同 。

若 一 个 半 阶 方阵4[z[四中的 元 素 满足 cv 一 ass(0 二 zi 入 2 一1), 则 称 其 为 阶对称矩

阵 (symmetric matrix)。

一 般 情 况 下 ,一 个 冯 阶 方 阵 的所有 元 素 可以 分 为 3 个 部 分 ,即主 对 角 部 分 ( 含 个元

素 )、上 三 角 部 分和下 三 角 部 分 ,如 图 6.2所示。已 知 一 个 元 素 的 下标 ,就 可以 确定 它 属 于 哪

个 部 分 。

对 称 和矩阵 中 的 元 素 是 按 主 对 角 线 对 称 的 ,即 上 三 角 部分和 下 三 角 部分中 的 对 应 元 素 相

等,因此 在 存储时 可以 只 存储主对 角 线 加 上 三 角 部 分 的 元 素 , 或 者主对 角 线 加 下 三 角 部 分 的

元 素 ,让 对 称 的 两 个元素 共 享一个 存储 空间 。

不 失 一 般 性 ,对 称 矩阵采 用 以行 序 为 主序存 储主 对 角 线 加 下 三 角 部 分 的 元 素 。如

图 6. 3 所 示 ,假设以一维数组B[0..z(z

十1)7/2一1作为半 阶 对 称 和矩阵4 的 存储 结构 ,4 中

的 元 素 aiv存储在已 中 的 元素2 中 ,那么4与 ;ij) 是 什么关系呢? 分 为 以 下 两 种 情况 :

Q@ A[c..di,cz..d?]表示数组 A 的 行 号从cl 到 cs , 列号从 由 到 do 。 例如 ,由于 CVC++ 语 言中规定 数组下 标从 0 开

始,所以A[z]数组可以表示为AL0..mm

一可,A[z][m]或 AL 站 数组 可 以 表示 为 A[0..mm 一1,0..n 一 匡 。

168

[第人6 人章 忆

数组和广义表

上 三 角 部 分 元 素 ov : <

下 三 角 部 分 元 素w: z>7

主 对 角线部 分元素 o 记/

图 6.2 一 个 交 阶 方 阵的3 个 部 分

1

| aiDs

1

1 010
,

aol

和

ne

En

ao ml

QUmrl

才 :

1 ij 人
本
1

本

1

Qnr10

Go-L1

加

人 四

行下标为。行下标为

0的行: 1
个 元 素

1的行: 2
个 元 素

国史

也 本

行 下标 为 一 1 的
行: 认 元 素

行 下 标 为葛行:ov
前 面有/个元素

000

00 9 和 9001 和 GOrF 人 001 019 00 or

有 站 本 本

图 6.3 ”对称 和矩阵的压缩存储

(1)

若 ou 是 4 中 主 对 角 线 或者下 三 角 部 分 的 元 素,有 ;全)。 在以行序为 主序的存储 方

式 下 不计 行 下标 为 ;的行,元素 civ 的 前 面共存储了 ; 行 (行 下标为 0 一;一 1, 行 下标为0 的

行有一 个 元 素 , 行 下标 为 1 的 行有两 个 元 素 ,...,行 下标为;一1 的行有 ;i 个 元 素), 这 守 行有

1 十 2 十 ...

十;一 2zG十1)/2 个 元 素 ; 在行下标为z 的 行中,元素 aiv 的 前 面 也 存储了 7 个 元 素 。

所 以 元 素 civ 的 前 面 共存储了 ;zi 十1)/2 十) 个 元 素 , 而 数组 的 下标 也 是从 0 开始的,所 以

有AR&=iG十1)/2十7 。

(2) 若是4 中 上 三 角 部 分 的 元 素,有 i<) 。其 值 等于 w 而 元素 ws 属于 情况(1),

它 存放 在 刀 中 下标 为7G 十1)/2 十 z 的 位 置,所以 此时有 A 一7G 十1)/2十i。

将 两种情况 合 起来 ,得 到 & 与 ij) 的关系如下:

二 了 十

太一

7 十 TD

2

(6.6)

an

显然 ,一维数组 妃 中 存放 的 元 素 个 数 为 1 十 2 十 ... 十 2一zz 十1)/2。如 果 4 直接 采用 一

个 守 行闻列的二 维 数组存储 ,所 需要 的 存储 空间 为 好 个 元 素,所以 这 种 压缩存储 方法几乎

节省 了 一 半 的 存储 空间。另 外 ,由 于 一 维 数组 B 具有 随机 存 取 特 性,所以 采用 这 种 压缩存

储 方法后对 称 矩阵 4 仍然具有 随机 存 取特 性 。

归纳起来,在计算 4 中 元 素aiv 在 也 中存储位置A 时 ,首先求出元素 av 前 面共存放多

169

数据 结构 教程

虹 第人5 【版

少 个 元 素 ( 设 为冯个); 再看 召 中 存放 元 素 的 下标 是从 0 开始还是从 1 开始(设 召 的 初始下

标 为>) , 则 &一闷十s。

2 下 二 朋 征件 的 不信和 存依

所 谓 上 三 角 矩 阵Cupper triangular matrix) ,是 指 和矩阵 的 下 三 角部 分 中 的 元 素 均为常数

< 的 阶 方 阵。同 样,下 三 角 矩 阵(lower triangular matrix) 是 指 和矩阵 的上三 角 部 分 中 的 元

素均为常数 c 的”阶 方阵。

对 于 上 三 角 和矩阵,其压缩 存储 方法是采用 以行 序 为 主序存 储 其主对 角 线加 上 三 角 部 分

的 元 素 , 另 外 用 一 个 元 素 存 储 常数 c, 并 将 压缩 结果 存放 在一维 数组 正中 ,如 图 6.4 所示。

显然,B 中 元 素 的 个 数 为 (2z 十1)/2 十1,即用 BL0..zC2z

十1)72]存放 4 中的元素。

Go0,0

Go,1

ol

行 下标为 0 的 行 下标为 1 的 行下标为天的 行 下标为的 行: ay
行: 个 元 素 行: zx-1个元素 ”行: z 一 线 1 个 元素 前面有广 ;个 元 素

0001 和 Go 1

gr OP

Be

站

图 6.4 上 三 角 抢 阵 的 压缩存储

同样,4 中 元 素 aiv 存 储 在 3 的 元 素 六 中 ,那么&与 ;是 什么关系 呢 ? 这 里 也 分 为如

下 两 种情况:

(1) 若 aiv是4 中 主 对 角 线 或者上 三 角 部 分 的 元 素,有 ij过) 。 在以行 序 为主序 的存储 方

式 下 不计 行 下标 为 ;的行,元素 civ 的 前 面共存储了 ; 行 (行 下标为 0 一;一 1, 行 下标 为 0 的

行有 7 个 元 素 , 行 下标 为 1 的行有 7 一 1 个 元 素 ,...,行 下标 为 ;一1 的 行有7 一;十 1 个 元 素 ),

这 守 行有 7 十(2 一1) 十 ... 十 (2 一;十 1) 一 ;22 一 ;十1)72 个 元 素 ; 在 行 下标

为站的 行 中 ,元素

ai 的 前 面 也 存储了 7 一; 个 元 素。所以 元 素 aiv 的 前 面 共 存储了 ;22 一 上 十1)/2 十 7 一 个 元

素,而也数组的下标也是从 0 开始的,所以有& 一 ziC272一;十1)/2 十 7 一i。

(2)

若 ov是4 中 下 三 角 部 分的元 素,有 ; 盖) 。 其 值 为 常数 c, 用 忆 中 最 后一个 位 置 ( 即

下 标为zz十1)72 的 元素) 存 放 常数 c。

将 两种情况 合 起 来 ,得 到 & 与) 的关系如下:

并2 二

一

72 十 1)

2

ii

(6.7)

对 于 下 三 角 和 矩阵4, 其 常见的压缩存储 方法是采用 以行 序 为 主序存 储 其主对 角 线加 下

三 角 部 分 的 元 素 , 另 外 用 一 个 元 素存储 常数 ,并 将 压缩结果 存放 在 一维数组 中 中 ,采用类

170

PEA6A刘7放 。。。。。 歼组Dr广x表 |

似 于 对 称矩阵 的推导 过 程,得 到 A 与 的关系如下 :

2 十 1)

于 二 7

4

2 元

i 一

(6.8)

若一个 妈 阶 方阵4 满足 其所有 非零元 素 都集中 在以主对 角 线为中 心 的 带状区 域中 , 则

称 其 为交阶 对 角 和矩阵(diagonal matrix) 。其 主对 角 线上\、下 方各有 4 条 非零元 素 构成 的次对

角 线 ,称2 为 矩阵半 带 宽 ,(20 十 1) 为 矩阵 的 带宽。对 于 半 带 宽为 00 丢 0 甩 (2 一1)/2) 的 对 角 拢

阵 , 其 | ;一 让 甩2 的 元 素 iv 不 为 零 , 其余元 素 为 零 。图 6. 5 所 示 为 半 带 宽 为上的对角 和矩阵示

意图。

对于2=1 的 三 对 角 和矩阵,只 存储 其非 零 元素,并 存储 到 一维数

组 已中,将4的非 零 元素aiv 存 储 到 已 的 元 素 六 中。

4 中行下标为0 的行和行 下标为一1 的 行都具有 两 个非零元

素 , 其 余 各 行有 3 个非零元 素 。

对 于 行 下标 不为0 的非 零元素 iv 来说,在 它 前 面 存储了 和 拢阵 图 6.5 半 带 宽 为5的

的 前 ;和 行元素 ,这 些 元 素 的 总 数为 2 十3(i一1) 。元素 aiv 在 行下标 对角和矩阵

为:的 行(本 行)中 分 为 3 种 情况 :

(1) 若 ov 是 本 行中的 第 1 个非 零 元 素 , 则 4=2 十3Gi

一1) 一3i 一1, 此时 7 一:一 1,即人

2 十 ;一1一 2 十7。

(2) 若 wj 是 本 行 中 的 第 2 个非 零 元 素 , 则 &

一 2 十3G

一1) 十1一3i, 此 时 z

一 六即A

2 十;一 2 十7。

(3) 若 ai 是 本 行中的 第 3 个非零元素, 则

一 2 十3(G 一ID) 十 2一3i 十1, 此 时 7 一:十1,即

& 一 2 十 ;十 1 一 2 十 7 。

归纳 起 来有 & 一 27十7。

以 上讨论 的 对 称 和矩阵、 三 角 和 矩阵、对 角 和矩阵 的 压缩存储方法 是 把 分 布有规律的特殊 元 素

( 值相同 元 素 、 常 量 元素) 压 缩存储 到 一 个 存储 空间 中 ,这样 的 压缩存储 只 需 在 算法 中 按 公式

做 映射即 可 实现 特殊矩阵元素的随机 存 取 。

当 一 个 阶 数 较 大 的 矩阵中 的非 零元素 个数 * 相对 于 矩阵 元 素 的 总 个 数

! 非常小时 , 即 *<<z 时 , 称 该矩阵为稀 朴矩阵(sparse matrix)。 例如一个

100X100 的 矩阵, 若 其 中只有 100 个非零元 素 ,就可 称 其为稀 朴 矩阵。

稀 朴 矩阵和 上 一 节 介绍 的 特殊 矩阵 相 比有一个明显 的 差异: 特殊矩阵
中 特殊 元 素的分 布具有 某 种 规律 ,而 稀 朴矩阵 中 特殊 元 素 (非 零元素 ) 的 分

视频讲解

布 没有规律 ,即具有 随机 性 。

171

数据 结构 教程

[第! 5人版

稀 琉 矩阵抽象 数据类 型与 Cd= 2)维 数组抽象数据 类 型 的 描述相似,这 里 不再介绍 。

621 稀 玻 和矩阵的三 元组表示

不 同 于 前 面讨论 的特殊 矩阵 的压缩 存储方法 , 稀 玻 矩阵的压缩存储 方法是只 存储非零

0010000
0200000

Arc 50 30 09,
ooo0o6oo

00000714

图 6.6 稀 朴 矩阵4

元 素。由 于 稀 玻 矩阵 中非 零 元素的 分 布 没 有任何规律,所

以 在 存储非 零元 素时 必须 同时 存储 该非 零元素对 应 的 行 下

标 ` 列 下标和 元 素 值 。这 样称朴 矩阵中 的 每一个非 零元 素
由 一 个 三元 组(ij ,ai ) 唯一确定 , 稀 朴 矩阵中 的所有 非 零
元 素 构成 三 元组 线性 表 。

假设有一 个6X7 阶 稀 疏 矩阵 4,4 中 的元 素如图 6.6

则 对 应 的 三 元 组 线性 表 为 :

所示 。

(5,6,4))
((0,2,1),(1,1,2),(2,0,3),(3,3,5),(4,4,6),(5,5,7),

若 把 稀 朴 矩阵 的 三元 组 线性 表 按 顺序 存储结构 存储 , 则 称为稀 朴 矩阵 的 三元组 顺序 表 ,

简称为三元组表(list of 3-tuples) 。 三 元组 顺序 表 的 数据 类 型 声明 如 下 :

# define M < 稀 朴 矩阵行数 >

# define N < 稀疏 矩阵列 数>

# define MaxSize < 稀 玻 矩阵中非零元 素最多 的 个数>

typedef struct

{

intri

int ci

ElemType di;

} TupNode;

typedef struct

{

int rows;

int cols;

int nums;

//行号

//列 号

// 元 素 值

// 三 元组 类 型

//行数

// 列 数

// 非 零 元 素个数

TupNode data[LMaxSize] ;

TSMatrix;

// 三 元组 顺序 表 的 类 型

其中,data 域中表示 的非 零元 素 通常以行 序 为 主序 排列 , 即 为 一种下标 按 行 有 序 的 存储 结

构。例 如,前面的稀玻矩阵 4 对 应 的 三 元组 表示 如 图 6. 7 所 示 。 这 种 有序 存 储结构 可 简化

大 多 数 稀 玻 矩阵 运算 算法,下 面 的 讨论 都 假设data 域 是 按 行 有序 存储 的 。

ccwc=

cc=cc=nmb=

cc===-

oowococ=

==oc=n==

===--==

oooce==

四w+lwobl-l=|=-

auw|lwl=l-leb

上|wolebl=-

图 6.7 稀 朴 矩阵 4 对 应 的 三 元组表示

172

视频讲解

EXA6A刘7。 歼组DrXx表 |

稀 朴 矩阵 的 运算 包括矩阵 转 置 .矩阵 加 \ 和矩阵减和和矩阵乘 等,这 里 仅 讨 论 一些基本 运算

算法。

人 人 个一全 入 放生 什 人 于 其 一 亏 绍 表 丰

采用 以行 序 为主 序 的 方式扫描 二 维 稀 朴 矩阵 4, 将其中 非零的 元 素 依 次 插入到 三 元组

顺序表上 中。 算法如下:

void CreateMat(TSMatrix &t, ElemType ALMJ [IN)

{

intij;

t.TOws一Mi t.cols王Ni t.nums一0;

for (i一0;i<

Mii 十十)

{

for G=0;j<N3;j 十十)

计 (A口蕊!一0)

// 只存储非零元素

t.data[t.nums] .r一iit.data[t.nums] .c一j;

t.data[t.nums] .d王ADD ;:t.nums 十 十 ;

{

】}

】}

该 运算 就 是对于 稀 玻 和 矩阵4执行4[订[让=z(z通常是一个非零值 ) 。先 在 三 元 组 顺

序表 :上 中 找到 适当 的位 置上,如 果 该 位置对 应 一 个非 零元素 , 将其 & 数据域修改 为z; 否则

需要 插入 一 个非 零元素 , 将 &~上 nums一1 的 元 素 均后移一个 位 置 ,再将非 零 元素z 插 和人到

L. data[A]处。算法如下:

bool Value(CTSMatrix &t, ElemType x,int i,int j)
{ intk一0,kl;

ii>一t.rows |‖ j>一tcols)

return false;

/ij 参数 超 界

// 返 回 假

while (k<t.nums 区 &i>t.data[k].r) k 十十 ; //查找到第 i 行的第一个非 0 元素

while (k< t.nums &&i一一t.data[k].r &&j>t.data[k].c)

上 十 十 ;

// 在 第 i 行 的 非 0 元 素 中 查找 第 j 列

让 (t:data[问 .r 一 一 &&& tdata[同.c 一 一i)

// 若存在这样的非 0 元 素

t. data[k].d一xi

// 修 改非 0 元 素 值

// 若 不 存在 这 样 的 非 0 元 素

for (kl一tnums一1;kl >一k;kl一一)

// 若干元素均 后 移 一个位 置

else

{

{

tdata[kl十 ].r=

一 t.data[kl].r;

十]].c一t.data[kl].c;
t. data[kl

十]].d一t.data[kl].d;
t. data[kl

}
t. data[国 .rz一iit'data[问 .c=jit'data[
t. nums十十;

问.d=x; // 插 入非 0 元素x

Sa

//非 0 元 素个数 增 1

/成功操作后返回真

}
return true;

】}

3 将指定 位 着 的元素值岂结 妆 重

该运算 就是对 于 稀 朴 矩阵4 执行z一人 [Ci[7],即提取人4 中 指定 下标的 元 素 值 。先 在 三

173

数据 结构教程

(第5 【版

元组顺序表: 中 查找 指定 的 位 置,若 找到 了 ,说 明 是 一 个非零元 素 ,将 其 值赋给 z; 否则说明

是零元素,置 zx 一0。 算法如下 :

bool Assign(TSMatrix t,ElemType &x,int i,int j)

{ intk一0;

让 (i>一trows | j>一tcols)

return false;

//参数超界

// 返 回 假

while (k< t.nums 中 &i> t.data[k].r) k十十;

// 查 找 第 i行

while (k< t.nums &&i王一t.data[k].r &&j>t.data[k].c)

十十;

// 在 第 i 行 的非 0 元 素 中 查找第j 列

这 (t:data[g] .rz一 一

路 & tdata[同.ce一 一i)

// 若存在这样的非 0 元素

x 一 t.data[k] .d;

// 提 取 元 素 值

else

X 一 0;

Teturn true;

// 若 不存在 这 样 的非 0 元素

//置x 为 0

// 成 功 操作 后 返回 真

该运算 从 头 到 尾 扫描 三 元组 顺序 表 上 ,依次输出元素值。算 法如 下 :

void DispMat(TSMatrix t)

{

intk;

让 (tnums<一0)

// 没 有非 零 元素时 直接 返回

Teturn;

PrintfC"Nt%dNt

吧dt吕

dAn",t.rows,t.cols,t.nums);

Printf("Nt 一一 一一 一一一 一 一一一一 一一一 一 一一\n");

for (k=0;k<t.nums;k十十) ,// 输 出所有 非 0 元 素

printfC"Nt%dNt%dNt%dNn",t.data[k] .r,t.data[k].c,t.data[k] .d);

一 入 这 年件共 阁

该运算对于一 个痉X7 的 稀 朴 矩阵4wxv, 求 其转置 矩阵B,xw 即 0 二ai其中0 过 过

1 一 1,0< 5 入 2 一 1。采 用 的 算法思路是4 对应 的 三 元 组 顺序 表 为 ,其转置矩阵吾对 应 的 三

元组顺序表为tb。 按 v 一0,1,......',. cols 在 上中找列号 为 的 元 素 , 每 找到 一 个 这 样 的 元 素 ,

将行 、 列 交换 后 添加 到 tb 中。算法如下,

ee

void TranTat(TSMatrix t,TSMatrix &tb)
{ intk,kl一0,vi;

tb.rows一 t.cols;tb.cols一 t.rowsitb.nums一 t.nums;

//kl 记录 世b 中 的 元 素 个 数

这 (tnums!一0)

// 当 存在非 零 元素时 执行转置

{

for (v=0;iv<t.colsiv十十)

//按 v=0、1、...'\t'cols 循环

for (k一0;k<t.nums;k十十)

/人 用 于 扫描 t. data 的所有 元 素

让 (t.data[k] .c 一 一v)

// 找 到 一 个 列 号为 的 元 素

{

tb.data[kl].r=t.data[k].c;

// 将 行 、 列 交换 后添加 到 tb 中

tb. data[kl].c 一 t.data[k] .r;

tb. data[kl] .qd=t.data[k] .d;

174

6人力歼组Dr广x表 |

kl1 十十;

//tb 中 元 素 的个数 增 1

)}

以 上算法中含有两重 for 循环,其时间 复 杂 度为O(L. colsX4 nums)。 最坏的情况是当

稀 玻 矩阵 中 的非 零元素 个 数 上 nums 和 六 X? 同 数量 级时,时间 复 杂 度为O(m2X姑), 所以 这

不 是 一 种 高 效 的 算法 。

从 以 上 可以 看出, 稀 玻 矩阵 采用 三 元组 顺序 表 存 储后 , 当 非 零元素 个 数 较 少时 会在一 定

程度上节省存储空间。如 果 用 一 个 二 维 数组 直接 存储 稀 朴 矩阵,此 时 具有 随机 存 取 特性 ,但

采用 三 元 组 顺序 表 存 储 后 会丧失 随机 存 取 特 性 。

622 稀疏矩阵 的十字 链 表 表 示

十 字 链 表 (orthogonal list) 是 稀疏 矩阵的 一 种 链 式 存 储 结构(相应 的 ,前 面 的 三 元 组 顺

序 表 是 稀 玻 矩阵 的 一种顺序 存储结构 )。有 如 下 3

行 4 列 的 稀 朴矩阵:

1002

Bi一 0030

0

0

0

14

创建 稀疏 矩阵 刀 的 十 字 链 表 的 步骤如 下 :

(1) 对 于 稀 朴 矩阵中 每 个 非 零 元 素 创建一个 结 点 存放 它 ,包含元素 的 行号、.列号和 元 素

值 。这里有 4 个非 零 元素, 创建 4 个数据结点 。

(2) 将 同一 行 的所有 结 点 构成 一 个带头结 点 的 循环 单链表 ,行 号为;的

单 链表 的 头 结 点为hr[门。这里 有 3 行,对应有 3 个 循环 单链表 , 头 结 点 分

别为hr[0]一hr[2]。hr[

可 (0 过 i 委 2) 头 结 点 的行指针 指向 行 号为;的单链

表 的 首结点 。

(3) 将 同一列 的所有 结 点 构成一个带头结 点 的 循环 单链表 , 列号为 了

的 单 链表 的 头 结 点为hdL门。这里有 4 列,对应有 4 个 循环单链表 , 头结

点 分 别 为hdL0]一hdL3]。hd[

门(0 和受j 委 3) 头结 点 的 列指针 指向 列 号为了 的 单链表 的 首

结点。

由 此 创建了 3 十4=7 个 循环单链表 , 头结 点 的个数也 为7个。实际上 ,可以将 hr[让和

hd[ 详 合 起来变为 杂 , 即 拒 训 同时 包含有行指针 和 列指针 。A[ 苛(0 过 i 委 2) 头 结 点 的行 指

针 指 向行 号为地 的 单链表 的 首 结 点 ,[ 训 (0 过 ;过 3) 头 结 点 的 列指针 指向 列 号 为站的 单链表
的 首结 点 ,这样 头 结 点 的个数为MAX13,4}一4个。

ss

(4) 再 将所有 头结点 [ 训 (0 过 i 运 3) 连 起 来 构成 一 个带头结 点 的 循环单 链表 ,这 样需要

增加一个总头结点 hm, 总 头 结点中 存放 稀 玻 矩阵 的 行数和 列 数等信息 。

采用 上 述 过 程 创 建的稀 朴 矩阵召 的 十 字 链 表 如 图 6. 8 所示。每 个非 零元素 就好比 在

一 个 十 字 路 口,由 此 称 为十字 链 表 。

在 稀 朴 矩阵的十 字 链 表 中 包含 两种类 型 的结 点 ,一种是 存放非 零 元素的 数据结 点 ,其结

数据 结构教程

[第! 5 【版

头 结 点

hm 一一3|

4 中 了

Jo]

7

|

17D]

了

本

了

下
010T1

于
01312

了
1[213

|

21314

-|

0

L -|
训 [1

L -|

72

10

图 6.8 一 个 稀 朴 矩阵 的十字 链 表

构 如 图 6.9(a)所示; 另 一 种 是 头结点,其结构如 图 6.9(b)所示。

TOW

col

value

TOW

col

link

down

right

down

right

(a) 数据结点结构

(b) 头结 点 结构

图 6.9 十 字 链 表 的 结 点 结构

为 了 方便 算法 设计 ,将 两种类 型 的结 点 统一起 来,设计 稀 玻 和 矩阵 的十字 链 表 的 结 点 类 型

MatNode 如下 :

# define M < 稀 朴 矩阵行数 >
# define N < 稀 朴矩阵 列 数>
# define Max ((M)>(N)?C(MD:CN))

typedef struct mtxn

{

int rowi

int col;

struct mtxn x right,x downi

ee

Unlon

{

ElemType value;

// 抢 阵行列较大者

// 行 号 或 者 行 数

// 列 号 或 者 列 数

//行、列指针

// 非零元 素 值

struct mtxn x link;

// 指 向 下 一 个头结 点

) tag;
}】 MatNode;

// 十 字 链 表 的 结点类 型

从 中 可以 看 出 ,在 十 字 链 表 中行 、 列 头 结 点是共享 的 ,而 且 采用 头结 点 数组存储 ,通过 头

结点 [可的 A[ 训 一> right 指针 可以 逐 行 搜索 行 下标为;的

所 有 非零元素,j[ 计 一 > down 指

针 可以 逐 列 搜索 列 下标

为 站 的所有 非 零 元 素。每一个非 零 元 素同时 包含 在 两个链表 中 , 方

176

6人As

数组Dr广x表 |

便 算 法 中 行 方向和列 方向 的 搜索 ,因而大大 降低了 算法的时 间 复 杂 度 。

对 于 一个疡 X 半 的 稀 朴 矩阵,总 的头结 点 个 数为 MAX{m,z) 十 1。

由 于 稀 玻 矩阵十字 链 表 的 运算 算法 设计 比较 复杂 ,这 里 不 再 袭 述 。

【 例 6.2〗 设计 一 个 用 于 存储 双 层 集合 的 存储 结构 ,所谓 双 层集合 是指这 样 的 集合,其

中 每 个元素 又 是 一 个集合 ( 称 为集合 元素),该集合 元 素 由 普通 的整数 元 素 构成 。例如 S=

(13)1 7,8) 15,6))。

采用 类似 于 十 字 链 表 的 思路 ,将 每个集合 元 素设计 成 带头 结 点 的单链表 ,将 这 些 集

合 元 素头结 点 串 起 来构成一个 单链表

,设置九所 指 的 结点作为 集合头结 点 ,如图 6. 10 所 示 。

/一一|

人

合 元 素 头结 点

了

了

了

人

人| 1

一 1

| 3

入

7

8 | 从

| 5

-|

6

入

图 6.10 双 层 集合 的存储 结构

数据 结 点 的 类 型声明 如 下 :

typedef struct dnode

{

int data;

Struct dnode # next;

} DType;

合 元 素 头 结 点 的 类 型 声明如下 :

typedef struct hnode

{

DType * next;

struct hnode * link;

} HType;

集合头结点的 类 型 与集合 元 素 头 结点的 类 型相同 。

Ex六贿四

631 广义 表 的 定义

广义表(generalized table)

是线性表的推广 ,是有 限 个 元 素 的 序列 ,其进

辑结构 采用 括号表示 法 表示 如 下 ,

GL一(al az Qi ao)

视频讲解

177

数据 结构教程

[第5 【版

其 中 寻 表 示 广 义 表 的 长 度 ,即广义 表 中 所 含 元 素的个 数," 伍 0。若 2 一 0, 称 为 空 表

。a; 为广

义表的第;个 元 素 , 如 果 ai 属于 原子 类 型(原子 类 型 的 值 是不可 分 解 的,如 CVC++语言中的

整 型、实 型和字符 型 等) , 称 为广义 表 GL 的 原子(atom);如果 au 又 是 一 个 广义 表 , 称 为 广义

表 GL 的 子 表 (subgeneralized table) 。

广义 表 具 有以 下 重要 的特性 :

(1) 广义 表 中 的 数据 元 素 是有相对 次 序 的 。

(2) 广义 表 的 长度定 义 为 最 外 层 包 含元素 的个数 。

(3) 广义 表 的 深度 定义 为所含 括 弧 的 重数, 其中原子 的 深度为 0, 空表的 深度为 1 。

(4) 广义 表 可以 共享 ,一 个 广义 表 可以 被 其他 广义 表 共 享,这 种 共享 广义表 称为再

入表。

(5) 广义 表 可以 是一个递归 的 表 , 一 个 广义 表 可 以是自己 的 子 表 , 这 种 广义表 称 为递归

表。递 归 表 的 深度是无 穷 值,而 长 度 是有限 值 。

广义 表 抽 象数据 类 型 的 定义如 下 :

ADT Glist

{ 数据 对 象 :

={ e| 1 委 过 wx 关 0,eEAtomSet 或 eEGList,AtomSet 为某个数据对象}

数据 关系 :

及 ={<erie> | eveED,2过和运从

基本 运算 :

CreateGL(s): 创建 广义表 g, 由 括号 表示 法 * 创建并 返回 一 个 广义 表 ;

DestroyGLC&sg): 销毁 广义 表 , 释 放 广义 表 g 的 存储 空间 ;

GLLength(g): 求广义 表 g 的 长度;

GLDepth(g): 求 广义 表 g 的 深度 ;

DispGL(sg): 输出 广义 表 g.

}

为 了 简单 起 见,下 面 讨论 的 广义 表 不 包括 前 面 定义的 再人表 和 递归 表 ,即 只讨论 一 般 的

广义表。另 外 ,规定 用小写字 母表示 原子,用 大 写字 母 表示 广义 表 的 表 名 。 例如:

A=()

忆一(e)

C=(a,(b,c,d))

王(() ,Ce),(Ca, (bc,d)))
D=(A,B,C)

玖 =((ay(Ca,b),((Ca,b),c)))

玉

A 是 一 个 空表, 其长度为0;

已 是 一个只含有 单个原子 e 的 表 , 其 长 度为 1;

C 中 有 两 个元素 ,一 个是原子,另 一 个 是子表 ,C 的 长 度为2;

刀 中有 3 个 元 素 , 每 个 元 素 又 都是一 个子表 , 了 的 长 度为3;

刁 中 只 含有一 个 元 素 ,该元素 是 一 个子表 , 尼的长度为 1 。

如 果 把 每个表 的 名 称 (若有 ) 写 在其表 的 前 面 (没有给 出 名 称 的子表 为 匿名表 , 用 ”,” 表

178

6人As。歼组Dr广x表 |

示 ), 则 上 面 的 5 个 广义 表 可 相应 地 表示 如 下 :

AGO)

忆 (Ce)

CCa,。(b,c,d))

D(A(CO ,BCe),CGa,。(b,c,d)))

下 (。(a,。(a'b),。(。(a'b),c)))

若 用 圆圈和 方 框 分别 表示 表 和 原子 ,并 用 线段 把表和 它 的 元 素 ( 元 素 结 点 应 在 其 表 结 点

的 下 方 ) 连 接 起 来 , 则 可 得 到 一 个 广义 表 的 图 形 表示。例如 ,上 面 5 个 广义 表 的 图 形 表 示 如

图 6. 11 所 示 。

4

也

”了

已

日

C

b||le|la

瑟

al |b

C

图 6.11 广义表的图形表示

广义表 GL 的 表 头 为第一 个 元 素 wa ,其 余部 分(ax ,...,a,...'av)为GL 的 表 尾 ,分别记

作 head(CGL)=a 和 tail(GL)

一(aa a)。显 然,一 个 广义表 的 表 尾始终 是一个 广

义表。空 表 无 表 头 、 表 尾。这 里仍取 上 面的示例 ,

A 无 表 头 、 表 尾

head(CB)=王e; tail(B)一()

一((b,c,d))
head(CC)王ay tail(C)

一(Ce),(Ca,(b,c,d)))
headCD)王(CO); tailCD)

head(E)

一(a,(a,b),((ayb),c)); tail(E)一()

其 中 ,广义表A 和 了

的 深度为 1( 注 意 广义表 A 和广义表忆 的 深度相同 ,因为 它们 均只有 一

重 括号 ) ,广义表CD、E 的深度分别 为 2.3

和 14。

632 广义表的存储结构

扯 -下

回,

广义 表 是 一 种递归 的 数据 结构,因此很 难为 每个广义 表 分 配 固定 大小

的 存储 空间 ,所以 其存储结构只 好 采用 链 式 存储 结构 。

家

从图 6. 11 中 可以 看 到 ,广义表有 两 类 结 点 ,一 类 为 圆圈结 点 ,在 这 里 对 应子表 ; 另 一 类

aa

为 方形 结 点 ,在 这 里对 应 原子 。

为 了 使 子表和 原子 两类结 点 既能 在 形式上 保持 一 致,又能 进行 区 别 ,可 采用以 下 结构

形式,

tag

sublist/data

link

其中,tag 域 为标志 字段 ,用 于 区 分 两类结 点 , 即 由 tag 决定 是 使用 结 点 的 sublist 还是

179

数据 结构教程

[第! 5版

data域,

(1) 若 tag一0, 表 示 该 结 点 为原子 结点, 则 第 2 个 域为 data, 存 放 相应原子 元 素 的 信息 ;

存放相应表/子表中
(2) 若 tag 王 1, 表 示 该 结 点 为表/ 子 表 结 点 , 则 第 2 个 域为sublist,

第 一 个 元 素对 应结 点的地 址 。

link 域存放 同一层的 下 一 个 元素对 应 结 点 (兄弟结 点)的 地 址 , 当 没有兄弟结 点 时 ,其

link 域 为NULL。

例如 ,前面的广义表 C 的 链 式 存储结构 如 图 6. 12 所示。

c 一 [TAX

LTaT TI

Lnr

盖| 0

|

站 0|1d| 人

图 6.12 广义表 C 的 存储 结构

采用 CVC++ 语 言描述广义 表 的 结点类型GLNode,其声明如下 :

typedef struct lnode

{

int tag;

union

// 结 点 类 型标识

{

ElemType data;

// 存 放 原 子 值

struct lnode * sublist;

// 指 向 子 表 的 指针

}》 val;

struct lnode * link;

) GLNode;

// 指 向 下 一 个 元 素
// 广义表 的 结 点 类 型

633 广义表的运算

为了使 算法 方便 ,在 广义 表 的 逻辑 表示 中 用 ”(# )? 表 示 空 表 。

在 广义 表 的 链 式 存储 结构中 ,tag=1 的 结点可 以 看 成是一 个 单 链 表 的 头 结点 ,由

sublist 域 指向 它 的所有 元 素 构成的单链表 的 首 结 点 ,link 域 指向 它 的 兄弟 结 点 。从中可以

看 到 ,广义 表 的 链 式存储结构具有 递归 性 ,可以 从 两 个 方面 来理解 这 种递归 性,从 而 得 到 广

义 表 的 两 种递归 算法 方法 。

解法 1: 一 个非 空 广义表 的 基本 存储结构如图 6. 13 所 示 ,将 其 看 成是带头结 点 的 单 链

|

8 -1 人 入

子 表的 头 结 点 :

子 表 可 以 看 成

|本 | 第 2 个 元 素

一 个 带头结 点 的 广义 表

第 寻 个 元 素

“1人 入

1

|

1

1

壮 子 表结构 和 广义 表结 构 是相似 的

图 6.13 一 个 非 空广义 表 的 基本 存储 结构

180

6人As放 。。。。。 歼组Xx表 |

表 , 对 于 原子结 点,可以 直接 进行 处 理以实现原子 操作 ; 对 于 子 表 结 点 ,由 于 子 表 的 存储 结

构 和 整个 广义 表 的 存储结构是相似 的,因此 子 表 的 处理和 整个 广义 表 的处理 是 相似 的 。从

这 个 角度 出发设计 求解 广义表 递 归 算 法 的 一 般 格式如 下 :

void funl (GLNode* g)

//g 为 广义 表 头结点 指针

{

, GLNode * gl 一g一 val.sublist;

V/gl 指向第一个元素

while (gl1!=NULL)
{

gg

浊 (g
funl(g1);
ielse
; 原子处理语句;

/元素未处理完循环
//为子表时
//递归 处理子表;
// 为原子 时
// 实 现原子操作;

先处理 一 个 元 素

再处理后继元素

】}

解法 2: 一 个非 空 广义表 存 储结构 中 两 类 结 点 的 基本结构 如 图 6. 14 所示 。每个原子结

点的 data 域 为原子值,link 域指向其兄弟; 每个表 / 子 表结 点 的 sublist 指向 它 的元 素 ,link

指向 兄弟。因 此 ,对 于 原子结 点 ,其 兄弟 的 处 理 与 整个 广义 表 的处理 是 相似 的; 对 于 表 / 子

表 结 点 ,其元 素和 兄弟 的 处 理 与 整个 广义 表 的 处 理是相似 的 。

广义

表 的一个 结 点

-一 -一 -

广义 表的 一 个结 点

t
S&-|0

上 | 才

原子 值
,

一 -一 一
人 & 的 兄弟
=-l |*|7
4
\、

~~_~__---

,

如

)
上 HL

|

~

~-----

=

|
一 症一一

一 二

一 ~人、

交

束

来

来

A\

一
们、g 的 元素 “一

/

(a) 广义表原子结点

(b)广义表/子表结点

图 6.14 广义 表 中 两类结 点的基本 结构

从 这 个 角度 出发设计 求解 广义表 递 归 算 法 的 一 般 格 式如 下 :

void fun2(GLNode * g)

//g 为 广义 表 结点指针

{

这 (g!=NULL)

{ 省 (g一 tag=一1)

// 为子表 时

一 val.sublisb; // 递归处 理 其 元 素 ;

; fun2(g
else
; 原子处理语句;

//为原子时 一-先处理 data/sublist 域 ,即元 素 部 分
// 实 现原子操作

Ta

一一再处理 link域 ,即兄弟部分

}》

181

数据 结构教程

[第! 5版

在 广义 表 中 ,同一层次 的 每个结 点是通过 link 域 链接 起 来的,将 其 看 成

是 带头 结 点 的 单链表 ,如 图 6. 13 所 示 ,这 样 求广义 表 的 长 度 就是求单链 表

的 长 度 。对 应 的 非递归 算法 如 下 :

int GLLengthCGLNode * g)

{

int n 一 0;

//求广义表 g 的 长 度
// 累 计 元 素 个 数 ,初始 值为0

GLNode * gl1;

g1 一 g 一 val.sublist;

while (gl!王NULIL)

mn 十 十 ;

gl一gl 一 > link;

{

}

return ni

)}

了 求 ) 多 表 的 朵 度

//gl 指向 广义 表 的 第 一 个 元 素

// 扫 描所有 元 素 结 点

/元素个数增 1

// 返 回 元 素个数

对 于 广义表 g ,其 深度 等 于所有 元 素 的最大 深度加 1。 若 8 为 原子,其深度为 0, 求广义

表 深 度 的递归 模型Ag)如下:

7C8) 一 0
7C8) 一 1
AD 一 MAXSA(7Csubg))十1

若 5 为原子
若 8 为空表
其 他 情况

求 广义表 8 的深度的算法如下 :

int GLDepthCGLNode * g)

//求广义表 g 的 深度

{

GLNode * 81;

int maxd一0,dep;

秆 (Cg 一 tag一一0)

Teturn 0;

g1 一g 一 val.sublist;

让 (gl一=王NULL)

Teturn 1;

// 为原子时返回0

V/gl 指向第一个元素

// 为空表 时 返回 1

while (gl!=NULIL)

//人遍历 表 中 的 每一个 元 素

{

这 (gl 一 tag一一1)

// 元 素 为子表 的 情况

dep 一GLDepth(g1);

// 递 归 调 用 求 出子表 的 深度

让 (dep> maxd)

maxd一dep;

//maxd 为 同一 层 的子表 中 深度 的 最 大 值

{

】》

gl1一gl -> link;

//使gl 指向下一个元素

}

returnCmaxd 十 1);

// 返 回 表 的 深度

)}

实际上 ,本 算法 是 采用 前 面 介绍 的 广义 表 算 法 设计 方法中 的解法 1 实现的。

182

6人As。歼组Dr广x表 |

下

输出 广义 表 g 的 过程Ag)为,若 8 不 为NULL,先输出g 的 元 素,当 有 兄弟时 再 输出

兄弟。输出 g 的 元 素 的 过 程 是 ,如 果 该 元 素 为 原子, 则 直接 输出 原子 值,若 为子表 , 输 出〈",

以输出子表,再输
如 果 为 空表则 输出 '# “如 果 为非 空子表 则 递归 调用 /Cg 一 > val. sublist)

出 7"。 输出 < 的 兄弟 的 过 程是输出 '

1

,,

递归 调用

Cg 一 >link) 以 输出 兄弟 。

输出 一 个 广义 表 的 算法 如 下 :

void DispGLCGLNode * g)

{

让 (g!王NULL)

{

这 (g一>tag 一一0)

printf(" 由

c",g 一 val.data) ;

else

{

printf("(");

一一NULL)
让 (g 一 val.sublist

Printf(" 井”);

else

DispGLCg 一> val.sublist) ;

printf(")");

】》

过 Cg 一 >1link!王NULL)

printf(",");

DispGLCg 一 link);

{

】》

)}

// 输 出广义表 g
// 表 不 为 空判断

//g 的 元 素 为原子时
// 输 出原子值
//g 的 元 素 为子表 时

// 输出'('

// 为空表 时

// 为非 空子表时

// 递归输 出 子 表

// 输 出 7

//递归输出 g 的 兄弟

实际上 ,本算法是采月

日 前 面 介绍 的 广义 表 算 法 设计 方法中 的 解法 2 实现的。

于 建 了 ) 义 表 的第式 存俏 结 森

假设广义 表 的迎辑结构 采用 括号 表示 ,其 中

的元素类型ElemType 为

char 类 型 ,每个原子 的 值 被限定 为 单个英文 字母 。

其 格式 为 元 素 之 间 用 一

个逗号 分隔, 表 元 素 的 起 止符号 分 别为左 、 右圆括号 , 空 表 为 "(#)"。 例如

"Ca,(byc,d),(#)) "就 是一个 符合上述 规定 的 广义 表格 式 。

视频 讲解

建立广义 表 链 式 存储结 构 的 算法 是 一 个递归

算法 , 它 使用 一 个广义 表 括 号 表示 字符 串

参数 *, 返 回 创建的广义 表 链 式存储结构 的 头 结 点

指针 g。

算法 的 执行 过 程 是从头 到 尾 扫描 s 的 每 一个字符。当 遇 到 〈 时 ,表明 它 是 一个表 / 子 表

的 开始 ,应 创建 一 个由& 指向的表 / 子 表 结 点 ,并 月

日它的 sublist 域 作为子表 的 表 头指针 进行

递归 调用 来 建立子表 的 存储 结构 ; 当 遇 到 一 个 英文 字母时 ,表明 它 是 一 个 原子, 则 应 创建 一

个由天 指向的原子结点; 当 遇 到 一 个 ) 字符 时 ,表明 前 面的表 / 子 表 已 处 理 完毕 , 则 将 8 置

为空; 当 遇 到 一 个 '# 字符时 ,表明 前 面的表 / 子 表 是 空表, 则 将 g一> val, suplist 置 为 空。

当建立了一个由斑 指向 的结 点 后 ,接着 遇 到 ', 时,表明还存在兄弟,需要建立当前结点

( 即由 g 指向 的结 点 ) 的 兄弟 结点; 否则 表明 当前 结 点 没有兄弟了 ,将 当前 结 点 的 link 域置

为空。

根据以上分析 ,设计对应的 生成 广义表 链 式 存储结构 的 算法如 下 :

183

数据 结构教程

[第! 5 【版

GLNode * CreateGLOchar * &s)

// 返 回 由 括号表示 s 建立 的 广义 表 链 式存储 结构

{

GLNode *g;

char ch一 * s十十;

让 (ch! 一 \0)

// 取 一 个 字符

//若s 未 扫描 完

{

, g= 一(GLNode * )malloc(sizeof(GLNode));

。 // 创 建 一 个新结 点

让 (ch 一 一'()

// 当 前 字符 为 左括号 时

, g一tag一1;

g 一 > val.sublist

一CreateGLCs) ;

// 新 结 点 作为 表 / 表 头 结 点
// 递 归 构造子表 并 链接 到 表 头 结点

{

)}

else 让 (ch 一 一 7)

g=NULL;

else 让 (ch一一'#

g=NULL;

else

{ gg一tag一0;

g 一> val. data一ch;

)》

)》

else

g一NULL;

ch一* s十十;

让 (Cg!=NULL)

让 (ch 一 一 ,)

g 一 link 王 CreateGLCs);

g一link王NULL;

else

ITeturn g;

}

// 遇 到 )) ' 字 符 ,g 置为空

// 遇 到 '# ' 字 符 , 表 示 空 表

// 为原子 字符

// 新 结 点 作为原子 结点

// 若 s 扫描 完,g 置为空

// 取 下 一 个 字符

//s 未 扫描 完 ,继续 构造兄弟 结点

// 当 前字符为',

//递归 构 造兄弟 结 点

// 没有兄弟了 ,将 兄弟 指针 置 为 NULL

// 返 回 广义 表 g

该 算法 需要 扫描 输入 广义 表 括号 表示 中 的所有 字符 ,所以 算法 的时间 复 杂 度 为 O(z) ,m

表示 广义 表 中 所 有 字符 的 个 数。在 这 个 算法 中 既 包 含子表 的递归 调用 ,也 包含 兄弟 的递归

调用,所以递归调用的 最 大 深度 不 会超过 生成 的 广义表 中 所 有 结 点 的 个 数 , 因 而 其 空间 复杂

度 也为OCzD)。

该 运算 扫描 广义 表 链 式 存储结构 & 的 所 有 结 点 并 逐个 释放 。 将 广义 表 & 看 成 是带头

结 点 的 单链表 ,扫描 & 的所有 元 素结 点 ,如 果 为 原子结 点,直接 释放,

如 果 为 子 表结 点 ,释放

该子表 的 过 程 与 整个广义 表 是 相似 的。对 应 的速归 算法 如 下 :

void DestroyGLCGLNode * &g)

//销毁广义表 g

{

GLNode * gl1,*g2;

gl一g一> val.sublist;

while (gl1!

王 NULL)

{

计 (gl 一 tag 一一0)
{ g2一gl 一 link;
free(Cg1);

g1 一 &2;

V//gl 指向 广义 表 的 第 一 个 元 素

// 遍 历所有 元 素

// 若 为原子结点
//g2 临时 保存 兄弟 结 点
// 释 放 gl1 所 指 的原子结点

//gl指向后继兄弟结点

184

6人力歼组DrXx表 |

}

else

{ , g2一gl 一 link;
DestroyGL(g1) ;

g1 一 g2;

】》

}

freeCg) ;

)}

//若为子表

//g2 临时 保存 兄弟 结 点
//递归释放 gl 所 指 子 表 的空间

//gl指向后继兄弟结点

// 释 放 头 结 点空间

实际 上 ,本 算法 是 采用 前面介绍 的 广义表 算 法 设计 方法中 的解法 1 实

现的。

【例6.3】 对 于 采用 链 式 存储结构 的 广义 表 g 设计 一 个 算法 求原子个数 。

需要 扫描 广义 表 g 中 的所有结点,可以 采 月

日 前 面 介绍 的 广义 表 算 法

设计 方法中 的 两 种解法 来 实现 。对 应 的 算法如下 :

// 采 用 解法 1 的 方法

int CountlC(GLNode * g)

{

int n一0;

GLNode * g1 一g 一> val.sublist;

//求广义表 g 的原子个数

while (gl1!王NULL)

// 对 每个元 素 进行 循环处理

, 计 (g1 一>tag 一一0)
n 十十;

else

n 十一Countl(g1);

g1一&]1 一 link;

{

}

Teturn Dj;

)》

// 采 用 解法 2 的 方法

int Count2(GLNode * g)

{

int n一0;

让 (g!=NULL)

{

让 (g一tag一一0)

n 十十;

else

//为原子时
// 原 子个数增 1

//为子表时

// 累 加 元 素 的 原子个数
// 累 加 兄弟 的原子个数

// 返 回 总原子个数

//求广义表 g 的原子个数

// 对 每个元 素 进行 循环处理

//为原子时
// 原 子个数增 1

//为子表时

n 十 二 Count2(g 一> val. sublist);

// 累 加 元 素 的 原子个数

n 十 二 Count2(g 一> link);

// 累 加 兄弟 的原子个数

}

Teturn Dj;

)》

// 返 回 总原子个数

一人 本章 小 结 一 一

本 章 的 基本 学 习 要 点如 下 :

(1) 理解 数组 和 一般线性 表 之间 的 异同 。

视频讲解

数据 结构 教程

虹 第人5 【版

(2) 掌握 数组 的顺序存储结构 和 元 素地 址计算 方法 。

(3) 掌握 各 种特殊矩阵 (如对 称 矩 阵`、上 /下 三 角 和 矩阵 和 对 角 和矩阵 ) 的 压缩存储 方法 。

(4) 掌握稀疏矩阵 的 各 种 存储结构 及 其特点 。

(5) 掌握 广义 表 的 递归特性和 存储 结构设计 。

(6) 掌握 广义表的相关算法设计 方法 。

(7) 综合 运用 数组 和 广义 表 解 决一些 复杂 的 实际问题 。

1. 如 何 理解 数组 是 线性 表 的 推广?

2. 有 三 维 数组 ea[0..7,0..8,0..9]

采用按行序优先存储,数组的起始地址是 1000 ,每 个

元 素 占用 两个字 节 , 试 给出下 面结果 :

(1) 元素ass的起始地址。

(2) 数组 所 占用 的存储空间。

3. 如 果 某 个 一 维 数组 A 的 元 素 个 数 ”很 大 ,存在 大 量 重复 的 元 素,上且所 有 元 素 值相同

的 元 素 紧 挨 在 一 起 ,请 设计 一种压缩 存储 方式 使 得存储 空间 更 节省 。

4. 一个寺 阶 对 称 矩阵4 采用 压缩存储 在 一 维数组已 中 , 则

召 中包含多少个元素?

5. 设 ?2X7 的 上 三 角 和 矩阵4[0..2 一1,0..2 一 已 压缩到 一 维 数组 BL0..z四中 , 若 按 列 为

主序存储,则 4[ 让 [7门 对 应 的 忆 中存储位置& 为多少? 给 出推导过程。

6. 利用 三 元 组 存储任意 稀 下 数组 A ,假设其中 一 个 元素和 一 个整数 占用 的 存储 空间 相

同 , 问 在 什么 条件 下 才能 节省 存储空间 ?

7. 用 十 字 链 表 存储 一 个有“个非 0 元 素 的 冯 2 的 稀 朴 矩阵 , 则 其 总 的 结 点 数 为多少 ?

8. 求 下 列 广义 表 运 算 的 结果 。

(1) head[LCx,y,z)]

(2) tailL((Ca,b),(Cx,y))]

注意: 为了清楚 起 见,在 括号 层次 较 多 时将head 和 tail 的 参数用 中 括号 表示。例如

headLG] \tailLG] 分 别 表示 求 广义表 G 的 表 头 和 表 尾 。

9. 设 定 二 维整数 数组 B[0..mz一1,0..x 一 芍 数据 在 行列 方向上都按从 小 到 大 的 顺序

排序,且整型变量 z 中 的数据在也 中 存在 。设 计 一 个 算法 , 找 出一对 满足B[z[门=z的站

了 值,要 求比较 次 数 不 超过 冯 十 m。

10. 设计 一 个 算法 ,计算 一 个 用 三 元 组 表 表示 的 稀 玻 矩 阵 的对角 线 元 素之和 。

11. 设计一个算法 Same(g1,g2) ,判断两个广义表 g1 和 8g2 是 否 相 同 。

实验题1: 实现 稀疏 矩阵(采用 三 元组表示 ) 的 基本 运算

目的: 领会稀朴 矩阵 三 元 组 存储结构 及 其 基本 算法 设计 。

内容: 假设 2zXz 的 稀 玻矩阵4 采用 三 元 组 表示 ,设计 一 个 程序exp6-1. cpp 实现以下

186

6人As。歼组Dr广x表 |

功能。

(1) 生成 以 下 两个稀 朴矩阵 的 三 元组 c 和 2 。

1

0

0

0 .30

1 .00

0 .10

3

0

0

0

0 4.0 0

0

0

1

0

0011

0 0.0 2

(2) 输出 a 转 置矩阵的三 元组 。

(3) 输出 c十2 的 三 元 组 。

(4) 输出 aX2的三元组。

实验题2: 实现 广义 表 的 基本 运算

目的: 领会广义 表 的 链 式 存 储 结构 及 其 基本 算法 设计 。

内容: 编写一个程序 exp6-2. cpp, 实 现 广 义 表 的 各 种 运算 ,并 在 此 基础 上 设计 一 个 主 程

序 完 成 以下功能 。

的链式存储结构 。
(1) 建立 广义 表 g ="(b,(b,a,(直),d),(CCaybl,c,((#))))"

(2) 输出广义 表 g 的 长 度 。

(3) 输出 广义 表 g 的 深度 。

(4) 输出 广义 表 g 的最大原子。

人设计 性 实验

实验 题3: 求5SXSs 阶螺旋方阵

目的: 掌握 数组 算法 设计 。

内 容 : 以下是 一个5X5 阶 螺旋 方 阵,编写一 个 程序 exp6-3. cpp 输出该形式 的 六

阶方阵(按顺时针方向旋进) 。
7Cz<10)

1

16

15

14

13

2

17

24

23

12

3 45

18

25

22

11

19

20

21

10

6

7

8

9

实验题4: 求 一 个矩阵 的 马鞍点

目的: 掌握数组 算法 设计 。

内 容 : 如 果和 矩阵 4 中 存在 一 个 元 素满足 以下条 件 ,即 4[z[7门是第 守 行中值 最 小 的 元 素 ,

且又是第7

列 中 值最大 的 元 素 , 则 称 之 为 该矩阵 的 一 个 马鞍 点 。设计 一 个 程序exp6-2. cpp 计

算出 冯 X2 的矩阵 4 的所有 马鞍点。

谷 综 合性实验

实验题$: 求 两 个对称 矩 阵 之 和 与 乘积

目的: 掌握对 称 和 矩阵的压缩存储 方法及 相关 算法 设计 。

内容: 已知4 和 也 为 两个半 X妈阶 的 对 称 和矩阵 ,在 输入时 ,对 称 矩阵只 输入下 三 角形 元

素 ,存和 一 维 数组 ,如 图 6. 15 所 示 ( 对 称 和 矩阵 M 存储在一维数组 A 中 ) ,设计一个程序

exp6-5. cpp 实现以下功能。

aa

187

数据结构 教程

(第人5人版

(1) 求对称 和 矩阵4 和 了 吾的和 。

(2) 求对称 和 矩阵4 和 了 的 乘积。

0.0

10 局

M=| mo

WP

ma

or-10

-LI

Dr12 1

4:| 09

YL0 | XU1 | 20 | 221 | 222

| 20 | xl

1.2

| Zr

图 6.15 ”对称矩阵 的存储 转换 形式

188

在 前 面 介绍 了 几 种常用的线性 结构 , 本 章讨论 树 形 结构。树形

结构 属于 非 线性 结构 , 常用的 树 形 结构有树 和 二 叉 树。 线性 结构 可

以 表示 元 素 或元素 之间 的

一对 一关系 , 而 在 树形 结构中 , 一 个 结点

可 以 与 多 个 结 点 相对 应 , 因此 能 够 表示 层次 结构 的 数据 。

本 章主要讨论树和 二 叉 树 两种树形 结构 的 基本 概念 和 相关 算法

设计。

数据 结构教程

[第1 5 【版

树的基本 概念

※

711 树 的定义

树 (tree)是由 2”(z 伍 0) 个结 点 (或元 素 ) 组 成 的 有 限 集合 (记为了)。

如果 2 一0, 它 是 一棵 空树 ,这 是 树 的 特例 ;

如果 x一0,这 守 个结 点 中 有 且 仅 有 一 个结 点 作为树的 根 结 点 ,简称 为

视频 讲解

根 (root) ,其 余结 点 可 分 为 丸 Cm 三 0) 个 互不相交的 有 限 集

,三 ,...,T ,其中 每 个子集 本

身 又 是 一棵 符合 本 定义 的树 , 称 为 根结 点的 子 树(subtree) 。

从 上 可以 看 出 , 树 的 定义 是递归 的 ,因为在树 的定义 中 又 用 到 树 定义。它 刻化了 树 的 固

有 特性 ,即 一 棵 树 由 若干棵 互不相交 的 子 树 构成,而 子 树又由 更 小 的 若干 棵子树 构成 。

树结构 常用于 表示 具有 层次 关系 的 数据。树 的 抽象 数据 类 型 描述如 下 :

ADT Tree

{ 数据对象 :

D={a| 1]过过 风 2 二 0,o 为 ElemType 类型}

//ElemType 是 自定义类型标识符

数据 关系 :

R={(<a,ou> |aoED,1

近 is0 其中有 且仅有 一 个 结 点 没有前 驱 结点,其 余 每个结 点

只 有 一 个前驱 结 点 ,但 可以有 零 个 或多个 后 继 结 点 }

基本 运算 :

InitTree(&DD: 初始 化树, 造一棵 空树 二
DestroyTree(&z):销毁树,释放树 上 占用的存储空间.
TreeHeightCz) : 求树 上 中 的 高 度 .
Parent(b力) : 求树 上 中心所 指 结 点的双亲 结 点 .

Borther(b轧) : 求树上 中 户 所 指 结 点 的所有 兄弟 结 点 .

Sons(力) : 求树 上 中 情 所 指 结 点 的所有 子孙 结 点 .

712 树 的 逻辑表示方法

树 的 多 辑 表示 方法有多 种 ,但 不 管 采 用 哪种表示 方法 ,都 应 该能 够 正确地 表达 出树中 结

点 之 间 的层次 关系。下 面 介绍 树 的 几 种 常见逻辑 表示 方法 。

pe

(1) 树 形表示法(tree representation): 用 一 个 圆圈表示 一 个 结点 ,圆圈 内 的 符号代表
该 结 点 的 数据 信息 , 结 点 之间 的 关系 通过 连线表 示 。 虽 然每条 连线上 都 不带有 箭头 ( 即 方

向),但 它 仍然是有 方向 的 ,其 方向隐 含 着从上 向 下 , 即 连 线的上 方 结 点 是 下 方 结点的 前 驱 结

点 ,下 方 结 点是上 方 结 点 的后继 结 点。它 的 直观 形象 是一棵 倒置 的树( 树 根 在上,树叶 在

下 ), 如 图 7.1(a)所示。

说明: 在 树 形 表示 法 中 ,尽管 用没有 箭头 的 连 线 表示 结 点 之间 的 关系 ,但 实际上 树 中 结 点

之间 的 关系 是 一 种有向 关系 。例如,图 7.1(a)中结点 A` 了 之间 的 连线对 应 序偶<A,B>。

(2) 文氏岁 表 示 法(venn diagram representation): 每棵树 对 应 一 个 圆圈,圆圈内 包含

190

[第 /7 【章】 树和二又树

根结 点和 子 树 的圆圈 ,同一 个 根结 点 下 的 各 子 树 对 应 的 圆圈是 不 能相交 的。在 用 这 种 方法

表示 的 树 中 , 结 点 之 间 的 关系 是通过 圆圈 的 包含来表示 的。图 7. 1(a) 所 示 的 树 对 应 的 文 氏

图表示法如图7.1(b)所示。

(a) 树形 表示法

(b) 文 氏 图 表示法

A

B

C

D

E

F

G

H

T

了

K

[L

M

A(B(E,.P)C(G(UDJ)DUHIOKL.MD)

(9 凹入表示法

(d) 括号 表示 法

图 7.1 树 的 各 种 表示法

(3)

凹 和表示法(concave representation) :

每 棵 树 的 根 结点对 应 一 个 条 形 ,其子树 的 根

对 应 着 一 个 较 短 的 条 形 , 且 树 根 在 上 , 子 树 的 根在下 ,同一 个 根 下 的 各 子 树 的根对 应 的 条 形

长 度 是 一 样 的 。图 7. 1(a) 所 示 的 树对 应 的 凹人表示 法 如 图 7. 1(c)所示 。

(4) 括号 表示法 (bracket representation): 每 棵 树对 应 一 个 形 如 * 根(子树 1, 子树2,...,

子树 m) ?的 字符 串 ,每棵子 树的表示 方式 与 整棵树 类似 , 各 子 树 之间 用 逗号 分 开。在用这种

方法 表示 的 树 中 ,结 点 之 间 的 关系 是通过 括号 的 嵌 套 表示 的。图 7. 1(a) 所 示 的 树 对 应 的 括

号表示法如图7.1(d)所示。

713 树的基本 术语

下 面 介绍 树 的 常用术语 。

(1) 结 点的 度 与 树的度: 树 中 某 个结 点 的 子 树 的个数 称 为 该 结 点 的 度

(degree of node) 。树 中 所 有 结 点 的度中 的最大 值 称 为树的 度(degree of tree) ,

通常将度为zm 的树称为严 次 树(mtree) 。例如,图 7. 1(a)是一棵 3 次树。

191

aa

数据 结构 教程

虹 第 5 【版

(2) 分 支 结 点 与叶子结点: 树 中 度 不 为 零 的结 点 称 为非 终端 结 点 ,又叫 分 支结点

(branch)。度 为 零 的 结 点 称为叶子 结 点 (leaf) 。 在 分 支结 点 中 ,每 个结 点 的 分支数 就 是 该结

点的 度 。如 对 于 度 为 1 的结 点 ,其 分 支 数为1, 被 称 为 单 分 支 结 点; 对 于 度为 2 的结 点 ,其分

支 数为 2, 被 称为双 分 支 结 点 , 依 此 类 推 。例如,在图7. 1(a)所示的树 中,BC 和 D等是分支

(3) 路径与 路 径 长 度: 对 于 树 中 的任意两个结点 妨 和 心,若 树 中 存在 一 个结 点 序列

(CRa ysAasAi) 使 得序列中除访 以 外 的任 一 结 点都 是 其 在 序列 中 的 前 一 个结 点 的

后 继结 点 , 则 称 该结 点 序列 为由访 到心 的一条 路 径(path)。路 径 长 度(path length)是该路

径 所 通过 的结 点 数目减 1(即 路径上 分 支 数目)。可 见 , 路 径 就 是从 久 出 发<自 上 而 下?到达

久 所 通过 的 树 中 结 点 序列。显 然,从 树 的 根结 点 到 树 中 其 余 结 点 均 存 在 一 条 路 径 。例如,

在图7.1(a)

所示的树中,从A 到 开 的 路 径 为 (A,;D,I'K)

,其长度为 3, 而(K,I,D,A)为A

到 开 的 逆 路 径 。

(4) 孩子结 点 `,双 亲 结 点和 兄弟结 点 : 在 一 棵树中 ,每个结 点 的后继结 点被称 为 该结 点

的 孩子 结 点(children)。相 应 地 ,该结 点 被 称 为 孩子 结 点 的 双亲 结 点(parents)。具 有 同一

双亲 结 点 的 孩子结 点 互 为兄弟 结点(sibling)。 进 一 步 推广 这 些 关 系 , 可 以 把 每 个结 点对 应

子树中 的所有 结 点 ( 除 自身外)称 为 该 结 点 的 子孙 结 点(descendant) ,把从根结 点 到 达 某 个

结点的路径上经 过 的所有结 点 ( 除 自身 外 ) 称 为 该结 点的宜 先 结 点 (ancestor)。例如 ,在

图 7.1(a)所示的树中 ,结点BC、D 互 为兄弟结 点 ,结 点 D 的子孙结点有 HIK、L 和 M,结

(5) 结 点 层次和 树 的 高度: 树 中 的 每个结 点 都 处在一 定 的 层次 上。结 点 层次 (level)或

结 点 深度(depth) 是 从 树 根开始 定义 的 , 根结 点 为 第 一层, 它 的 孩子结 点 为第二 层 , 依 此 类

推 ,一 个结 点 所 在 的 层次 为其双亲 结 点 的 层次加 1。 树 中 结点 的最大 层次 称 为树的 高 度

(Cheight of tree)

或树的深度(depth of tree)。

(6) 有 序 树和 无 序树: 若 树 中 各 结 点 的子树是按照一定 的 次 序 从 左 向 右 安 排 的 ,上且相

对 次 序 是 不 能 随意 变换 的 , 则 称 为有序 树(ordered tree) ,否则 称 为 无 序 树Cunordered tree)。

一 般情 况下,如果 没有特别 说 明 ,默认 树都 是 指 有 序 树 。

(7) 森林: zz 二 0) 个 互不相交 的 树 的 集合 称 为森林 。 把 含有 多 棵 子 树 的 树 的 根结 点

删 去 就成了 森林 (forest) 。反之,给 mm(mz二 1) 棵 独立 的 树加 上 一 个 根结 点 ,并 把 这 关 棵树作

为 该结 点 的 子 树 , 则 森林 就 变 成了一 棵 树 。

714 树 的 性 质

性质1: 树 中 的结 点 数 等 于所有 结 点 的 度数 之和加 1 。

证明: 根据树的定义,在 一 棵 树 中 除根结 点 以 外,每个结点有且 仅 有 一

个 前 驱 结 点 。也 就 是说,这 样的 结点 与 指向它的 一 个 分 支 一一对 应 。所以

视频讲角

除根结 点以 外 的结 点 数 等 于所有 结 点 分 支 数之和 , 即结 点 数 等 于所有 结 点

分 支 数之和 加 1 ,而所有 结 点 分 支 数之和 恰好 等 于所有 结 点 的度数之和,因此 树 中 的结点 数

等 于所有 结 点 的 度数 之和 加 1 。

性质2: 度为zz 的树中 第 层 上 最多有 福王:个结 点 (Ci 人 1) 。

证明: 采用 数学 归纳 法证明 。

192

人 7 人齐记 。。。。。 本和二X村

|

对 于 第 一 层,非 空树中 的 第 一 层上只 有 一 个 根 结点,由 这 1 代入 mi ,得 mr 一 oa 一 1,

显然结论 成立。

假设对 于 第 (一 1)层 (i盖2)命 题成立 ,即度为zm 的树中 第 (一 1) 层上最 多 有 me一个 结

点 ,根据 树的度 的定义 ,度为产的 树 中 每个结 点 最多有 关 个 孩子结 点 ,所以第 ; 层 上 的 结 点

数最多 为第(i一1) 层上结点数的冯 倍 , 即最多 为 2 一 义 一 六 一 个 结 点,故命题 成立。

推广: 当 一 棵 疡 次 树 的 第 ; 层上有 闷 一:个 结 点 (Ci人1)时,称 该 层 是 满的, 若 一 棵 2 次 树

的所有 叶子 结 点 在 同一 层,并 且 除 该 层 以 外 的 每 一 层 都 是 满 的,称 为满关 次树(full

mrtree) 。显然 ,满关 次 树 是所有 相同 高 度的关 次树中结 点 总 数 最 多 的 树。也 可 以 说 ,对 于

二 个 结点 ,构造的 z2

次 树 为满2

次 树 或者接近 满 冯 次树, 此时树 的 高度最 小。

性质3: 高 度 为 九 的mn 次 树 最多有只一个结点。

机

证明: 由 树 的 性质2 可知,第 ; 层 上 最 多 的 结 点 数 为 性 一:Ci 一 1 一,显然当高度为六的

妈次树为满双 次 树时 结 点个数 最 多 ,因此 有以下关系 。

最多结点数 = 每 一 层最多结 点 数之和 = 冯 十妈十妇十 十 mm 一 辽

jl1

7 一 1

所以,满呈 次 树 的 另一种 定义 为 当一标高 度为有 的m 次树上的结 点 数等于 和-时称

772

该 村 为满几 次树。合 如 ,对 于 一 标高 度为 5 的满 2 次 树 , 结 点 数为2

二 31; 对 于 一 棵 高

庶为5 的满 3 次 树 , 结 点 数为3二

二 121。

性质4: 具有 )个结点的闷 次树 的 最 小 高 度为 log (zaCm一1)十1) 。

证明: 设具 有 个 结 点 的产 次 树 的 高 度 为灵 , 若 在 该树中 前 一 1 层 都 是 满 的 ,即每一

层 的结 点 数 都 等于 mm 一 个 (1 和 ;入 1 一1) ,第 六 层 ( 即 最 后 一层) 的结 点 数 可 能 满,也 可 能 不

满 ,但 至少有 一 个 结 点 , 则 该 树具有 最小 的 高 度 。

根据树的性质 3 可 得; 妈 一 一1二 1<xn区 到 一 !

7 一 1

7 一 1

前 者 结 点 个数对 应 的 树是 1一/一1 时 都 是 满的,第 大 层只有 一 个 结 点; 后 者 结 点 个 数

对应的树是 1~刀时 都 是 满的。

为了便于 计算 ,将 其 等价地 改 为 ,。思 一 一< 乞 二1

均 乘(m 一1) 后 加 1:

取以闷 为 底的对 数 :

即有 :

7(一1)十1]壹2

一1)十1)反矿
六 一1一 log。(2(02

logw (2a(02 一1) 十1) 近 一 logw(2(02 一1) 十1) 十 1

疡 只 能 取 整 数,所以 有 :

太一 logw (2(C7一1)十1)

结论 得 证 。

aa

例如 ,对 于 2 次 树 , 求 最小 高 度 的计算 公式 为 log: (2 十1) ,若 "一20, 则 最小 高 度为5;

对于 3 次 树 , 求 最 小 高度的计算 公式为 log;(22"十1) ,若 "一20, 则 最 小 高 度为4。

【例7.1】 含有 ?7 个 结 点的4 次 树 的 最 小 高 度是多 少? 最 大 高 度是多 少 ?

根据树的性质 4, 含有 个 结 点的4 次 树 的 最小 高度minh一 log:(3z十1) 。

Q@

z 表示大于等于z 的 最 小 整数,例如 2.4 一3; z 表示小于等于z 的最大 整数,例如 2.8 一 2。

193

数据 结构 教程

虹 第 5 【版

对于4 次 树 , 其 中 至 少有一 个 结 点 的 度 为 4, 这 样 的 树具有 最 大 高 度:除了某一层含有

4 个结 点 以外 ,其 余 各 层 都只有 一 个 结 点 ,显然高度 为xz 一 4 十 1一?一3。所以,含有 7 个 结 点

的 4 次 树 的最大 高度maxh 是 ”一 3。

【例7.2】 若 一 棵 3 次 树 中 度为3 的 结 点有两个, 度为 2 的 结点有 一 个 , 度 为 1 的 结 点

有 两 个,则 该 3 次 树 中 总 的 结 点 个数和 叶子 结 点 个 数 分别是多 少 ?

设该 3 次 树 中 总 的 结 点 个 数为尺度 为 的 结 点 个 数 为 一 (0 过 i 委 3)。 依 题意有

7 一 2,72一1,73一2。

每个度为守 的结 点 在所有 结 点 度数之和 中 贡献让个 度,所以所有 结 点 度数之和 三 1

7 十2X7 十3Xz 一1X2 十2X1 十3X2 王 10。

由 树 的 性 质 1 可 知 ,* 一所有 结 点 度数 之和十1二 10十1一11。

对于 3 次树, 显 然有 7 一xz 十 思 十 2

十 7a 。

则 mm 一7

一 冯

一 如

一 2 二11

一2一1

一3一6。

所 以 该 3 次 树 中总 的 结 点 个数和 叶子 结 点 个 数 分 别 是 11

和 6。

说明: 在m次树中计算 结 点 个 数时常用的 关系式有 : 四所 有 结 点 度 树之和 一 7 一 1;

加所 有 结 点 度数之和 一 站 十 272 十 ... 十 mozm; 2 一 7 十 思 十 ... 十 7 。

715 树的基本 运算

由 于 树 属 于 非线性 结构 ,结点之间的 关系 比线性结构 复杂 一 些,所以 树的运算 比以 前讨

论 过 的 各 种 线性 数据结构 的 运算 要 复杂很 多。树 的 运算 主要 分 为 以下 3 大 类 :

(1) 寻找 满足某种特定 条件的结 点 ,如 寻找 当前 结 点 的 双亲 结 点等;

(2) 搬入 或 删除某 个 结 点,如 在 树 的 指定 结点上 捅 入 一 个 孩子结 点 或

删除指定 结 点 的第 ;个 孩子结 点 等;

(3) 遍历 树 中 的所有 结 点 。

树 的 遍历 (traversal) 运 算是指 按 某 种 方式访问 树 中 的所有 结 点 且 每 一

由

视频计角

个结 点 只 被 访问 一 次 。树 的 遍历 方式主要 有 先 根 遍 历.后 根 遍历和 层次 遍历 3 种。注意,树

的 先根遍历和 后 根 遍 历 过 程 都 是递归 的 。

全 光 根词历

先 根 遍历(preorder traversal) 的 过 程如 下 :

(1) 访问根结点;

(2) 按照从左 到 右 的 顺序 先根遍 历 根 结 点 的 每一棵 子 树 。

例如 ,对 于 图 7. 1(a) 所 示 的 树 , 采 用 先 根 遍历 得 到 的结 点 序列为ABEFCGJDHIKLM。 从

中可以看出, 先 根 遍 历 序列 的第一 个 元 素 即 为 根 结 点 对 应 的 结 点 值 。

2 后 根 吝 廊

后 根 遍 历(postorder traversal) 的 过 程如 下 :

(1) 按照从左 到 右 的 顺序 后 根 遍 历根结 点 的 每 一棵子 树 ;

(2) 访问根结点。

例如 ,对 于 图 7. 1(a) 所 示 的 树 ,采用 后 根 遍 历得到 的结 点 序列为EFBJGCHKLMIDA。 从

中 可 以 看 出 ,后 根 遍 历 序列 的 最 后 一 个 元 素 即 为根结 点 对 应 的 结 点值。

194

人 7 人齐太本和二X村

|

层次 遍历 (level traversal) 的 过 程是从 根 结 点 开始 按从上 到 下 .从 左 到 右 的 次 序 访问 树

中 的 每一个 结 点 。

例如 ,对 于 图 7. 1(a) 所 示 的 树 , 采 用 层次 遍历 得 到 的结 点 序列为ABCDEFGHUKLM。 从

中 可 以 看 出 ,层次 遍历 序列 的 第 一 个 元 素即 为 根 结 点 对 应 的 结 点 值 。

716 树 的 存储 结构

存储 树的基本 要 求是既 要 存储结 点 的数据元素本身, 又 要存储结点之间的 逻辑 关系 。

有 关 树 的 存储 结构 很多,下面介绍 3 种 常用 的 存储 结构 , 即 双 亲 存 储结构、 孩子链 存储 结构

和 孩子兄弟 链 存储 结

全 双亲和存傅结焰

是一种顺序存储结构,用一组
双亲 存储 结构(parent storage structure)

连续 空间 存储 树 的所有 结 点 ,同时 在 每 个结 点 中 附设 一 个 伪 指 针指 示 其 双

亲 结点 的 位 置(因为除了 根 结 点以 外 ,每 个 结 点只有 唯一 的 双亲 结 点 ,将 根

结 点 的 双亲 结 点位 置设置 为特殊 值 一1) 。

双亲 存储 结构 的 类 型 声明 如 下 :

typedef struct

{

ElemType data;

int parent;

//存放结点的值
/存放 双亲 的 位 置

} PTree[MaxSize] ;

//PTree 为 双亲 存储 结构 类 型

例如 ,图 7.2(a)

所 示 的 树 对 应的双亲 存储结构如 图 7. 2(b) 所 示 ,其 中 根结 点 A 的 伪 指

针 为 一1, 其 孩子 结点BC 和 D 的双亲伪指针均 为 0,E.F 和 G 的 双亲 伪指针均为2。

@
加 (CO

中 O 9

data

parent

"各
;加 |

0

4

|E

2

:二

2

(a) 一棵树

(b) 对 应的双亲存储结构

图 7.2 一 棵 树 的 双亲 存储 结构

该存储 结构 利用 了 每个结 点 ( 根结 点 除外)只 有 唯一双亲 的 性 质。在 这 种 存储 结构 中 ,

求 某 个 结 点 的 双亲 结 点 十 分 容易,但 在 求某个 结 点 的 孩子结点时 需要 遍历 整个存储结构 。

2 孩子估存俏结和

在 孩子链 存 储 结构(child chain storage structure) 中 ,每 个结 点 不 仅 包含结 点 值 ,还包

括 指向所有 孩子结 点 的指针 。 由 于 树 中 每 个 结 点 的子树 个数( 即 结 点的度)不 同 , 如 果 按 各

个结 点 的 度设计 变 长 结构, 则 会 因为结 点 的 孩子结 点 的 指针 域 个 数不同而导致算法 实现 非

数据 结构教程

[第! 5版

常 麻烦。孩子链 存储 结构 可 按 树 的度(即 树中所 有 结 点 度 的 最 大 值)设计 结 点 的 孩子结点的

指针域个数。

孩子链 存储 结构 的 结 点 类 型声明 如 下 :

typedef struct node

{

ElemType datai

//结点的值

struct node * sons[MaxSons]; // 指 向 孩子结点

) TSonNode;

// 孩子链 存 储结构 中 的 结点类 型

其 中,MaxSons 为最多 的 孩子结 点 个 数 ,或 称 为该树的度 。

例如 ,图 7.3(a)

所 示 的 一 棵 树 ,其 度为 3, 所以 在 设计 其 孩子链 存储 结构 时 每个结 点 的

指针域个数应为 3, 对 应 的 孩子链 存储 结构 如 图 7. 3(b)所示 。

sons[]

data_ sons[0]

sons[2]

包

[

和

人

ORGe <1

B

,

C

人 |A人|和A

人A|A|

国 IAAIA

-二

G|IAIAIA

(a) 一 棵 树

(b) 树的孩子 链 存储结构

A 困| 雪-|国| 沁-[AUEI和

t

人 |G| 入

(9)

树 的 孩子兄弟 链 存储结构

图 7.3 一 棵 树 的 孩子链存储 结构和 孩子兄弟 链存储 结构

孩子 链 存储 结构 的 优点 是 查找 某 结 点 的 孩子 结 点 十 分 方便,其 缺点 是查找 某 结 点的双

PE

亲 结点 比较 费时 ,另外 , 当 树 的 度 较 大 时 存在 较 多 的 空指针 域 。

【例7.3】 以 孩子链 作为树的 存储 结构 ,设计 一 个 求树 上 高度的递归算法。

设 Fo)为树 上 的 高度, 其递归 模型如下 。

GD 一 0
FGD 一 MAX {FCp))十1 其他情况

若 :一NULL

指向的孩子

对 应 的递归 算法如下 :

196

7As放机和=X村

|

int TreeHeightl(CTSonNode * t)

{

TSonNode *p;

int i,h, maxh 一 0;

让 (t==王NULL) return 0;

else

{

for(i=0;i< MaxSons;i 十十)

{

, p=t一> sons[口;

计 (p!=NULL)

// 空 树返回高度 0

// 处 理 非 空树

//p 指向 t 的第 i十1 个 孩子结点
//若存在第 i 计 1 个 孩子

,h=TreeHeightl(p);

// 求出对 应 子 树 的 高 度

让 (maxh< h) maxh一h;

// 求所有 子 树 的最大 高 度

{

】》

】》
returnCmaxh 十1);

// 返回maxh十1

)}

3 孩子郊弟估存储结焰

孩子 兄弟 链 存储 结构 (child brother chain storage structure)

是为每个结 点设计 3 个

域 ,即 一 个 数据 元 素 域.一 个 指向 该 结 点 的 左边 第 一 个 孩子结 点 (长 子)的 指针 域`一 个 指向

该结 点 的下一 个 兄弟 结 点 的 指针 域 。

兄弟 链 存储结构 中 结 点 的 类 型声明 如 下 :

typedef struct tnode

{

ElemType data;

Struct tnode 关 hp;

Struct tnode x vp;

//结点的值

//指向 兄弟

//指向 孩子结点

} TSBNode;

// 孩 子兄弟 链 存储 结构 中 的 结 点 类 型

图 7. 3(a) 所 示 的 树 的 孩子兄弟 链 存储 结构如图7. 3(c)所示 。

由 于 树 的 孩子兄弟 链 存储结构 固定有 两个指针 域,并 且 这 两个指针 是有序 的 ( 即 兄 弟 域

和 孩子 域不能 混淆 ) ,所 以 孩子兄弟 链 存储 结构 实际上 是 把 该树转换为二 又 树的存储 结构 。

在 后 面 将 会 讨论 ,把 树 转 换 为 二又树 所 对 应 的 结构恰好 就是这 种 孩子兄弟 链 存储 结构 ,

所以 孩子兄弟 链存储 结构 的最大 优点 是 可 方便 地 实现树和 二 又 树 的 相互转换。孩子兄弟链

存储结构 的 缺点和 孩子 链存储结构 的 缺点 一 样 ,就 是从当前 结 点 查找 双亲 结 点比较麻烦 , 需

要 从 树 的 根 结 点 开始 逐个 结 点比较 查找 。

【例7.4】 以 孩子兄弟 链 作为 树的存储 结构 设计 一 个 求树 : 高 度 的递归 算法 。

其递归 模型 与例 7. 3 的完全 相同 ,针对 孩子兄弟 链 存储 结构,对 应 的递归 算法

如 下 。

int TreeHeight2(TSBNode * t)

{

TSBNode *p;

int h, maxh一0;

这 (t=王NULL) return 0;

//空树返回0

else

{

, p=t一vp;

//p 指向 第 1 个 孩子结 点

197

Ta

数据 结构教程

(第5 【版

while (p!I=NULL)

// 扫 描 t的所有子树

{

, h=TreeHeight2(p);

让 (maxh< h) maxh一h;
p 一D

一 hp;

// 求出 p 子树的 高 度
// 求所有 子 树 的最大 高 度
// 继 续 处理 t 的其他 子 树

)》
return(maxh 十 1);

// 返回maxh十1

)}

例 7.4 和例7. 3 的 功能 相同 ,但 树 的 存储 结构 不同 ,所以 在 算法 设计 上 存在 差异。

说明: 当 树 采用 孩子兄弟 链存储 结构时 , 树 的 算法和广义 表 的 算法设计 方法 十分相似 。

二 叉树 的概念和 性 质 洒

721 二 叉 树 的 定义

二 叉 树(binary tree) 是 一 个 有 限的结 点 集合 ,这 个 集合或者为空 ,或 者

和右子树 (right
由 一 个 根结 点 和 两棵 互 不相交 的 称 为 左 子 树 (left subtree)

视频讲解

subtree)
的二叉树组成。

二 又 树 的 抽象 数据 类 型 描述和 树 的 抽象数据 类 型 相似,这里不再

介绍。显 然,和树的定

义 一 样,二 又 树 的定义 也 是 一 个递归

定义。二 叉 树 的 结构 简单.存储 效率 高,其 运算 算法 也

相对简单 ,而且任何产次 树都可 以 转化为二 又 树结构 ,因此 二 又 树具有很重要 的 地 位 。

二 又树和 度为 2 的树(2 次 树 ) 是 不 同 的,对 于非 空树, 其 差别 表现 在以 下 两 点 :

。 度为2 的树 中 至 少 有 一 个结 点 的 度为 2, 而 二 又 树 没有 这 种 要 求 ;

。 度为2 的 树不区 分 左 、 右 子树 ,而 二 又 树是严格 区 分 左 、 右 子 树的 。

二 又树有 5 种 基本 形态,如 图 7.4 所 示 ,任 何 复杂 的 二 叉 树都可以 看 成是这 5 种 基本 形

态 的 复合 。其 中 图 7. 4(a)是空二 又树,图 7. 4(b)是 单个结 点 的 二 叉树, 图 7. 4(c)是 右 子 树

为 空的二 又树 ,图 7.4(d)是 左子树 为 空的二 叉 树 ,图 7. 4(e)是左、右子树 都 不 空的二 又 树 。

peee

图 7.4 二 又 树的5 种 基本 形态

(a)

人 b)

(9

(d)

(e)

二 又 树 的 表示 法 也 和 树 的 表示 法 一 样,有 树 形 表示 法 、文氏 图 表示 法.上思人 表示 法 和 括

号 表示 法 等 。另 外 ,上 一 节 介绍 的 树 的所有 术语对 于 二 又 树 都适用 。

在 一 棵 二 又 树 中 ,如 果 所 有 分 支 结 点 都有左 孩 子 结点和 右 孩 子 结 点 ,并 且 叶 子 结 点 都 集

中 在 二 又 树 的最下 一 层,这 样的二 又 树 称 为 满二叉 树 (full binary tree)。 图 7.5(a)所示就

是 一 棵满二 又 树。用 户 可 以 对 满二又 树 的 结 点 进行层序 编号(level coding) ,约定 编号从 树

198

7As放机和-X村

|

根为 1 开始 ,按照 层数从小 到 大 、 同 一 层从左 到 右 的 次 序 进行 ,图7.5(a)

中 每个结 点 外 边 的

数字 为 对 该 结 点 的

编号 。当 然 也 可以 从 结 点 个数和 树 高 度 之 间 的关系来定义, 即 一 棵 高 度

为关且有必 一 1 个 结 点 的 二 叉 树 称 为满二 又 树 。

图 7.5 满 二 又树和 完全 二 又 树

(b) 完全二又树

非 空满二 又 树 的特点如 下 :

。 叶子结 点 都在最下 一 层 ;

。 只 有 度 为0 和 度为 2 的结 点 。

若 二 叉 树 中 最 多 只 有 最 下 面 两层的 结 点 的 度数 可以小于 2, 并 且 最 下 面 一 层 的叶子

结 点都依次 排列 在 该 层最左边 的位 置上, 则 这 样的二 又 树 称 为完全 二 叉 树 (complete

binary tree) ,图 7.5(b)

所 示 为 一 棵完全 二 叉 树。同 样 可以对 完全 二 又 树 中 的 每 个 结 点 进

行 层 序 编号 ,编号的 方法和 满 二 又 树 相 同,图 7.5(b)

中 每 个 结 点 外 边的数字 为对 该 结 点

的编号 。

不 难看出 ,满二 又 树 是完全 二 又 树 的 一 种特例 ,并且 完全 二 又 树与同 高 度 的满二 又 树 的

对 应位 置 结点有 同一 编号 。图 7.5(b) 所 示 的 完全 二 又 树 与 等 高度的满二 又 树 相 比 在 最 后

一 层 的右边缺少了 4 个结点。

非 空完全 二 又 树 的特点如 下 :

。 叶子结 点 只 可 能 在最下 面 两层中 出现 ;

。 对 于 最 大 层次 中的叶子结 点 ,都 依次 排列 在 该 层最左边的位 置 上 ;

。 如 果 有度为 1 的结 点,只 可能 有 一 个 , 且该结 点只有 左 孩子而 无 右 孩子;

。 按 层 序 编号时 ,一 旦 出现编号为让 的结 点 是叶子结 点 或 只 有 左孩 子 , 则 编号 大 于 :的

结 点 均 为叶子结 点 ;

” 当结点总数半 为奇数时,盖0,当结 点 总

数羡为偶数时,mm二 1。

722 二叉树的性质

性质 1: 非 空二又树 上 的叶子结 点 数 等于 双 分 支 结 点 数 加 1。

证明: 设 二 又树上 的叶子 结 点 数为 四. 单 分 支 结 点 数 为 、 双 分支结 点

数 为 思 ( 如 果 没有特别 指出 ,后 面均采用 这 种 设 定), 则 总 结 点 数 x一闸十普

十挛。在 一棵二 又树中 ,所 有 结 点 的 分 支 数 (即所有 结 点 的 度 之和 ) 应等于
单 分 支 结 点 数加 上 双 分支结 点 数 的 两 倍 , 即 总 的 分 支数= 普 十 2 。

0

199

数据 结构教程

[第5 【版

由 于 二 又 树 中 除了 根 结 点以 外 ,每个结 点 都有唯一 的一个 分支指向它, 因 此 在 二 又 树 中

总 的 分 支数=7 一 1。

由 上 述 3 个 等式可 得 半 十222 一 加 十 刀 十 2 一1, 即 mo 一 2 十 1。

说明: 在 二 又 树 中计算 结 点 时 常用的 关系 式有 : 四所 有 结 点 的 度之和 一 7 一 1; 加 所 有

结 点的度之和 三 四 十272; 7 一zz 十 思 十 7 。

性质2: 非空二 又 树的 第

层 上 最多有 2 一:个结 点 Ci 全 1)。

由 树 的 性 质 2 可 推出 。

性质3: 高 度 为 疡的 二 叉 树 最多有 入 一 1 个结 点 (三1) 。

由 树 的 性质 3 可 推出 。

性质4: 完全 二 又树中 层 序 编号 为二的结 点(1 受 i 友 27 人 17 为结 点 数)有以 下 性 质 :

(1)

若 过 22 ,即 2 和 2, 则 编号为守 的结 点 为 分 支结 点 ,否则 为叶子结 点 。

(2) 若 7 为 奇数, 则 每 个 分 支结 点都 既 有 左 孩 子结 点 ,又 有 右 孩 子结 点 (例如 图 7.5(b)

所 示 的 完全 二 又树 就是这 种情况 ,其中 * 王 11,分支结点 1一5 都 有 左 、 右 孩子 结 点); 若 7 为

偶数 , 则 编号最大的 分 支结 点 (编号为w/2 ) 只 有 左 孩 子结 点 ,没有 右孩 子结 点 ,其 余 分 支结

点都 有左右孩子结点。

(3) 若编号 为 字 的结 点 有 左孩 子结 点 , 则 左 孩子结 点 的编号为2; 若 编 号 为站的结 点 有

右 孩 子结 点 , 则 右孩 子结 点 的 编号为 2 十 1。

(4) 除根结 点以外 , 若 一 个结 点 的 编号 为 刻 则 它的双亲 结 点的编号为/2 。

上 述 性 质 均 可 采用 归纳 法 证 明 ,请 读者自己 完成 。

性质$: 具有 个 (2二 0) 结 点 的 完全 二 又树 的高度为 log: (zz十 1)

或 log 十 1。

由 完全 二 又 树 的 定义和树 的 性 质 3 可 推出 。

说明: 对 于 一 棵 完全 二 又 树 , 结 点 总数寻 可 以确定 其 形态,ma 只 能是0 或 1。 当 宛 为偶

数时,轨一1; 当 刀 为 奇数时,mm 一0。

【例7.5】

已 知一棵完全 二 又 树 的第 6

层 ( 设 根 为第 1 层)有 8 个叶子 结 点 , 则 该 完全

二 又 树 的 结 点 个 数 最 多 是 多 少 ?

完全 二 又 树的叶子 结 点 只 能 在 最 下 两 层 ,对 于 本 题,结 点 最 多 的 情况 是 第 6 层 为 倒

数第二层,即 1一6 层 构成一个 满 二又树 ,其 结 点 总 数 为 2 一 1一63。 第 6 层有于 二 32 个结

点 ,其中含 8 个叶子 结 点 ,另外有 32一8一24 个非 叶 子 结 点 ,它们 中 的 每个结 点 都有两个孩

子 结 点 ( 均 为第 7 层的叶子结点) , 计 48 个 叶子 结点 ,这样 最 多 的 结 点 个 数 =63 十48=111。

723 二叉树与树、森林之间的转换

PE

树,森林 与二又 树 之间有 一 个 自然的对 应 关系 ,它们 之 间 可 以 互相转换,即任何一个 森

林 或一棵 树 都可以 唯一地 对 应一棵 二 又 树 ,而任一 棵 二 又 树 也 能 唯一地 对 应 到 一 个森林 或

一 棵 树上。 正 是由于 有 这 样 的 一一对 应 关系 ,可以把 在 树 中 处 理 的问题对应 到 二 又 树 中 进

行 处理, 从而把 问题 简单化,因此 二 又 树在树 的 应用中 显得 特别 重要。下面 要-己
介绍 森林 、 树 与 二 又 树 相互转换 的 方法 。

忌

全 森林、 树续 换 为一义树

这 种 转换 分 为 两种情况 ,一 是 单棵树 转换 成二又 树 ,二 是 由 多 棵 树 构成

200

7As放机和=村 |

的 森林 转换成二 又 树 ,但 是 不 论 哪 种情况 都只转换 成 一棵二 又 树 。

将 一 棵 树 转换 成二又 树 的过程如下 :

(1) 树 中所有 相 邻 兄弟之间 加 一 条 连 线 ;

(2) 对 树 中 的 每个结点只 保留它与 长 子之间 的 连线, 删 除 与其他 孩子之间 的 连 线 ;

(3) 以 树 的 根 结 点 为 轴 心 ,将 整 棵 树顺时 针 转动 45" ,使 之结构 层次 分 明 。

【例7.6]】 将图7. 6(a) 所 示 的 树 转换 成二又 树 。

(c) 删除 与双亲 节点的 连线

(d) 转换后的二又树

图 7.6 一 棵 树 转换 成一棵 二 又 树 的 过 程

转换过程如图7.6(b)

一(d) 所 示 , 最 终结 果 如 图 7.6(d)所示。

从 中 可以 看 到 ,一 棵 树 工 转 换 成二叉 树 BT 后,BT 中 的 左 分 支仍表示 工 中 的 孩子关

系 ,但BT 中 的 右 分 支却表示 工 中 的 兄弟 关系。由于工 的 根 结 点 没有兄弟 ,所以 BT 的 根 结

点 一 定 没有右 孩 子结 点 。

若 要 转换 为二叉 树 的 森林 由 两 棵 或 两 棵以上的 树 构 成,将 这 样 的森林 转换 为 二 叉 树 的

过 程如 下 :

(1) 将森林 中 的 每 棵 树转换 成相应 的 二 又 树 。

(2) 第 一 棵 二 又 树 不 动,从 第 二 棵 二 又 树 开始 ,依次 把后一 棵 二 又 树 的 根 结 点 作为 前 一

棵 二 又 树 根 结 点 的 右 孩子结 点,当 所 有 二 又 树 连 在 一 起 后 ,此 时 得 到 的 二 又 树 就 是由森林 转

换得 到 的 二 又 树 。

实际上,当森林 下 由 两 棵 或 两 棵以上 的 树 1 ,7T ,7T} 构 成时,所 有 这 些 树 的 根结
点 构成兄弟关系 ,所以森林 下转换成一棵二又树BT 后,将第一棵树 厂 的 根 结 点 作为 BT

Sn

的 根 结 点 与,T 的 根 结 点 作为 卖 的 右 孩 子结点 二 ,Ts 的 根 结 点 作为 妃 的 右 孩 子 结 点二 ,...,

【例7.7】 将图7.7(a)

所 示 的 森林 转换成二 又 树 。

转换过程如图7.7(b)

一(e) 所 示 ,最 终结 果 如 图 7.7(e)所示。

【例7.8】〗

设 森 林 正 中 有 3棵树,第1、第2第 3 棵 树 的结点个 数 分 别 为 9.8、7,将其转

可

数据 结构 教程

\BOG

(a) 森林

OO

了

ONEORGRG

(b) 相 邻的 兄弟 加 连线 (虚线 )

G 人

@

Wo
)

(c) 删除 与双亲 结 点的 连 线

(gd) 每 棵树转换 成 的 二 又 树

(e)

所 有 二 又树连接成一棵 二 又树

图 7.7 森林 转换 成 一棵二 又 树 的 过 程

换成二 又 树 ,该二又 树 根结 点 的 右 子树上 的 结 点 个 数是多 少 ?

与 森林 下 对 应 的 二 又 树 根 结 点 的 右 子树上 的结 点 是 由 第 2 和 第 3 棵 树 的 全 部 结 点

转换 而 来 的,所 以 二 又 树 根 结 点 的 右 子树上 的 结 点 个数=8十7一15。

2古林

由 于 转换 过 程 分 为两种 情况,所以 还原过 程也相应 地 分 为两种 情况,一是由 单棵树 转换

成的二 又 树还原 成树, 二 是 由 多 棵 树 构成 的森林 转换 成 的二又 树 还 原成树 。

若一棵 二 又 树是由 一 棵 树 转换 而 来 的 , 则 该 二 又 树还原 为树的 过 程如下 :

(1) 若 某 结 点 是 其 双亲 的 左 孩 子 , 则 把 该结 点 的 右 孩子. 右 孩子的右 孩 子 等 都 与 该结点

的 双亲 结 点 用 连 线 连 起 来 。

(2) 删除原二 又 树 中所有 双亲 结 点 与 右 孩子结 点 之间 的 连 线 。

(3) 整理由 前 面 两 步 得 到 的 树 ,即以 根结 点 为 轴 心 , 着 时 针 转动 45 ,使 之结构 层次分明 。

实际上 ,二 又 树 的还原 就 是将二 又 树 中 的 左 分 支保持 不 变 ,将 二 又 树 中 的 右 分 支还原 成

【例7.9】 将图7.8(Ca)所示的 一 棵 二又树还原 为一棵 树 。

还原过程如图7.8(Cb)

一(d) 所 示 , 最 终结 果 如 图 7.8(d)所示。

若 一 棵 二 又 树是由 疡 棵 树 构 成 的森林 转换 而 来的,该二又 树 的 根 结 点 一 定有思 一 1 个

202

树和二又树

人)

@

ORG

NO

(a) 一 棵 二 又 树
愉Q

(B)
人昌 IIG

/

AN

, A\

|

人

1

MEO

CO)

(b) 加 连线

OOMRO

昌 D

q

(c) 删除与右孩子的 连 线

(d)还原后的 树

图 7.8 一 棵 二 又 树还原 为一棵 树 的 过 程

右下孩子,该二又 树 还原 为森林 的 过 程如 下 :

(1) 抹 掉 二 叉 树 根结 点 右链上 的所有 结点 之 间 的 “双亲一右 孩 子?关 系 ,将 其 分 成若干

个 以 右链上 的 结 点为根结 点 的 二 又 树 , 设 这 些 二 又 树为 bt .bt ......、btn。

(2) 分别 将 bu .bt 、...、\btw 二 又 树 各 自还原 成一棵 树 。

【例7.10】〗

将 如 图 7.9(a) 所 示 的 二 又 树还原 为森林 。

还 原 为森林 的 过 程如图 7.9(b)

和 (c) 所 示 , 最 终结 果 如 图 7.9(c)所示。

0

(a) 一棵二四 (b) 分为3棵 二又树

(c) 还原 成的森林

图 7.9 一 棵 二又树还原 成森林 的 过 程

二义树的 存储 结构

漆

与 线性表 一 样,二 又 树 也 有 顺序 存储结构和 链 式 存储 结构 。

203

数据 结构教程

[第! 5人版

731 二 叉 树 的 顺序 存储 结构

二 又 树 的 顺序 存储 结构 就 是 用 一组地 址 连续 的 存储 单元 来存放 二 又 树 的 数据元 素 , 因

此 必须 确定好 树 中 各 数据元 素 的存放 次序 ,使得各 数据元 素 在 这 个 存放 次 序 中 的相互位置

能 反映 出 数据元 素 之间 的 逻辑 关系 。

由 二 叉 树 的 性 质 4 可 知 ,对 于 完全 二 又 树和 满 二 又 树 , 树 中 结 点 的 层序 编号可 以 唯一地

反映 出 结 点 之 间 的 逻辑 关系 ,所 以 可以 用 一 维 数组 按 从 上 到 下 、 从 左 到 右 的 顺序 存储 树 中 的

所 有 结 点 值,通 过 数组元 素的下标 关系 反映 完全 二 又 树 或满二 又 树 中 结 点 之 间 的 逻辑 关系 。

例如 ,图 7.5(b)

所 示 的完全 二 又 树 对 应 的 顺序 存储结构 如 图 7. 10 所示 ,编号 为宇的结

点 值存放 在 数组 下标为; 的元 素中 ('# ' 表 示 空 结 点) 。 由 于 CVC++

语言中的数组下标从 0

开始 ,这里 为了一 致 性 而 没有 使用下 标 为 0 的数组元素。

育 呈

了下

12345678 9

10 1 1 3 1 ...

MaxSize-l

点值 |AjBljclplEglFflclalIlrlK|t#|#|#|...

#

图 7.10 一 棵 完全 二 又 树 的 顺序 存储 结构

然而对 于 一 般 的 二 叉 树 ,如 果 仍 按照从上 到 下 和 从 左 到 右 的 顺序 将 树 中 的 结 点 顺序 存储

在 一 维 数组 中 , 则 数组元 素 下标 之 间 的 关系 不 能够反映 二 又 树 中 结 点 之间 的逻辑关系,这时可

将 一 般 二 叉 树 进行改造 ,增添 一些并 不 存在 的 空 结 点 ,使 之 成 为一棵 完全 二 又 树 的 形式 。

图 7. 11(a) 所示 的 是 一 棵 一 般 的 二 又 树 ,添加 一 些 虚结 点 使其成 为一棵完全 二 又 树 的结果

如图 7. 11(b) 所示 , 再对所 有 结 点 按 层 序 编号,然后仅保留 实际 存在 的 结 点 ,如图 7. 11(c)所

示。接 着 把 各结 点 值 按 编 号存储 到 一 维 数组 中 ,在 二 叉 树中人 为 增添 的 结 点 ( 空结 点 ) 在 数

组 中 所 对 应 的元 素 值 为 一特殊 值 ,例如 '# ' 字 符 , 如 图 7.12 所示。

扫 一扫

(人b) 添加 虚结 点 使 其 成 为一棵 完全 二 又 树

图 7.11 一 般 二又树 按完全 二 又 树 结 点编号

204

(9) 仅保留 实际存在的结点

图 7.11

(续)

位 置 1234356789 10 112 13

14

...

MaxSize-l

结 点值 |A|B|C|lD|E|#|F|#|#|G|H|#|##|

工 | #

加

图 7.12 一 棵 二 叉树的 顺序存储 结构

也 就 是说 ,一般二 又 树 采 用顺序 存储结构 后,二 又 树 中 各 结 点 的编号 与 等 高度的完全 二

又 树 中 位置上 结 点 的 编号相同 ,这样对于 一 个 编号(下标 )为;的 结 点 ,如 果 有 双亲 ,其 双亲

结 点 的 编号(下标 )为2 ; 如 果 它 有 左 孩 子,其 左 孩子结点 的 编号(下标 )为22;

如 果它有

右 孩 子,其 右 孩子结 点 的 编号(下标 ) 为 2 十 1。

二 又 树 顺序 存储结构 的 类 型 声明如 下 :

typedef ElemType SqBinTree[MaxSize] ;

其中,ElemType 为 二 又 树 中 结 点 的数据值类 型 ,MaxSize 为 顺序 表 的 最 大长 度 。 为了方便

运算 ,通常将下标为 0 的位 置 空着, 空结 点 用 '# ' 值 表示 。

显然,完全 二 又 树 或 满二又 树 采 用 顺序 存储 结构比较合适 , 既 能 够最大 可 能 地 节省 存储

空间 ,又 可以利用 数组 元 素 的 下标 确定结 点 在 二 叉 树 中 的 位 置以 及结 点 之间 的 关系 。 对于

一 般 二 又 树 ,如 果 它 接近 于 完全 二 又 树 形态 ,需要 增加 的 空结 点 个 数 不多,也 可以 采用顺序

存储结构。如 果 需 要 增加很 多 空结 点 才能 将 一 棵 二 又 树 改造成 为一棵 完全 二 又 树 ,采用 顺

序 存储结构 会 造成 空间 的 大 量 浪费。最坏情况是右 单 支树( 除叶子结 点 外 每 个结 点只有 一

个 右 孩子) ,一棵高度 为疡的 右 单 支 树 ,只有 大 个 结 点 , 却需要分配 六 一 1 个 存储 单元 。

在 顺序 存储结构 中 ,查找 一 个结 点 的 孩子,双亲 结 点 都 很 方便,编号(下标 ) 为 字 的 结 点

的 层次为log:(Gi十1) 。

由 于 二 又 树 顺序 存储 结构具有 顺序 存储结构 的固有 缺陷 ,使 得二又 树 的插和人 、 删 除 等运

算 十 分 不 方便。因 此 ,对 于 一 般 二 又 树通常采用 下 面 介绍 的 链 式 存储 方式 。

732 二 叉 树 的 链 式 存储 结构

二 又 树 的 链 式 存储结构 是 指 用 一 个 链表 来存储 一 棵 二 又 树 , 二 又 树 中 的 每 一 个结 点 用

链表 中 的 一 个 结 点 来 存储。二 又 树 链 式存储结构 中结 点 的标准 存储 结构如 下 :

lchild

data

Tchild

数据 结构教程

[第! 5版

其中,data 表示 值 域 ,用 于 存储对 应 的 数据 元素,lchild 和 rchild 分 别 表示 左 指针 域和

右 指针 域 , 分别用于 存储 左 孩 子 结点和 右 孩子结 点 的 存储 地 址 。这 种 链 式 存储 结构 通常简

称 为二叉 链 (binary linked list) 。二 又 链 中 通过 根 结 点 指针 也 来 唯一标识 整个存储 结构 , 称

为 二 又树2。

二 叉 链 中 结 点 类型BTNode 的声明如下 :

typedef struct node
{
ElemType data;
struct node * lchild;

struct node * rchild;

} BTNode;

//数据元素
// 指 向 左 孩子结 点

// 指 向 右 孩子结点

由 于 本 章 后 面 的 算法 均 用 到 二 又 链 存 储 结构 ,为 此 将 其 类 型定义 存储 到 头 文件btree. h

中。例如,图 7.13(a)

所 示 的 二 又 树对 应 的 二 又 链 存储 结构 如图 7. 13(b)所示 。

人
gb
局

人 下
几、

八 |G| 人

(a) 一 棵 二 又 树

人b) 二 又 链 存 储结构

图 7.13 一 棵 二 叉树及 其 二 又 链存储 结构

二 又 链 存储 结构 的 优点是对 于 一 般 的 二 又 树比较 节 省 存储 空间 ,在 二 又 链 中 访问 一 个

结 点 的 孩子 很方便 ,但 访问 一个结 点的双亲 结 点需要 扫描所有 结 点 。有 时为了 高效地 访问

这样就构成了
一 个 结 点 的 双亲 结点,可 在 每 个 结 点 中 再 增加 一 个 指向双亲 的 指针 域 parent,

二 又 树 的 3 又 链表 ,其 结 点 结构如图7.14 所示。

lchild

parent

data

rchild

图 7.14 二 又 树的3 又链表结点结构

说明:

为了简便 ,在后面 讨论的二 又 树 中 均 假设 每 个 结 点 值 为 单个字符 , 即 ElemType

为 char 类型。在 没有特别指出 的 情况 下 ,假设一棵 二 又 树 中 的所 有 结 点 值 均不相同 。

PE

二 叉树 的 基本 运算 及 其 实现

741 二 叉 树 的 基本 运算 概述

归纳 起 来,二 叉 权 有 以下基本 运算 ,为了 方便 ,假设二 又 树均采用 二 又 链存储 结构 进行存储 。

206

7As放 机和村 |

。 创建二又树 CreateBTree(b,str): 根据 二 又 树 括号表示 法 字符 串 str生成对应的二

又 链 存储 结构 ,0 为创建的二 又 链 的 根 结 点 指针 。

。 销毁二叉树DestroyBTree(&2): 释放二又树纪中 所 有 结 点 分 配 的空间 。

。 查找 结 点 FindNode(2,z): 在 二 叉树和 中 寻找 data 域 值为二 的 结 点 ,并 返回指向 该

结点的指针 。

。 找 孩 子 结 点 LchildNode(p)和 RchildNode(z): 分 别求二 又 树 中 妃 所 指 结 点 的 左 孩

子 结点和 右 孩子结 点 。

。 求 高度BTHeight(0):求二又树2 的 高度。

。 输出二又树DispBTree(2): 以 括号 表示 法 输出 一 棵 二 又 树 5。

742 二 叉 树 的 基本 运算 算法 实现

本 小 节 采 用 二 又 链 存储 结构 讨论二 又 树的基本 运算 算法 。

二OF

假设 采用 括号 表示 法 表示 的 二 又 树 字符 串 str 是正确的,用 ch 扫措 str,其中只有 4 类

字符 ,其处理 方式如 下 。

。 若 ch='(': 表示 前 面 刚创建的结 点 户 存在孩子结 点 ,需要将 其 进栈作为 栈 顶结 点 ,

以便 建立 它和 它的 孩子结 点 之间 的 关系 (如 果 一 个结 点 刚 创 建 完毕, 其后一 个 字符

不是'('", 表 示 该结 点 是叶子结 点 ,不 需要进 栈) 。 然后开始 处理 该结 点 的 左孩 子,置

三 1( 表示 其 后 创建的结 点将 作为 这 个栈 顶结 点的 左 孩子结 点 ) 。

。 若 ch=')': 表示以 栈 顶结 点 为 根结 点 的 子 树 创 建完毕 ,将其退 栈 。

。 若 ch=',: 表示 开始处理 栈 顶结 点 的 右 孩 子结 点 ,置 上 一 2( 表 示 其 后 创建 的结 点将

作为 当前 栈 顶结 点 的 右 孩 子结 点 ) 。

。 其他情况: 只 能 是 单个 字符 ,对 应 二 又 树中 的 某 个结 点值 ,需要 创建

一 个结 点 户 存 放 该结 点 值

。根据& 值 建立它与栈 顶 结 点 之间 的联

系 。当 A=1 时 ,将结 点 作 为栈顶结 点 的 左 孩 子; 当 & 一 2 时 ,将结

如 此 循环直到 str 处 理 完毕。算 法 中 使用一 个 栈 St保存双亲结点 ,top 视岂if册

为 栈 顶指针,& 指定 其 后处理 的 结 点是双亲 结点( 栈 顶 结 点 ) 的 左 孩子 (一

1) 还 是 右 孩 子 ( 一 2) 。

对应的算法如下 :

井 include "btree.h"
void CreateBTreeC(BTNode x B&&b,char x str)
{

BTNode * St[MaxSize], * p;

int top 一一1,k,j一0;

char ch;
b=NULL;

ch一strD;

while (ch! 一 \0)

{

switchCch)

{

207

// 包 含 二 叉 树 的存储 结构 声明

ss

//St 数 组 作为 顺序 栈

V/top 为 栈 顶 指针

// 初始时 二 叉 链 为空

//循环扫描 str 中 的 每个字符

数据 结构教程

[第! 5人版

case '(':top 十十;St[top] 一p;k一1; break;

// 开 始处理 左 孩子结 点

case 0) :top 一 一 ;break;

case ',':k一2; break;

// 栈 顶 结 点 的 子 树处理 完 毕

// 开 始 处理右 孩子结 点

default:p

一(BTNode * )malloc(sizeof(BTNode)); ”// 创 建一个 结 点 ,由 P 指向它

p -> data一ch;

// 存 放 结 点 值

p ->1lchild一p 一 rchild王NULL;

// 左 \ 右 指针 都设置 为空

让 (b==NULL)

b 一 p;

else

{

switch(k)

{

// 若 尚未 建立根 结 点
//p 所 指 结 点就作为根结 点

// 已 建立二 叉 树 根 结 点

一p;break;
case 1:St[top]-> lchild

// 新 建 结点作为栈顶 结 点 的 左孩子

case 2:St[top]一 rchild一p;break;

// 新 建 结点作为栈顶 结 点 的 右孩子

}

j 寺 十 ;
ch一str[D ;

)}

//继续扫描 str

建立二又树链式存储结构的
例如 ,对 于 括号 表示 的 字符 串“A(B(D(,G)),CCE,F))”,

过 程如 表 7.1 所 示 ( 栈 中 的 元素A 表示 A 结 点的地 址) ,最后生成的二 又 链 如 图 7. 13(b)

所示 。

表 7.1 建立二叉 树 链 式 存储 结 构的过 程

算法 执行 的 操作

St 中 的 元 素 ( 栈底 空栈顶)

ch

A

(

B

(

D

(

,

G

)

)

,

建立 A结点 ,指向该结点

和A 结 点 进 栈 ,置人一1

建立 B结点,因&=]1, 将其作为 A 结 点 的 左 孩子

也 结 点 进栈,置人 一 1

建立 D结点,因& 一 1, 将 其 作为也结 点 的 左 孩子

D 结 点 进栈,置 人 一1

置 人 一 2

建立 G 结 点 , 因 & 一 2, 将其作为 D 结 点 的 右 孩子

退 栈 一 次

退 栈 一 次

置 人 一 2

ee

C 建立C结点,因& 一 2, 将其作为 A 结 点 的 右 孩子
(
开

C 结 点 进酚, 置人一1
建立 下结点,因& 一 1, 将 其 作为 C 结 点 的 左 孩子

,

下

)

)

ch 扫描 完毕

置 人一2

建立 下结点,因& 一 2, 将 其 作为 C 结 点 的 右 孩子

退 栈 一 次

退 栈 一 次

算法 结束

208

空

和A

A

AB

AB

ABD

ABD

ABD

AB

A

和A

A
AC
AC

AC

AC

A

空

GOODTEEI

设 /0) 的 功能 是 释放 为 二 又 树纺中 的所有 结 点分配 的 空间。其递归模型如下 :

7(p) 不 做 任何事情
CO)

CGO-> lchild); 7 一 > rchild); 释放所指结点;

若 6王NULL
其 他 情况

对 应 的递归 算法如下 :

void DestroyBTreeCBTNode * &b)

{

ii(bI=NULL)

{

,DestroyBTree(b 一 > lchild) ;

DestroyBTree(b -> rchild) ;

free(b) ;

】}

设 /Co,z) 的 功能 是在二 又 树 2 中查找值为z 的 结点,找到 后 返回其地 址 ,和否则 返回

NULL。 其递归模型如下 ;

Ko,z) = NULL
CDZ) 一 已
Kb,z) 一 户
Jp,z) 一 KB -> rchild,z) 其他情况

若 2==NULL
车0 一 > data 一 一工

若 在 左 子树中 找到 了 , 即 2 一 jlchild,z)且 NULL

对 应 的递归 算法如下 :

BTNode * FindNode(BTNode * b,ElemType x)

{

BTNode * p;

这 (b= 王 NULL)

return NULL;

else i (b 一 data 一一x)

return b;

else

{

, p=一FindNode(Cb -> lchild,x);

让 (Cp!=NULL)

Teturn p;

else

return FindNode(b 一> rchild,x) ;

)》

和 和找芒 于 用 二 让FT

直接 返回 结 点 如 的 左 孩 子 或 右 孩子 地 址。算法如下 :

BTNode * LechildNode(BTNode * p) //返回结点 p 的 左 孩 子指针

{

209

数据 结构教程

[第! 5人版

return p 一 > lchild;

}

BTNode * RchildNodeCBTNode * p)

// 返 回结点 p 的 右 孩子指针

{

}

return p 一> rchild;

求二又树0 的高度 的递归 模型(0)如下 :

CD) 一 0
CGO)

一 MAX{JFC -> lchild) ,7CO 一 > rchild)}十1 其他情况

若 0王NULL

对 应 的递归 算法 如 下 :

int BTHeight(BTNode * b)

int lchildh,rchildh;
i (b=王NULL) return(0);

else

// 空 树 的 高 度为0

{

lchildh=BTHeightCb -> lchild);

// 求左子 树 的高度 为 lchildh

rchildh=

王BTHeight(b 一> rchild) ;

// 求右子 树 的高度为rchildh

return (lchildh> rchildh)? (lchildh十1) :Crchildh十1);

{

)》

人

其 过 程 是对 于 非 空二又 树 0, 先输出结点2 的 结点值,当 它 存在 左 孩 子 或 右 孩子时 输出

一 个“(? 符 号 ,然后递归 处 理 左 子树; 当 存在 右 孩 子时 ,输出 一 个 ,符号 ,再递归 处 理 右 子

树 ,最后 输出 一 个")” 符 号。对 应 的递归 算法如 下 :

void DispBTree(BTNode * b)

{

ii(bI=NULL)

{

printf("%c",b 一 data);

这 (b 一 lchildl=NULL | b 一 rchildI=NULL)

{

printf("(");

// 有 孩子结 点 时 才 输 出"("

DispBTree(b 一 lchild) ;

// 递 归 处 理 左 子 树

这 (b 一 rchild!王NULL) printf(","); // 有 右 孩 子 结点时 才 输 出","

DispBTree(b -> rchild) ;
printfC")");

// 递 归 处 理 右 子 树
// 有 和孩子 结点时 才 输 出")"

PE

}

例如 ,调用前面的函数CreateBTree(0,"A(B(D(,G)),CCE,F))")

构造一棵二又树0,

再 调用 DispBTree(0) ,其执行结果如下 :

A(CBCD(C,C)) ,CCGE,EF))

210

7As放权和=X村 |

二 又树 的 遍历

米

751 二 叉 树遍历的概念

二 叉 树 的 遍历 是 指 按照 一定的 次 序 访 问 二 又树中 的所有 结点,并 且 每 个 结点仅 被访问

一次的过程。它 是 二 又 树 最 基本 的 运算 ,是二 又 树中所 有 其他 运算 实现 的 基础 。

一 棵 二 又 树 由 3 个 部 分 (即根 结 点 \左 子树和 右 子 树 )构成,可 以 从 任何 部 分开始 遍历 ,

所以有 3!(即 6) 种 遍历 方法。若 规定 子树的 遍历 总 是先左后右 ( 先 右 后 左 与 之对称), 则 对

于 非 空二又 树 ,可得 到 以 下 3 种递归 的 遍历 方法 ,即 先 序 遍历.中 序 遍历和 后 序 遍 历 。另外
还 有 一 种 常见的层次 遍历 方法 。

要-要

全 先 序 调 历

先 序 遍历(preorder traversal) 二叉树的过 程如下 :

(1) 访问根结点;

(2) 先 序 遍历 左子树 ;

(3) 先 序 遍历 右子树 。

例如 ,图7.13(a)所 示 的 二 又 树 的先序 序列为 ABDGCEF。 显然, 在 一棵二 又 树的先 序

序列 中 ,第 一 个 元 素 即 为根结 点 对 应 的 结 点 值 。

2 和 放 遍历

二又树的过程如下:
中 序 遍 历 (inorder traversal)

(1) 中 序 遍 历 左子树 ;

(2) 访问根结点;

(3) 中 序 遍 历 右子树 。

例如 ,图7.13(a)所 示 的 二 又 树 的 中 序 序列为 DGBAECF。 显然,在 一棵二 又 树的中 序

序列中 , 根 结点值将其 序列 分 为 前、后 两个部 分 ,前 部 分 为 左 子 树的中 序 序列,后 部 分 为右子

树的中 序 序列。

3 后序调历

二又树的过程如下 :
后序遍 历(postorder traversal)

(1) 后 序 遍 历 左子树 ;

《2) 后 序 遍 历 右子树 ;

(3) 访问根结点。

例如 ,图7.13(a)所 示 的 二 又 树 的后序 序列为 GDBEFCA。 显然,在 一棵二 又 树的后 序

序列 中 ,最后一 个 元 素即 为 根 结点对 应 的 结 点 值 。

天 层关 局 售

层次 遍历 (level traversal)

不同于前面 3 种遍历 方法, 它 是非递归的,用 于 一 层 一层地访

数据 结构教程

[第1 5 【版

问 二 又 树 中 的所有 结 点。其 过 程如 下 :

若 二 又 树非 空 (假设 其 高 度 为凡) , 则 :

(1) 访问根结点(第 1 层);

(2) 从 左 到 右访问第 2 层 的 所 有 结 点 ;

(3) 从 左 到 右 访 问 第 3 层 的所有结 点 、...... 、\ 第疡层 的所有 结 点 。

例如 ,图 7.13(a)

所 示 的 二 又 树 的层次 遍历序列为ABCDEFG。显然,在 一 棵 二 又 树 的

层次 遍历 序列 中 ,第一个元 素 即 为 根结点对 应 的结 点 值 。

要-要

752 先 序 .中序和 后 序 遍 历递归 算 法

由 二 又 树 的 先 序.中 序和 后序 3 种 遍历 过程直接得 到以下 3 种递归

void PreOrder(BTNode * b)

// 先 序 遍 历递归 算法

{

站 CbI=NULL)
{

printf("%c ",b一> data);

PreOrder(b -> lchild);

PreOrder(b 一 rchild) ;

}

}
void InOrderCBTNode * b)

{

站 (bl=NULL)
{

InOrder(b -> lchild) ;

printf("%c ",b 一 > data);

InOrder(b -> rchild) ;

}

}
void PostOrderCBTNode * b)

站 (bl=NULL)
{

,PostOrder(b -> lchild);
PostOrder(b -> rchild) ;

printf("%c ",b 一 > data);

}

{

}

// 访 问 根 结点

// 先 序 遍 历 左 子 树

// 先 序 遍 历 右 子 树

// 中 序 遍 历递归 算法

// 中 序遍 历 左 子 树

/访问根结点

// 中 序 遍 历 右 子 树

//后序遍 历递归 算法

//后 序 遍 历 左 子 树
// 后 序 遍 历 右 子 树

/访问根结点

上 述 算法 中 访问 根 结 点 采用 的 是 直接 输出 根结 点 值 ,在实际 中访问 根 结 点可 以 对 其 进

行 各 种 操作 ,如 结 点计数 、删除结 点 等 。

递归 算法 在 执行 中 需要 多 次 调用 自身。例如,对于图 7. 13(b) 所 示 的 二 又链 , 先 序 遍 历 算

ee

法 PreOrder(A)
类 同。图 中 的 实 箭头 表示 调用 步(对 应递归 的 分 解), 虚 箭头 表示 返回 步(对 应递归 的 求 值)。

为 了 简便 ,其 中 参数 A 表示 结 点 A 的 地 址 ,其余

的执行过程如图 7.15 所 示 。

从 上 面可以 看 出 ,3 种递归 算法 虽然 简单 ,但 执行 过 程 是 十 分复杂的。一 般情况下 ,递

归 调用 从 哪里开始 ,执行 最 后 一定要 返回 到 这 个 调用 的 地 方 。

要-_扫

【 例 7.11】 假设 二 又 树 采 用 二 又 链 存储 结构 存储 ,设计 一 个 算法 , 计

算 一 棵 给 定 二 又 树 的所有 结 点 个 数 。

二 又 链 的 基本结构 如 图 7. 16 所示 。 设 /2)求二又树训 中 的所有

结 点 个 数是“大问题 ”, 则 /2 一 > lchild)和 (2一> rchild)

分别求左右子 树

212

[第 /7 【章】 树和二又树

PreOrderA) -一访问 A ,
一 -人

站 1 -|
PreOrder(B) 一-一访问 B,

,

,

| 二

|

PreOrder(D)-一=访间D 本 三

| Po |
1

,

\

PreOrder(NULL)

1
1

|

忆 PreOrderNULDH

|

1
,Preorder(G)一一访|

ES

AN

的执行过程
7.15 PreOrder(A)

中 的所有 结 点 个数 ,是 两 个 “小 问题 ”它们与大 问题 的 求解过 程 是 相似 的 。递 归模型AC2)

Kb) 一 0
2) 一 78 -> lchild) 十7Kb -> rchild)十1

若b王NULL

其 他 情况

刀 D): 大问题

JUD->lchild): 小 问题 Xp->rchild) : 小 问题

图 7.16 二 叉 链 的基本结构

对应的递归 算法如下 :

int Nodes(BTNode * b)

{

, iCb==NULL)

Teturn 0;

else

213

数据 结构教程

[第! 5 【版

return Nodes(b 一 lchild) 十 Nodes(b 一 rchild) 十 1;

}

其 中 最 后 语句 的 执行过程是先 扫描 左 子 树,再 扫描 右 子树,最 后 是 根结 点(计 1),所以本算

法 采用 的 是 后 序 遍 历 思路。由 于 “十 1 可以 放 在 返回 表达 式 的 任何 位 置,对 应 不 同的遍历思

路。也 就 是 说 ,本例 算法 可以 基于 3 种 遍历 递归 算法 中 的任何 一种。

说明: 从例7.11 可以 看 出,直接 采用 递归 算法设计 方法和 基于 某种遍历 递归 方法 会 得

到 相同 的 结果 ,实际上 前 者 是 后 者 的 基础 ,所以 掌握基本 的 二 又 树 的递归 算法设计 方法 对 于

二 又 树问 题 的 求解 是十分 重要 的 。

【例7.12】〗 假设二又 树 采 用 二 又 链 存储结构 存储 , 试 设计 一 个 算法 ,输出 一 棵 给 定 二

又 树 的所有 叶子结 点 。

输出 一 棵 二 又 树 的所有 叶子结 点 的 递归 模型 ACO)如下。

Jp) 不 做 任何事件 若6王NULL
Jo) 输出已所 指 结 点 的 data 域
Kb) CD -> lchild); Fo -> rchild) 其他情况

若 所 指 结 点为叶子 结点

对 应 的 递归 算法如下 ,

void DispLeaf(BTNode * b)

这 (bl=NULL)
{

一=NULL)
if(b 一 lchild==NULL && b 一 rchild

printf("%c ",b一>data);

DispLeaf(b -> lchild) ;

DispLeaf(b -> rchild);

// 访 问 叶 子 结 点
//输出 左 子树中 的叶子结点

// 输 出 右 子树中 的 叶子 结点

{

)}

上 述 算法 实际上 是 采用 先序 遍 历递归 算法 输出所有 叶子结 点 的,所以 叶子结 点 是以 从

左 到 右 的 次 序 输出 的 , 若 要 改 成 以 从 右 到 左 的 次 序 输出所有 叶子结 点,显然只 需要 将 先 序 遍

历 方式 的 左 ` 右 子 树 访问 次 序 倒 过 来即可。对 应 的 算法如下 :

void DispLeafl(BTNode * b)

这 (Cbl=NULL)
{

这 (b->1lchild

一=NULL && b-> rchild一NULL)

printf("%c ",b一> data);

// 访 问 叶 子 结 点

DispLeaflCb -> rchild) ;

DispLeafl(b-> lchild);

//和 输出 右 子树中 的叶子结点

// 输 出 左 子树中 的 叶子 结 点

{

)}

一 棵 二 又 树 由 根结 点 ` 左和 右 子树 3 个部 分构成,又 可 以 分 为 根结点和 子 树两类 ,在 设

计 二 又 树 算法时 根结 点 是可以 直接 处理的 , 子 树 处 理 不是直接 的 ,需要 递归 处 理 。

如 果 必 须 先处理 根结 点 ,再 处 理子树 ,就是基于 先 序 遍 历的思路 。例如,例 7. 12 的 算法

是 要 输出 叶子结 点 ,所以 先 判断当前结 点 是 否为叶子结 点。尽 管也可 以 在 左 、 右 子 树 处理之

214

7As放本和=村 |

后 再 来判断 是 否为叶子 结 点 ,但 后 者 不如 前 者清晰 。

如 果 必 须 先处理子树, 再处理 根结 点 ,就是基于 后序 遍 历的思路。例如,在 7.4.2 小 节

中 ,销毁二又树的DestroyBTree(&2)

算法就是基于后序遍历 的 ,如 果 先 释放 根结点 ,那么

就找 不 到 它 的 左 、 右 子树了 。

有 些问 题在求解时 既 可以 先处理 根结 点 ,又 可 以 先处理子树 ,也 就是说 与根结点和 子 树

的 处 理 次 序 无关, 这 样可以 采用 基于 先 序 遍 历 或 者 后 序 遍历 思路 来 求解 。例如,例7. 12 的

算法便是如此。

如 果子 树 的处理 需要 区 分 左右 子 树 ,就需要 考虑 中序 遍 历的思路 ,这 种情况比较少, 所

以 二 叉 树 算 法 大 部 分 都是基于 先 序 遍历 或 者 后 序 遍 历 思路 来 求解 的 。

【例7.13】 假设 二 又 树 采 用 二 又 链 存储 结构 ,设计 一 个 算法 求 二又树 2 中结 点 值为工

的结 点 的层次 (或者深度 ) ,并 利用 二 又 树的基本 运算 算法 编写 一 个完整 的 程序

,建立

图 7.13(a)

层次。

所示 的 二 叉 树 的 二 叉 链 ,对 于 用 户输入 的任何结 点值计 算出 在 该二又 树 中 的

设计 算法为Level(O,z,j)

,其返回值为在二又树 2 中查找结点值为z 的结 点 所 在

的 层次 ,返回 0 表示未找到。如果 0 为 空树,返回 0; 如 果 当 前 根结 点 的结 点 值 为zx, 则 返回

As; 否则 在 左 子树中 查找 (层次 六 需要增 1) , 若 在 左 子树中 未找到 ,再 在 右 子 树 中 查找 (层次

九 需 要 增 1)。

实现 本 例 功能 的 完整 程序如 下 :

# 井include "btree.cpp"

int Level(BTNode * b,ElemType x,int h)

//R 置 初值1

{

intl;

计 (b=王NULL)

Teturn(0) ;

else 计 (b 一 > data 一一x)

return(h) ;

else

{

1=Level(b一 lchild,x,h十1);

// 在 左 子树中 查找

让 (1一0)

Teturn(]) ;

else

return(Level(b 一> rchild,x,h十1));

// 在 左 子树中 找到 了 ,返回 1

// 在 左 子树中 未 找到 ,再 在 右 子树中 查找

}

}

int main()

{

BTNode * b;

int h;

ElemType x;

CreateBTree(b, "A(B(D(,G)),CCE,F))");
printf("b:");DispBTree(b) ;printfC"\n");
printf(" 结 点 值 :");
scanf(" ic 中 xz);

h一Level(b,x,1);

计 (h 一 一0)

数据 结构教程

[第! 5人版

printf("b 中 不存在%c结点\n",x);

else

printf("在b 中 %c 结 点 的 层次为%d\n",x,bh);

DestroyBTree(b) ;

// 销 毁 二 叉 树

return 1;

】}

Level(0,z,j)算法采用的 是 基于 先 序 遍 历 的 思路 。以 上 程序 执行 一 次 的结果如 下

b: A(B(D(,G)),C(E,F))
结点值:三巡
在 b 中 王 结 点 的层次为3

本 例 涉 及 递归 算法 形 参 赋 初 值 的 问题 。在 Level 算法中, 形 参 用 于 在 二 又 链 中 遍历结

点 ,该 算法 中 又 需要 知道 它 的层次 ,在 这 种情况 下 就需要 增加 一 个 形 参 /, 它 表示 2 所 指 的

结点层次。在 调用 本 算法 时 总 是从根结 点开始 查找 的 ,而 根结 点 的层次为 1, 所以 大 的初值

为 1, 即调用 方式是Level(,z,1l)。

【例7.14】 假设 二 又 树 采 用 二 又链 存储 结构 ,设计 一 个 算法求二 又树 2 中第& 层 的 结

设计 算法 为 Lnodenum(p ,je&z) 败 表示 尺 所 指 的 结 点 层次 ,是引用型参数,用

于 求第& 层 的结 点 个 数。在 初始调用时 ,2 为 根结 点 指针 ,为 1,2 赋值 为 0,即 调用 方式是

7 一 0; Lnodenum(D ,1,R,7)。

采用 基于 先序 遍历 的 思路得 到以 下 算法 :

void Lnodenum(BTNode * b,int h,int k,int &n)

{

这 (b==NULL)

// 空树直接返回

Teturn;

else

// 处 理非空树

{

让 (h 一一k) n十十;

// 当 前 访问 的 结 点 在第上 层时n 增 1

else 过 Ch<k)

// 若 当前 结 点 层次小于 k, 递 归 处 理 左 、 右 子 树

,Lnodenum(b -> lchild,h十1,k,n);

Lnodenum(b 一> rchild,h 十 1,k,n);

{

】}

】}

在 上 述 算法 中 ,引用型形 参 用 于记录二又树4 中第& 层 的结 点 个 数 ,也 可以 用 全 局 变

量 来 代 蔡 ,功能 等价的 算法如下 :

int n一0;

// 全 局 变量

void Lnodenuml(BTNode * b,int h,int k)

{

让 (b==NULL)

// 空树直接返回

Teturn;

else

// 处 理非空树

{

这 (h 一一k) n十十;

// 当 前 访问 的 结 点 在第上 层时n 增 1

else 过 (h<k)

// 若 当前 结 点层次 小 于 k, 递归 处 理左右子树

216

7As放本和X村

|

,Lnodenuml(b 一> lchild,h 十1,k);

Lnodenuml(b -> rchild,h十 1,k);

{

】}

)》

在 算法 执行完毕 后 , 求得的 7 为 二叉树0 中第& 层 的结点 个 数 。从中可以 看 出 ,函数中

的 引用型形参 可以 通过 全 局 变量 来 实现。一 般情况下,只 有 在 函数 的 形 参个数 比较 多 并 且

数据 类 型复杂 时 为了简化 算法 才 采 用 这 种 方法 。

【例7.15]】 假设 二 又 树 采 用 二 又 链 存储结构 ,设计 一 个 算法 判断 两 棵

二 叉 树 是否相 似。所 谓 二 又 树 01 和 52 相似指的 是 忆 和 22 都 是 空的二 又

树; 或者和 1 和 22 的 根结 点 是 相似的,以及21 的 左 子树和 22 的 左 子 树是相

似的,并 且 21 的 右 子 树 与 22 的 右 子 树是相似 的 。

判断两棵二又树01 和 02 是 否 相 似 的递归 模型(01,22)如 下 。

Kb1,02)一true

Kb1.02) 一 false

若 刀 =2=NULL

若 刀 .02 之 一为NULL,另一个不 为NULL

Kb1,02)一751 -> lchild,22 -> lchild) 区了& 其他情况

Kb1 -> rchild,52 一> rchild)

对 应 的算法如下 :

bool Like(BTNode * bl ,BTNode * b2)

//bl 和 b2 两 棵 二 叉树相似 时 返回 true, 否则 返回 false

{

bool likel ,like2;

if (bl一=NULL && b2 一一NULL)

Teturn true;

elsei (bl一=NULL | b2=一一NULIL)

Teturn false;

else

{

likel 王 Like(bl 一 lchild,b2 一 lchild) ;

like2一Like(bl 一> rchild,b2 一> rchild) ;

return (likel && like2);

// 返 回 likel 和 like2 的 与 运算 结果

)}

【例7.16]】 假设二 又 树 采用 二 又链 存储结构 ,设计 一 个 算法 输出 值为 z 的结 点 的所有

祖先。

aa

根据 二 又 树 中 祖先 的 定义 可 知 , 若结 点 户 的 左 孩 子 或 右 孩 子 是结 点 q, 则结 点 户

是结 点 g 的 祖先 ; 若结 点 户 的 左 孩 子 或 右 孩 子是 g 结 点 的 祖先 , 则结 点 户 也 是结 点 g 的

祖先。

设 /2,z)表示结点0 是 否 为 值是z 的结 点 的 祖先 , 若结 点 2 是 值为zx 的结 点 的祖先 ,

CO,z)返回 true; 否则 F(,z)返回 false。 当 jpO,z)为true 时 ,输出结 点 的值 。求 值为

并 的结 点 的所有 祖先 的递归 模型/CO,z)如下:

217

数据 结构教程

[第! 5版

Kb,Z) 一 false

若 0=NULL

Jo,z) 一 true,并输出 如 一 data
Jpb,z) 一 true,并输出 如 -> data

若 结 点 8 的 左 孩 子 或 右 孩 子的 data 域为
车 KK 一 lchild,x)为true 或 Kb -> rchild,z)为 true

DZz) 一 false

其他情况

对应的算法如下 :

bool ancestor(BTNode * b,ElemType x)

{

让 (b==NULL)

Teturn false;

else 过 (b -> lchild!

王 NULL 人&& b 一> lchild -> data 一一x

| b-> rchild!

王 NULL & 本 b 一 rchild 一 > data 一一x)

人

printf("%c",b一> data);

Teturn true;

}
else if (ancestor(b -> lchild, x) | ancestor(Cb -> rchild,x))

{人 printf("%c",b一> data);

ITeturn true;

}

else return false;

753 先 序 .中序和 后 序 遍 历 非递归 算法 *

二 又 树 是 一 种递归 数据 结构 ,其 先 序.中序和 后 序 遍 历 算法 采用 递归 方式 设计 是理所 当

然的,但 大 家 掌握对 应 的非递归 算法 可以 进一步 加 深 对 这 3 种 遍历 算法 的 理解 ,提高应用 它

们 的 能 力 。

全 先 施 融 历 非 逆归 租 法

先 序 遍历非递归 算法 主要有 两 种 设计 方法 。

1) 先 序 遍历非递归 算法 1

由 先 序 遍 历 过 程 可 知 , 先访问 根结 点 ,再 遍历 左子树 ,最后遍历 右 子 树 。由 于 在 二 又 链

中 左 、 右 子 树是通过 根结 点 的 指针 域 指向 的 ,在 访问 根 结 点后遍历 左子树 时 会丢失 右 子 树 的

地 址 ,需要 使用一 个 栈 来 临时 保存 左右子树的地 址 。

由 于 栈 的 特点 是 先进后 出 ,而 先 序 遍历 是 先 遍 历 左 子树, 再 遍历 右 子 树,所以 当 访 问 完

个非叶子 结 点 后 应 先 将 其 右 孩 子 进栈, 再 将 其 左 孩子 进 栈。对 应 的非递归 过 程如 下 :

Le

将 根 结 点 进杰;
while 〈 栈 不 空)

出 栈 结 点 p 并访问之;
若 p 结 点有右 孩子, 将 其 右 孩子进 栈 ;
若 p 结 点有左 孩子, 将其左 孩子进 栈 ;

{

)》

该算法 中 的 栈 采 用 顺序 栈 存储 结构 ,其 类 型 声明 如 下 :

218

7As放权和=村 |

typedef struct

{

BTNode * data[MaxSize] ;

int top;

) SqStack;

// 存 放 栈 中 的 数据 元 素
// 存 放 栈顶指针

// 顺 序栈类 型

相关 的 栈 运算 算法 设计 见 3. 1. 2 小 节 ,本小 节 的所有 非递归 算法 都 使用这 样的顺序 栈 。

先 序 遍历非递归 算法 1 如下:

void PreOrderl(BTNode * b)

// 先 序非递归 遍历 算法 1

BTNode * p;
SqStack * sti;
InitStack(Cst);

if (b!=NULL)
{

PushCst,b);

// 定 义 栈指针 st
//初始化栈 st

// 根 结 点 进 栈

while (!StackEmpty(Cst))

// 栈 不 为空时 循环

{

Pop(Cst,p);

//退栈结点 p 并访问它

printf("%c ",p 一> data) ;

让 (p -> rchild!=NULL)

// 有 右 孩子时 将其进 栈

Push(Cst,p 一 > rchild) ;

ii(p 一 1lchild!=NULL)

// 有 左 孩子时 将 其进栈

Push(st,p -> lchild) ;

】}
printf("\n");

)}
DestroyStack(st) ;

// 销 毁 栈

{

)}

对 于 图 7. 13(b)所示的二又树 2, 上述 算 法 的 执行 过 程如表 7. 2 所 示 , 最后的 输出 序列

为 ABDGCEF。 表 中 *A”?表示 A 结点的 地 址,下同。

表 7.2, 先序遍历非递归 算法 1 的执行过程

操

作

栈(栈底 空栈顶 )

访问的结点

根 结 点 A 进 栈

根 结 点 A 出 栈 , 访 问 A

将 A 结 点 的 右 孩子 C 进栈

将 A 结 点 的 左 孩子了B进栈

结点B 出栈, 访 问 也

结点也 的 左 孩子进栈

结点D出栈,访问D
结 点 D 的 右 孩 子进栈

结点 G出栈,访问 G

结点C 出 栈 ,访问C

结点 C 的右孩子F 进栈

结点 C 的左孩子下 进 栈

结点下出栈,访问 下

结点下出栈,访问耻

栈空,算法结束

A

空

C

CB

C

CD

C
CG

C

空

下

FE

下

空

219

人A

B

D

G

C

下

下

ES

数据 结构教程

[第! 5 【版

2) 先 序 遍历非递归 算 法 2

先 序 遍 历 顺 序 是 根结 点 . 左 子树和 右 子 树,所以 先 访问 根结 点 及 其所有 左下结 点 ,由

于 在 二 又 链 中 无法由 孩子找到 其 双亲 ,所以需要 将 这 些 访问 过 的结 点 进栈保 存 起 来 。此时

当前 栈 顶结 点 要 么 没有 左 子树( 实际 上 是 没有 左 孩 子) ,要 么 左子树 已 遍历 过 ,所 以 转向 它 的

右 子树, 对 右 子 树 的 处 理 与 上 述 过 程 类 似。对 应 的非递归 过 程如 下 :

p 王 b;

while 〈 栈 不 空 或者p!=NULL)

while (结点 p 有 左 孩子)
{ 访问 结 点 p; 将 其进栈 ;

pb一p 一 lchild

)》

// 对 于结点 p 及 其所有 的 左下 结 点 , 边访问边进 栈

// 此 时 栈 顶 结 点 (已访问 ) 没有左 孩子, 或 者 左子树 已遍历 过

迁 〈 栈 不 空)

{ 出栈p;

p一p 一> rchild;

}

{

)》

首先让之 指向 根结 点 ,然后开始 外 循环 ,每一轮 循环分 为 两个阶段,第 一 个 阶段是沿 着

结点户 的 左下 方向 查找 , 边访问 边 进 栈 ,直到 最左下结 点 ( 它 没有 左 孩 子);, 第 二 个阶段出栈

一 个结 点 六 ,通过让 疡 指向 它 的 右 孩子再重复 循环 来 遍历 右 子 树 。

每 一 轮 外 循环结束时 ,所 有 栈 中 的结 点 均 已 访问 且 它 的 左 子 树 已 遍历 (或者左 子 树 为

空) ,等 待 遍历 右 子树; 而 馆 指 向 刚刚 出 栈结 点 的 右 子 树。显然, 当 栈 空而且 如 =NULL 时

例如 ,对 于 图 7. 13(b) 所 示 的 二 又 树 ,其 先 序 遍 历非递归 算法 2 的执行过程如表 7. 3 所

示 , 也 可以 用 图 7. 17 来描述,其 中 箭头 表示 处 理结 点 的 过 程 , 整个过 程 是从 A 结 点 开始的。

结 点 劳的数字 表示 访问 该结 点 的 次 序,“ 十”表示 该结 点 进 栈,“ 一”表示 该结 点 出 栈,下 同 。

表 7.3 先序遍历非递归 算法 2 的执行过程

执行 的 操作

访问 结 点

修改 后 的请值

st( 栈 底 客栈项)

A.B.D 结 点 依次进栈 并 访问 之,如 = 一刀一> lchild

ABD

pb=NULL

PE

出栈 D 结 点 ,妃指 向 它 , 一 轧一> rchild

G 结 点 进 栈 并 访问 之 , 妈 一 户一> lchild

出栈 G 结点,尹指 向 它 , 一 思 一 > rchild

出栈也 结 点 ,尹指 向 它 ,刀一 加一> rchild
出栈 A 结 点 , 力 指 向 它 , 一 户一> rchild
CE 结 点 依次 进 栈 并 访问 之 ,刀一 祖一> lchild

出栈下 结 点 ,力指 向它,思一 记一> rchild

出栈 C 结 点 ,声指 向 它 , 一 一 > rchild
F 结 点 进栈并 访问 之 ,如 一如一 > lchild

出栈下 结 点 ,尹指 向 它 ,刀一 户一> rchild

栈 空量 p王NULL,退出循环,算法结束

力 指 向 G 结 点

=NULL

一 NULL

b=NULL
旋 指 向 C 结点
==NULL

2=NULL

旋 指向下 结 点
zb=NULL

六一NULL

G

CE

下

220

ABD

AB

ABG

AB

人A

CE

C

下

树和二又树

图 7.17 先 序 遍 历非递归 算法 2 的执行过程

对应的 先 序 遍历非递归 算法 2 如下 :

void PreOrder2(BTNode * b)

// 先 序 遍 历非递归 算法 2

BTNode * p;
SqStack * st;
JInitStack(st);

p一b;
while (!StackEmptyCsb ‖ p!=NULL)

// 定 义 一 个 顺序 栈 指针 st
//初始化栈 st

{

while (p!I=NULL)

//访问结点 p 及 其所有 左下 结 点 并 进 栈

{

printf("%%c ",p一> data);
了Push(st,p);
p=p 一 lchild;

// 访 问 结 点 p
// 结 点 p 进栈

// 移 动 到 左 孩子

}
计 (C!StackEmptyCst))

PopCst,p);

p=D 一 rchild;

{

}

}
printfC"N\n") ;
DestroyStack(st) ;

//若栈不空

//出栈结点 p

// 转 向 处 理 其 右子树

//销毁栈

{

)}

中 序 遍 历非递归 算法 是 在 前面先序遍历非 递归算 法 2 的基础上修改的,

中 序 这 历 顺序 是左子 桂 、 根 结 点 \ 右 子 树。所以 需要将根结 点 及 其左下结 点 依

次 进 本 ,但 还不能 访问 ,因为 它们 的 左 子 树 没有 遍历 。当 达到 根结 点 的 最左下

结 点时 , 它是中序序 列 的 开始 结 点 ,也 是 本 顶结 点 ,出 本 并 访问 它 , 然 后转向 它

的右子 树 ,对 右 子 禁 的处理 与上述 过 程 类 似。对 应 的非递归 过 程如 下 :

p一b;
while ( 栈 不 空 或者p!=NULL)
{

while (结点 p 有 左 孩子)
{ 将 p 进栈;

p=王p一> lchild;

}

// 此 时 栈 顶 结点(尚未 访问 ) 没有左 孩 子 或 左 子 树已壳 历 过

迁 ( 栈 不 空)

到

数据 结构教程

[第! 5版

{ 出栈p 并访问之;

p 王 p 一> rchild;

}

}

当 每 一 轮 外 循环 结束时 ,所 有 栈 中 结 点 均 未 访问 但 它的左子树 已 遍历 (或 者 左子树 为

空) ,等 待访问 并 遍历右子 树 ; 而 户 指向 刚刚访问 结 点 (出栈结点) 的右子 树 。当 栈 空而且

2=NULL 时 ,表示 所 有 结 点 都 访问了 ,算法 结束 。

例如 ,对 于 图 7. 13(b) 所 示 的 二 又 树 , 其 中 序 遍 历非递归 算法 的 执行 过 程如 表 7.4 所

示 , 也 可以用 图 7. 18 来 描述 。

表 7.4 中 序 遍 历非递归 算法的执行过 程

执行 的操作

访问 结点

修改 后的刀 值

st( 栈 底 之 栈 顶 )

A、B,.D 结 点 进栈,z 一训一> lchild

出栈 D 结 点 并 访问 它 , 如 一训一> rchild

G 结 点 进栈, 一思一> lchild

出栈 G 结 点 并 访问 它 , 一如一 > rchild
出栈 B 结 点 并 访问它, 加 一 如一> rchild
出 栈 A 结 点 并 访问 它 , 如 一 如 一 > rchild

C、上结 点 进栈, 一 户 一> lchild

出栈下 结 点 并 访问 它 , 一 如 一> rchild

出栈 C 结 点 并 访问 它 ,一 一> rchild

FE 结 点 进 栈 , 一训一 > lchild

出栈 下 结 点 并 访问它, 加 一 祖 一> rchild

栈 空且 p王NULL, 退 出外循环 ,算法 结束

D

G
B

和A

下

C

下

zp=王NULL

户 指 向 G 结点

zp=王NULL

zp=王NULL
pb=NULL

妃 指 向 C 结点

pzp=王NULL

六 =NULL

尹 指 向 下 结点

pzp=王NULL

zb=NULL

ABD

AB

ABG

AB
和A

CE

C

下

图 7.18 中 序 遍历非递归 算法 的 执行 过 程

对 应 的 中 序 遍 历 非递归 算法如 下 :

void InOrderl(BTNode * b)

// 中 序 遍 历非递归 算法

{

BTNode * p;

SqStack * sti

InitStack(st) ;

// 定 义 一个顺序 栈 指针 st

//初始化栈 st

222

7As放权和=X村 |

p王b;
while (1StackEmpty(sb ‖ p!=NULL)
{

while (pI=NULL)

PushCst,p);

bp一pb 一 lchild;

{

}

// 扫 描 结 点 p 的所有 左下 结 点 并 进 栈

// 结点 p 进栈

// 移 动 到 左 孩子

计 (!StackEmptyCst))

// 若 栈 不 空

// 出 栈 结 点 p
Pop(Cst,p);
printf("%c ",p一 data); //访问结点p

pb一pb 一 rchild;

// 转 向处理其右子树

{

】》

}

printfC"\n");
DestroyStack(st) ;

)}

// 销 毁 栈

后 序 遍历非递归 算法 是 在 前面中 序 遍 历非递归 算法 的 基础 上 修改 的,后 序 遍 历 顺序 是

左 子 树 . 右 子 树 、.根结 点 。所以 先 将 根结 点 及 其 左下结 点 依次 进栈,即 使栈顶 结点 思 的 左 子

树 已 遍历 或 为空 , 仍还不 能访问结 点 如 ,因为 它们 的 右 子 树 没 有 遍历 ,只有 当 这 样的 训结点

的 右 子 树已遍历完才能访问结 点 之。后 序 遍 历 的非 递归过 程如 下 :

p 王 b;

do

{

while (结点 p 有 左 孩子)

{ 将 结点p 进栈;

p一bp一 lchild;

}

// 此 时 栈 顶 结 点 (尚未 访问 ) 没有左 孩 子 或 左 子 树 已遍历 过

while ( 栈 不 空且结 点 p 是 栈 顶 结 点 )
{ 了到 栈 顶 结 点 p;

( 结点 p 的 右 子 树 已访问 )

{ 访问 结 点 p;

退栈;

}

else p一p 一> rchild;

// 转 向处理 其右子 树

}

} while ( 栈 不 空) ;

引

3

视频讲解

一 个问题 是如 何 判断当前处理 的结 点

户 是 栈 顶结 点 ,这 个比较 简单 ,设置一个布尔变

量 flag,在 do-while循环中的第一个while 循环结束 后开始 处 理 栈 顶结 点 ,置flag 为 truei

一 且 转 向 处 理 右 子树, 置 flag 为 false。

另一个 问题 是 如 何 判断结 点 户 的 右 子 树 已 遍历 过 ,这 是 算法 的 主要 难点。在一棵二又

树中 ,任何 一棵非 空子 树的后 序 遍历序列 中 最 后 访问 的 一 定 是 该子树的根结 点 ,也就是说,

若结 点 刀 的 右 孩 子刚刚访问 过 ,说 明 它 的 右 子 树 已 遍历 完 , 可 以访问结 点如了。当然,若结

223

数据 结构教程

[第! 5版

点 户 的 右 孩 子 为空 ,也 可 以访问结点 户。为 此 设置 一 个指针 变量 ~, 其 初始值 为NULL,让

它 指向 刚刚 访问 过 的 结 点 。对 于 正在处理 的 栈 顶结点 户 , 一旦 如一> rchild一一成立 ,说明

结点 妃 的 左右 子 树都 遍历过了 ,将 可 以 访问结 点 。

后 序 遍历非递归 算法 如 下 :

void PostOrderl(BTNode * b)

// 后 序 遍 历非递归 算法

{1

BTNode *p,xT;

bool flag;

SqStack * st;

JInitStack(Cst) ;

p王b;

do

人

while (p!I=NULL)

PushCst,p);

p一p 一 lchild;

{

】}

I一NULL;

flag王true;
while (!StackEmpty(st) && flag)

{

GetTop(st,p);

计 (p 一> rchild一一r)
{

printf("%c",p 一> data);

Pop(st,p);

IT 一 p;

】}

else

// 定 义一个 顺序 栈 指针 st
//初始化栈 st

// 扫 描 结 点 p 的所有 左下 结 点 并 进 栈
// 结 点 p 进栈
// 移动到 左 孩子

//r 指 向 刚 访问 的 结 点 ,初始时 为空
//flag 为真表示 正在处理 栈 顶 结 点

// 取 出 当前 的 栈 顶 结点p
// 若 结 点 p 的 右 孩 子 为 空 或者为刚刚 访问过 的 结点
//访问结点p

//r 指 向 刚 访问 过 的 结 点

, p一p 一 rchild;

flag一false;

// 转 向处理 其右子 树
// 表 示 当 前 不 是 处 理 栈 顶 结点

{

】}

】}

} while (1StackEmpty(Cst)) ;
printfC"\n");

DestroyStack(st) ;

// 栈 不 空循环

// 销 毁 栈

}》

当 每 一 轮 外 循环 结束时 ,所 有 栈 中 结 点 均 未 访问 但 它的左子树 已 遍历 (或 者 左子树 为

空) ,等 待 遍历 其 右 子树并 访问 它; 所以 一旦栈 空 ,表示 没有任何 需要访问 的结 点 ,算法结

束。但 在 外 循环之 前 没有任何结 点 进 栈,所以 外 循环采用

do-while 循环 ,即 后 判断 栈 是 否 为 空 。

例如 ,对 于 图 7.13(b)

所示 的 二 又 树 , 其 后序 遍 历 非 递

归 算 法 的 执行 过 程如 表 7.5 所示 , 也 可以 用 图 7. 19 来

描述

以 上 后序 遍 历非递归 算法 有 这 样 的特点 : 当 访 问 某 个

到 栈 底 正好 是 该 结点 的 双亲 结 点 到根

序列 。有 些 复 杂 的 算法 是利用 这 个 特点

解的,例7.17 就

是 采用 了 这 个特点 来 设计 算法 。

图 7.19

后 序 遍 历非递归 算法

的 执行过 程

224

7 人放权和=X村 |

表 7.5 后 序非递归 遍历 算法的执行过 程

执行的操作

访问 结点 st( 栈 底 只 栈 顶 )

A.B.D 结 点依次进栈

取栈顶结点PCD结点),D 结 点 的右子 树未遍历 , 一 户一> rchild, 指向

G 结点

G 结 点 进 栈 ,加= 一 > lchild,p王NULL

取栈顶结点 如 (G 结点) ,其右孩子为空 ,访问它,出 栈

取栈顶结点 CD 结 点 ) ,其 右 孩 子 为刚访问 的 G 结 点 ,访问它,出栈

取 栈 顶 结 点 p(B 结 点),其 右 孩子 为空,访问它,出栈

取 栈 顶 结 点 如 (A 结 点),A 结 点 的 右 子 树未遍历 , 刀 一 一 > rchild, 指向

C 结 点

C、 结 点 依次 进 栈 , 一加一 > lchild,p一NULL

取栈顶结点 如 (了下结 点 ) ,其 右 孩子 为空,访问它,出栈

取 栈 顶 结 点 如 (CC结点),C 结 点 的 右 子 树未遍历,如一 z 一 > rchild, 指向

F 结点

下 结 点 进 栈,如 一 训一> lchild,p一NULL

取栈顶结点PCF 结 点),其 右 孩子为空,访问它,出栈

取栈顶结点 如 CC 结点) ,其 右 孩 子 为 刚 访问的F 结 点 ,访问它,出栈

取栈顶结点ACA 结点) ,其 右 孩子 为刚 访问 的 C 结 点 ,访问它,出栈

栈 空 ,退出 外 循环,算法 结束

G

D

B

下

下

C

三

ABD

ABD

ABDG

ABD

AB

和A

入

ACE

AC

AC

ACF

AC

和A

【例7.17〗 假设 二又树 采 用 二 又链 存储 结构 ,设计 一 个 算法 输出从根结 点 到 每 个叶子

结 点 的 路 径 逆序列 ,要 求 采 用 后序 遍 历非递归 算法 实现 。

利用 后 序 遍历 非递归 算法 的特点 ,将其中 的访问结 点 改 为判断 该 结 点是否为叶子

结 点 ,若是 ,输出栈中 的所有 结 点 值 。对 应 的算法如下 :

void AllPathl1(BTNode * b)

{

BTNode *p,:#Ti

bool flag;

SqStack * sti;
JInitStack(Cst) ;

p一b;

do

{

while (CpI=NULL)

{

PushCst,p);

pb一pb 一 lchild;

】》
r一NULL;

flag一true;

// 定 义 一 个 顺序 栈 指针 st
//初始化栈 st

// 扫 描 结点 p 的所有 左下 结 点 并 进 栈

// 结 点 了p进栈

//p 移动到左孩子

//r 指 向 刚 访问 的 结 点 ,初始时 为空

V//flag 为真表示 正在 处 理 栈 顶 结 点

aa

while (!StackEmpty(Cst) & & flag)

{1

GetTop(st,p);

// 取 出当前的栈顶结点p

让 (p一 rchild一一D)

// 若 结 点 p 的 右 孩子为 空 或 者 为刚访问 过 的 结 点

{

证 (p一lchild==NULL && p一> rchild

王=NULL) 。 // 若为叶子结点

{

// 输 出栈中 的所有 结 点 值

for (int i 一st 一> top;i> 0;i 一 一 )

printf(" %ec 一 >",st 一> data[训-> data);

数据 结构教程

[第! 5版

printf(" %c\n'" ,st -> data[0] 一> data) ;

}

了Pop(st,p);
T 一 Di;

】}

else

//r 指 向 刚 访 问 过 的 结 点

{ , p=p一> rchild;
flag 一 false;

// 转 向处理 其 右子树
// 表 示 当 前 不 是处理 栈 顶 结 点

】}

】}

} while (1StackEmpty(Cst));

// 栈 不 空循环

)》

对 于 图 7.13(b)

所示 的 二 又 树 ,其 输出 结果为GD-~B一A、上一CA 和 F-~C一~A 这

3 条道路径序列。

754 层次 遍历 算法

在 进行层次 遍历时 ,对 某 个结 点 访问 完 之 后,再 按照它的 左右 孩子顺

序 进行 同 样 的 处理,这样 一层一 层 进行 。先 访问结 点 的 左右 孩子也 要 先 访

问 ,这样与 队列 的特征 相 吻 合 。因 此 层次 遍历 算法 采用 一 个环形 队列 qu 来

实现。

算法 中 的 环形 队列 采用顺序 队 存 储结构,其 类 型 声明如 下 :

视频讲解

typedef struct

{

BTNode * data[MaxSize];

// 存 放 队 中 元 素

int front, rear;

) SqQueue;

// 队头和 队 尾 指针

// 顺 序 队 类 型

相关 的 环形 队列 运算 算法 设计 见 3. 2. 2 小 节。

层次 遍历 过 程是先将根结 点 进 队 ,在 队 不 空 时 循环: 从 队列 中出列一个结 点 ,访问它;

若 它 有 左 孩 子结 点 ,将 左 孩子结 点 进 队 ; 若 它 有右 孩 子 结 点 ,将 右 孩 子结 点 进 队。如 此 操作

直到队空为止。对 应 的算法如下 :

void LevelOrder(BTNode * b)

{

BTNode *p;

SqQueue * qui;

JInitQueue(qu) ;

enQueue(qu,b);

// 定 义 环形队列 指针

// 初 始化队列
// 根 结 点 指针 进入队列

while (1QueueEmptyCqu))

// 队 不 为 空循环

{

deQueue(qu,p);
printf("%c ",p 一> data);

//出队 结点 p
// 访 问 结点 p

让 (p 一 lchild!=NULL)

// 有 左 孩子时 将 其进队

enQueue(qu,p -> lchild) ;

这 (p 一 rchild!王NULL)

// 有 右 孩子时 将 其进队

enQueue(qu,p -> rchild) ;

226

7As放 和=X村 |

【例7.18〗 采用 层次 遍历 方法设计 例 7. 17 的 算法 。

采用类似于 3. 2.4 小节

中 使 用 队列 求解迷宫问题 的 方法,这 里 设计的队列 为非 环

形 顺序 队列 ,队列 的 类 型 声明如 下 :

typedef struct snode

{

BTNode * pti;
int parent;

} NodeType;

typedef struct

// 存 放 当 前 结 点 指针
// 存 放 双 亲 结 点 在 队列 中 的 位 置

//非 环形 队列 元 素 类 型

{

NodeType data[MaxSize] ; ”// 存 放 队 列 元 素

int front, rear;

// 队 头 指针 和 队 尾 指针

) QuType;

// 顺 序 队 类 型

从 根 结 点开始 层次 遍历 ,将所有已 访问 过 的结 点进队 ,并 在 队列 中 保存其双亲 结 点 的位

置 。当找到 一 个 叶子 结 点时 ,在 队列 中 通过 双亲 结 点 的位 置 输出 根 结点 到 该叶子结点的路

径的逆序列。对 应 的 算法如下 :

void AllPath2C(BTNode * b)

{

intk;

BTNode * p;

NodeType qelem:;

QuType * qu;
InitQueue(qu) ;

// 定 义非 环形队列 指针
// 初 始化队列

qelem. pt一b; qelem. parent一一1; /创建根结点对应的队列元素
enQueue(Cqu,qelem) ;

// 根 结 点进队

while (1QueueEmpty(Cqu))

// 队 不 空循环

{

deQueue(qu,qelem) ;
p 一 qelem.pt;
证 (p -> lchild==NULL && p一> rchild==NULL)

//出队 元 素 qelem, 它在队 中的下标为qu 一> front
// 取 元 素 qelem 对 应 的 结点 p

// 结点 p 为叶子结点

{ 。 k一qu 一 > front;

// 输 出 结点 p 到 根 结 点的路 径的逆序 列

while (qu 一> data[k] .parent!一一 1)

printf("%c 一 >",qu 一> data[k] .pt 一 > data);

k 一 qu 一> data[k] .parent;

{

}

printf(" %c\n'" ,qu -> data[k] .pt 一> data) ;

}

王NULIL)
让 (p 一> lchildl

// 结点 p 有 左 孩 子

qdqelem.pt=p 一 > lchild;

//创建结点p 的 左 孩子对 应 的 队列 元 素

qelem. parent一qu -> front;

// 结 点 p 的 左 孩 子的双亲 位 置为qu -> front

enQueue(qu, qelem) ;

// 结 点 p 的 左 孩 子进队

{

】》

让 (p 一> rchild!王NULL)

// 结点 P 有 右 孩 子

{

,qelem.pt一p 一> rchild;

//创建结点p 的 右 孩子对 应 的 队列 元 素

qelem. parent一qu -> front;

// 结 点 p 的 右 孩 子的双亲 位 置为qu -> front

enQueue(qu, qelem) ;

// 结 点 p 的 右 孩 子进队

227

数据 结构教程

[第! 5版

对 于 图 7. 13(b) 所 示 的 二 又 树 , 其 输出结果 为 ->C-~A、F-=C一A和 G 一DB一A这

3 条 逆 路 径序 列 。

7.6 二叉树的构造

假设二又树中的 每 个结 点 值 为单个 字符 ,而 且所有 结 点 值均 不相同 (本 节

的 算法 均 基 于 这 种 假设) ,同一 棵 二 又 树具有 唯一先 序 序列 .中 序 序列 和 后 序

序列 ,但 不 同 的 二 叉 树 可 能 具有 相同 的 先 序 序列.中 序 序列 和 后 序 序列 。

例如 ,如 图 7. 20 所示的 5 棵 二 又 树 , 先 序 序列 都 为 ABC。 如图 7. 21 所 示

的 5 棵 二 又 树 ,中序序列 都为ACB。 如图 7. 22 所示的 5 棵 二 又 树 , 后 序序列

都 为 CBA。

CEG

ORG

心

ORG

加

(B)

0 )

加

ORG

CO

9)

四

中

人

四

加

图 7.20 先序序列为ABC 的 5 棵 二 又 树

心

ORG

ORG

ORG

@@

(B)

09

ORG

四

四

四)

四

中

人@

四

人

图 7.21 中 序序列为ACB 的 5 棵 二 又 树

心

一

CD 忆

CEG

四

@

加

(B)

0 )

ORG

Co

加

CO)

四

人

人

四

加

图 7.22

后 序序列为CBA 的 5 棵 二 又 树

显然 , 仅由先序序列`.中序 序列和 后序 序列 中 的任何一个无法确定 这 棵 二 又 树 的 树 形 。

但是,如果同时知道 了 一 棵 二 又 树 的 先 序 序列和 中 序 序列,或者同时知道了中序序列和后序

228

人 7 人齐记 本和二X村

|

序列 ,就 能确定 这 棵 二 又 树 。

例如,先序序列是 ABC ,而 中 序 序列是ACB 的 二 又 树 必 定 是 图 7. 20(c)。

类 似 地 ,中 序 序列是 ACB ,而 后 序 序 列是CBA 的 二 又 树必定是图7. 21(c)。

但 是,同时 知道先序 序列 和 后 序 序列 仍不能 确定 二 又 树 的 树 形 ,例如 图 7. 20 和图 7. 22

中 除 第 一 棵以 外 的 4 棵 二 又 树的先序序列 都是ABC,后序序列都是CBA。

定理 7.1: 任何 z(z伍0)个不同结 点的 二 叉 树 ,都可 由 它的 中 序 序列 和 先 序 序列 唯一地

确定。

证明: 采用 数学 归纳 法 证 明 。

当 7=0 时 ,二 又 树 为 空 ,结论 正确 。

假设结点数小于半 的 任何 二 又 树 都 可 以由其 先 序 序列 和 中 序 序列唯一

地 确定 。

若 某 棵 二 又 树 含有 zz 二 0) 个 不 同 结点,其先序序列是ca ...a, -1; 中

视频讲解

序 序列是DOOAT Di

因为在先 序 遍 有历过程中 访问 根 结 点后紧 跟 着 遍历 左 子 树 ,最 后再遍历 右 子 树,所以 oo

必定 是 二 又 树 的根结点 ,而且 w 必然在中序序列中出现。也 就 是说,在 中 序 序列 中 必 有 某

个 玉 (0 和 过 2 一1)就是根 结点 oo。

由于义 是 根结 点 ,而在中 序遍历过 程中先 遍 历 左子树 ,再 访问 根结 点 ,最 后 再遍历右子

树,所以在中 序 序列 中 总广 ...久-:必 是 根结点 六 (也 就是 ao ) 左 子 树 的 中 序 序列 , 即 六 的左

子树有A 个结点(注意 ,一 0 表示 结点和 没有左子树) ,而 %+i... 思-1:必 是 根结点 和 右 子 树

的 中 序序列 , 即 入 的右子 树有 ?一A一1 个 结点 (注意 ,一7一1 表示 结点 六 没有右子树) 。

另外,在 先 序 序列中 , 紧跟 在 根结点 ao 之 后的& 个结点 序列 wa

...ax 就 是 左子树 的 先

序 序列 ,zx一A一1个结 点 序列 w+i...a-i 就 是右子 树 的 先 序 序列 ,其 示意 图如 图 7. 23

所示 。

根 结 点 一

通过 ao在 中 序 序列 中找到 大

生根 结点

先序序列: ao ”ar eol

中 序 序列: bo0 pb DT

一一一”一一一一
左子树先序 右 子 树 先 序 左子树中序 ”右子树中序
序列 ,有k 。 序列, 有/-1

一一一 一一一

序列 ,有K

序列 ,有7-扩1

不 结 点
抽辟

个 结 点
拓 凡

个 结 点
拓!

个结 点

图 7.23 由 先 序 序列和中 序 序列 确定 一 棵 二 又 树

根据 归纳 假设,由 于 子 先 序 序列 wa ...ax 和 子 中 序 序列 bo5...-: 可 以 唯一地确定 根 结

点 ae 的 左子树 ,而 子 先 序 序列 w+ ...a -和子中序序列w+ -可以 唯一地 确定 根结 点

ao 的 右 子 树 。

综 上 所 述 , 这 棵 二 又 树 的 根 结 点 已 经确定 ,而且 其 左 ` 右 子 树 都 唯一地 确定了 ,所以整个

二 又 树 也 就 唯一地确定了。

实际上 ,先 序 序列的 作用 是 确定 一 棵 二 又 树 的 根结点 (其第一个 元 素即为根 结点), 中序

序列 的 作用 是 确定 左 ` 右 子 树的中 序 序列 (包含 确定 其含的结 点 个 数 ) ,进而可以 确定 左 、 右

子 树 的 先 序 序列。再递归 构造左右子树。

229

数据 结构教程

[第! 5人版

,则构造二又树的过程如
例如 ,已 知 先序 序列为ABDGCEF,中序序列为DGBAECF

图 7.24 所示。

根结 点 : A
左 先 序: BDG 左 中 序: DGB
右 先 序 : CEF 右 中 序: ECF

根结点: B
左 先 序: DG 左 中 序: DG

右 先序:

空

右 中 序 : 空 右先序: F 帮中 序 : 下

: 了 左 中 序

结点: C

根结 点: D
左中序: 空
空
左 先 序 :
右 先 序: G 右 中 序: G

根结点: BE
左 先 序 , 空 左 中 序 :
右 中 序 :
空
右 先序 :

根结点 : F

空 | |左 先 序 , 空 左 中 序 : 空
右 中 序 : 空
空 | |右 先序 :

空

根结点

左先序 , 空 志和 序 , 空
右 先 序 :

图 7.24 由 先 序 序列 和 中 序 序列 构造二又 树 的 过 程

由 上 述定理得 到以 下 构造 二 又 树 的 算法 :

BTNode * CreateBT1(char * pre,char x in,int n)

//pre存放先序 序列 ,in存放中序序列 ,n 为 二 叉 树的结 点 个 数 ,本 算法 执行 后返回 构造的二 叉 链的根
//结点指针 b

{

BTNode * b;

char < pi;

int k;

这 (Cn<一0) return NULL;

b=(BTNode * )malloc(sizeof(BTNode)) ;

/创建二又树结点b

b 一> data一 * prei

for (p王in;p< in 十n;p十十)

// 在 中 序 序列 中 找 等于* pre 字符的位置K

计 (x p 一一#* pre)

break;

上 一 p 一 in;

V/pre 指向 根结点

//在 训 中找到后退出循环

// 确 定 根 结 点在 in 中 的 位 置

b 一> lchild=CreateBT1(pre 十 1,in,k);

//递归 构 造 左子树

b -> rchild王CreateBT1(pre十k 十 1,p 十 1,n 一 k一1);

//递归构造右子树

return b;

)}

定理 7.2: 任何 z(?*二 0) 个 不 同乡

直点的 二 又树 都 可 由 它 的

P 序 序列和 后 序 序列 唯一 地

确定。

证明 : 同样采用 数学 归纳 法 证 明 。

当 ?z=0 时,二又树为空

,结论正确 。

假设结点数小于半 的任何 二 叉 树 都可以由其 中序 序列 和 后 序 序列 唯一

地 确定 。

230

人 7 人齐记本和二又村

|

已知某 棵 二 又 树 含有 z(z盖0) 个 不 同 结 点 ,其 中 序序列是 名 六 ...-iDxps+ri Di 后序

序列是 ca ...as-i。

因为 在 后 序 遍历 过 程中先 遍 历 左 子 树 ,再 遍历 右 子 树 , 最 后访问 根 结 点,所以 w,-: 必 定

是 二 又 树 的 根结 点 ,而 且 w-i 必 然 在中序 序列中出现。也 就 是说,在 中 序 序列 中 必 有 某 个

Ai (0 和 A<2 一1) 就 是 根 结点cv,-i 。

由 于 是 根 结 点 ,而在中 序 遍历过 程中先 遍 历 左子树 ,再 访问 根结 点 ,最 后 再遍历右子

树 ,所以 在 中 序 序列 中 训 ... 包 -: 必 是 根 结 点 生 ( 也 就是wo,-;) 左 子 树的中 序 序列 , 即 入 的左

子树有A 个 结点 (注意 ,一 0 表示 结点 和 没有左子树) ,而 o+i... 思-1:必 是 根结点 和 右 子 树

的 中 序序列 ,即 六 的 右 子树有 ?一4一1 个结点(注意 ,一2一1 表示 结点久 没有右子树) 。

另外,在 后 序序列中 ,在 根 结点w,-1 之前的 x 一&一 1 个 结点 序列 we...a,:就是右子树的

后序序列 ,个结点序列 ao...as-1 就 是左子 树 的后序序列 ,其 示意 图如 图 7. 25 所 示 。

根 结 点

通过aw -1在中序 序列
下我 到 0

后 序 序列: coal

...

”ae ar ... Ga -1 中 序 序列: po2 2 大

一 一一一
左子树后序 右子树后序 左子树中序 右 子 树 中 序
序列 ,有K 。 序列, 有)-扩1
个结 点

序列 ,有丰
个结 点

一一一 一一一

序列 ,有 7-寻1
个结 点

个结点

图 7.25 由 后 序 序列 和 中 序 序列 确定一棵 二 又 树

根据 归纳 假设 ,子中 序 序列 训 ... 和 ~: 和子后序 序列 we...ax-: 可 以 唯一地 确定根结 点 久

可以唯一地确定
(也 就是w-i) 的 左 子 树 ,而子中 序 序列 六 +入-: 和 子后序 序列 we...a,-:

根结 点 和 的 右 子 树 。

综 上 所 述 ,这 棵 二 又 树 的 根 结 点 已 经确定 ,而且 其 左右 子 树都 唯一地 确定了 ,所以整个

二 又 树 也 就 唯一地 确定了 。

例如 ,已知中 序 序列为DGBAECF

则构造二叉树的过程如
,后序序列为GDBEFCA,

图 7. 26 所 示 。

根结 点 : A
左 中 序: DGB 左 后 序: GDB
右 中 序 : ECF 右 后 序: EFC

根 结 点: B
左 中 序: DG 左 后 序: GD|

左 中 序: E 左 后 序: E
右中序: 空 右 后序 : 空 右中序: F 右 后 序: F

根结 点: C

根结 点; D
空 左 后序: 空
左 中 序 :
右中序: G 右 后序: G

根结点: E
左 中 序 : 室 左 后 序 :
右 后 序 :
空
右 中 序 :

根结点; F
空
空

空 | |左 中 序 :
空 | |右 中 序 :

左 后 序 : 空
右 后序 : 空

aa

根结 点: G
左 中 序 : 空 左 后序: 空
右 后序: 空
右 中 序 :

空

图 7.26 由 后 序 序列 和 中 序 序列 构造二又 树 的 过 程

231

数据 结构教程

[第! 5版

由 上 述定理得 到以 下 构造二又 树 的 算法

BTNode * CreateBT2(char * post,char * in,int n)

/* post 存放后序序列 ,in存放中序序列,n 为 二 又 树 结 点个数 ,本 算法 执行 后返回 构造的二 又 链 的 根
结 点 指针 bx /

{

BTNode * b;

char r,, x p;

int ki;

这 (Cn<一0) return NULL;

T一 * (post十n一1);

//根结点值

b 一(BTNode * )malloc(sizeof(BTNode)) ;

// 创建二 又 树 结点b

b 一 > data一T;

十n;p十十)
for (p 王in;p<in

让 (*x p一一T) break;

上 一 p 一 in;

b 一 lchild

一CreateBT2(post,in,k);

b 一 rchild一CreateBT2(post十k,p十 1,n一k一1);

return b;

)》

//在in 中查找根结点

//E 为 根 结 点在让 中 的 下 标

//递归 构 造 左子树

//递归 构 造 右子树

【例7. 19]

设计 一 个 算法 ,将 二 又 树 的 顺序 存储 结构 转换 成 二 又 链 存储结构 。

设 二 又 树 的 顺序 存储结构为g,由Ca,i返回创建的以 a[ 世 为 根 结 点 的 二 又 链 存

储结 构 ( 初 始调用 为 0一/Ga,1))。 转 换 过 程 对 应 的递归 模型如 下 :

Fra,芒=NULL

ra,芒=NULL

i 大于 MaxSize

i 对 应 的 结点 为 空 ,即 a[可 一 '#

Ja, 访一0( 创 建根结点5,其data 值 为a[朴);

其他情况

视频讲解

一> lchild一Fa,2xD;

0一> rchild一Fa,2xi 二 1)

对

应 的递归算法如下 :

BTNode * trans(SqBTree a,int iD)

{

BTNode * b;

迁 (i> MaxSize)

returmnCNULL) ;

秆 (a[ 口 王一'# return(NULL);

// 空 结 点 返回NULL

b 一(BTNode * )malloc(Csizeof(BTNode) ) ;

// 创 建 根 结 点 b

b 一 > data一a[] ;

b 一 lchild王trans(a,2xi;

b 一> rchild王trans(a,2xi 十1);

return(b) ;

//递归创建左子树

// 递 归 创 建右子 树

// 返 回 根 结点

232

人 7人齐放权和二又村

线索 二 又 树

2

771 线索二又树的概念

对 于 具有 宛 个 结 点的二 又 树 , 当 采用 二 又 链 存 储结构时 ,每 个 结 点有两 个 指针 域 , 总 共

有 272 个 指针 域 ,又由于 只 有 2 一 1 个结 点 被有效 指 针 域所指向 (2 个结 点 中只有 根结 点没有

被有效 指针 域 指向), 则 共有 2 一(一1)一2十1 个 空链域。

痪 历 二 又 树 的结果 是 一 个结 点 的 线性 序列 ,可 以 利用 这 些 空 链 域存放 指向 结 点 的 前 驱

结点和 后 继 结 点 的 地 址 。其 规定是当 某 结 点 的 左 指针 为 空时 , 令 该指针 指向 这 个 线性 序列

中 该结点 的 前 驱结 点; 当 某结 点 的 右 指 针 为 空时 , 令 该 指针 指向 这 个 线性 序列 中 该 结 点 的

后 继结点 ,这 样 的指向 该线性 序列 中 的 “前 驱结 点>”和 “后继结 点 ”的 指针 称 为线索 (thread) 。

创建线索 的 过 程 称 为线索 化。线 索 化 的 二 又 树 称 为线索 二 叉 树(threaded binary-tree)。

由 于 遍历 方式不同 ,产生 的 遍历线性 序列 也 不 同 ,会 得 到 相应 的 线索 二 又 树。一般有先

序 线索 二 又树 .中 序 线索 二 又树和 后 序 线索 二 又 树。创 建线索 二 又 树 的 目的

是提高该遍历

过 程 的效率。

那么 ,在 线索 二 叉 树中如 何 区 分 左 指针 指向 的是左 孩子结 点还是 前 驱 结 点 , 右 指针 指向

的 是 右 孩子结 点 还 是 后继结 点 呢 ?

为 此 ,在 结 点 的 存储结构上 增加 两 个标志位 来区分 这 两

种 情况 :

左标志 ltag 一

右标 志 rtag 一

0

1

0

1

表示 lchild指向左孩子结点

表示 lchild 指向前驱结点

表示 rchild指向右孩子结点

表示 rchild 指向后继结点

这 样 ,每个结 点 的存储 结构如 下 :

ltag

lchild

data

Tchild

Ttag

在 某 遍 历 方式的 线索 二 又 树 中 , 若开始 结 点 户 没有左 孩子, 将 沁 结 点 的 左 指针 改 为 线

索 , 其 左 指针 仍 为 空; 若 最后结 点 g 没有右孩子,将 dg 结点的右指针 改 为线索 ,其右指 针 仍

为空。对 于 其 他结 点 ~, 若 它 没有左 孩子, 将 左指针 改为指向 前驱结 点 的非 空 线索; 若 它 没

有 右 孩子, 将 右指针 改 为 指向 后 继 结 点 的非空线索 。

为 使 创建线索 二 又 树 的 算法 设计 方便,在 线索 二 又树中 再 增加 一 个 头 结 点 。头结 点 的

data 域 为 空; lchild 指向 无线索 时 的 根结 点 ,ltag 为 0; rchild 指向 按 某 种 方式遍历 二 又 树 时
的 最 后一个 结 点,rtag 为 1。 图 7. 27 为图7. 13(a) 所 示 的 二 又 树 的 线索 二 又 树,其 中 ,
是 先 序 线索 二 又 树 ( 先
图 7. 27(a)是中 序 线索 二 又 树(中 序 序列为DGBAECF),图7.27(b)

ss

序 序列为ABDGCEF) ,图 7. 27(c) 是后序线索 二 又 树 ( 后 序 序列为GDBEFCA)。 图中的实

线 表示 二 又 树 原来指针 所 指 的结 点 ,虚线 表示 线索 二 又 树 所 添加 的 线索 。

772 线索化二叉树

建立 线索 二 叉 树 ,或者说 对 二 又 树 线索 化,实际上 就是遍历 一 棵 二 又 树 , 在 遍历 的 过 程

233

数据 结构教程

[第! 5 【版

Toot:

四
o|

AM

1

/

把

1/

帮

| 人
了
0|Al0

、、

\

和和
和
>、、、\、

7

四

昌

87 NA

By 0|Cc

AN
AN

、

、

NA
\A\

Toot

四
oj

| | 、
T
0|Al0

\

愉

和、、

和

0|B|1

AN

和

和
\、
"clo|、

罗

\

1/

交
AN 4人
”AAA
1 |1plo LUEDDDEL Dll /1 El
1
\ |、 1 国 有 |

、 | 1 | ,
1
IFl1

国 国 梧 中 |

\
SAT

国

一

\

恩

一

了

\

1

1

1

、

CT

、\

\\
\

和 -=

EN

T 一

\

1 让 1

AI 一

,|1lcl

\

\、|

国

7/

1

、

\

[el

\ 1 有

NAN

上

(a) 中 序 线索 树

(b) 先 序线索树

Toot:

人
o|

- 才

1

上

六

广
|0Al0

了

于

AN

olBli

olcjo

罗

昌

|

~、、

、

[pbo

E|

1

1 FI

罗

1
1

\

-二 一|

下

四

、_-

上

1

1
NU

~ 一

(o)后序

序 线索 树

图 7.27 线索二又树

中 检查 当前结点

的 左右指针域是否为空 ,如 果为 空 , 将 它们 改为指向前 驱结 点或后继结点

为 了 实现 线索化 二 又 树 ,将 前 面二又 树 结点 的类型声

f 明修改如下 :

typedef struct node
ElemType data;

{

int ltag,rtag;

Struct node * lchild;

Struct node * rchild;

) TBTNode;

// 结 点数据域
// 增 加 的线索标记
// 左 孩子或线索 指针
// 右 孩子或线索 指针
// 线 索 二 又 树 中 的 结 点 类 型

234

7As 机和-X村 |

下 面以 中 序线索 二 又 树 为 例 讨论 建 立 线索 二

又树的算法。

CreateThread(20)

算法的功能是将以二又链存储的二又树2 进行 中序 线索 化 ,并 返回 线

索 化后头 结 点 的 指针 root。Thread(Z)

算法的功能是对以结点 为根的 二 叉 树 进行 中 序 线

索化。在整个 算法 中 妃 总 是指向 当前 被线索 化 的 结 点 ,而 pre 作为 全 局 变量 ,指向 刚 访问 过

的结点,结点 pre 是 结点 户 的 前 驱 结 点 ,结 点 户 是结 点 pre 的 后 继 结 点 。

CreateThread(0)

算法的思路是先创建头结点 root ,其 lchild 域 为链指 针 ,rchild 域为 线

索。将 lchild 指针 指向 根结 点 020, 如果 2 为 空 , 则 将 其 lchild 指向 自身,和否则将 root 的 lchild

对整个二又树线索
指向结 点 0, 首先 妃指向结点 2,pre 指向头结点 root。 再 调用Thread(0)

化 ,最 后加 入指向 头结 点 的线索 ,并 将 头结 点 的 rchild指针域线索化为 指向 最 后 一 个结点

(由 于线索化直到 户 等于NULL 为 止,所以 最后访问 的结 点是 pre)。

算法类似于中序遍历的递归算
Thread()

pre

法。在 中序 遍历中, 指向 当前访问 的 结 点 ,
pre 指向 中 序 遍 历 的 前 一 个结 点 (初始时, pre

指向 中序 线索 二 叉 树 的 头结 点 root) 。若 结点

尹 原 来 左指针 为 空,改 为 指向 结 点 pre 的 左线

索 , 若结点 pre 原来 右指针 为空 , 改 为指向结点

户 的 右 线索 ,如图 7.28 所示。

中 序线索 二 又 树 的 算法如 下 :

人、
若结 点 pre 原 来 右 指 ”车 结 点 p 原 来 左指
。 针 为 空 ,改为指向
针 为 空 ,改为指向
结 点 pre的 左 线索
结 点 p的 右线 索

图 7.28 将 空指针 改 为线索 的 过 程

TBTNode * pre;

// 全 局 变量

void Thread(CTBTNode * &p)

// 对 二 叉 树 p进行中序线索化

{

ii(CpI=NULL)

{

, Thread(Cp ->1lchild) ;

这 (p 一 lchild 一一NULL)

, p 一 lchild一pre;

p 一 1ltag一1;

{

】}

else

p 一 > 1ltag 一 0;

(pre 一 > rchild 一王NULL)

pre 一> rchild一p;

pre 一 rtag一1 ;

{

】}

else

pre 一> rtag一0;

pre 一 P;

Thread(p 一 rchild) ;

}

}

// 左 子 树线索化
// 左 孩子不存在,进行前驱结点线索化

// 建立当 前 结 点 的 前 驱 结 点 线索

//p 结 点 的 左 子 树 已线索 化

//对 pre 的后继 结 点线索化
// 建 立 前 驱 结 点 的 后 继 结 点 线索

// 右 子 树线索化

TBTNode * CreateThread(CTBTNode * b)

// 中 序 线索 化 二 叉 树

{

TBTNode * root;

root 一(TBTNode * )malloc(sizeofCTBTNode) ) ;

// 创 建头结 点

root -> ltag一 0;root 一 > rtag一1;

root 一 Tchild 一 b;

计 (b= 王 NULL)

//空二叉树

数据 结构教程

(第5 【版

root ~ lchild一root;

root 一 lchild一b;
pre 一 root;
Thread(b);
pre 一> rchild一root;

pre 一> rtag一1;
root 一 rchild一pre;

else

{

}

ITeturn IOot;

//pre 是 结 点 p 的前驱 结 点 , 供 加 线索 用
// 中 序遍 历 线索化二 叉 树

// 最 后 处理, 加 入 指向头结 点 的 线索

// 头 结 点 右 线索 化

773 遍历 线索 化 二 叉 树

遍历某种 次序 的 线索 二 又 树 就 是从该 次 序 下 的 开始结 点出 发,反复找

到 该结 点 在 该 次 序 下 的 后 继结 点 ,直到 头 名

0

下 面 仍然 以 中序线索 二 又 树的中序 遍 历 为例进行 讨论。在 中序 线索二 古 钥

又 树 中 ,开始 结 点 是 根结 点 的 最左下结 点 ,该结 点 的 左指针 域为线索 (指向 头结 点 的 线索 ),

即 ltag一1, 所 以找 开 始结 点的过 程如下 ,

P指向根结点;
while (p -> ltag 一一0)

p一p 一 lchild;

当找 到 开始结 点 ( 即结 点 妨 后访问它。如 果 结 点 名 的 右 指针 是 右 线索 ,说 明 右 线索 指向

的 是 后 继 结 点 ,就移到 后 继结 点 并 访问; 如 果结 点 户 的 右指针 不 是 右 线 索 , 它 指向 的 是 右 子

树 ,就 转向右子树。对 右 子 树的遍历和 对 整个二 又 树 的 遍历 是 相似 的,所以 中 序 遍历 过 程如 下 :

P 指向根结点;
while p 天 root 时 循环
{ 。找开始结点p;

访问 p 结点;
while (p 结点有 右 线 索 )
一 直访问下去;
D转向右孩子结点;

)}

对应的算法如下 :

void ThInOrder(TBTNode * 世)

{

TBTNode * p=tb 一 1lchild;

while (p!一tb)

// 不 是 右 线索 的 情况

//tb 指向 中 序 线索 二 又 树的头 结 点

//p 指向根结点

{

while (p -> ltag 王 一0) bp 一p 一 lchild;
printf("%c",p一> data);

// 找开始结点
// 访 问 开 始 结 点

while (p -> rtag 一一1 && p -> rchild!一tb)

,p=p 一> rchild;
printf("%c",p 一> data);

{

】》

p王p 一> rchild;

236

7As放。。本和=X村

|

)}

显然,该 算法 是非递归 的 ,其中也没有 使用 栈。尽 管时 间 复 杂 度 仍然为OCz)(? 为二叉

树 中 的 结 点 个 数) ,但 空间 效率 得 到 提高 ,空间 复杂 度为O(1)。

哈 夫 曼 树

米

781 哈 夫 曼 树概述

在许多 应 用 中经 常将树 中 的 结点赋予 一 个有某 种 意义 的 数值 ,称此 数值 为该结 点 的 权 。

从 根 结点到 该 结 点 之 间 的 路 径 长度与 该 结点上 权 的 乘积称 为结点 的带权 路 径 长 度

(Weighted Path Length,WPL)。 树 中所有 叶子结点的带权 路 径 长 度之和 扫一扫

称 为 该树的 带 权 路 径 长度 ,通常记 为 :

本

国

WPL = > zu,

其中,me 表示 叶子 结 点 的 个 数,zw 和 .2 分 别 表示第; 个 叶子 结 点的权值和

根 到 它 之间 的 路 径 长 度 (即 从 根 结 点 到 该 叶子 结 点 的 路径上 经 过 的 分支数 ) 。

在 z 个 带权 叶子结 点构成 的 所 有 二 又树中 , 带权 路径 长度WPL 最 小的 二 又树 称 为

哈 夫 曼 树(Huffman tree)或最优二又树。因为 构造这 种 树 的 算法 最 早 是由哈 夫 曼 于 1952

年 提出 的 ,所 以用他 的 名 字 命名。

例如 ,给 定 4 个 叶子 结点, 设其权 值 分别 为 1.3.5、7,

可以构造出形状不同的4 棵 二 又

树 ,如图7. 29 所 示 。 它们 的 带权 路 径 长 度 分别如 下 :

二3X2十5X2十7X2一32
(a) WPL=1X2

二3X3十5X3十7X1一33
(b) WPL=1X2

十5X3十3X2十1X1王43
(c) WPL=7X3

(d) WPL 王1X3十3X3十5X2十7X1一29

由 此 可 见 ,对 于 一 组具有 确定权 值的叶子 结点可以 构造 出多个具有 不 同 带 权 路 径 长 度

的二叉树。可 以证明 , 图 7.29(d) 所 示 的 二 叉 树 是 一 棵 哈 夫 曼 树 , 它 的 带权 路 径 长度最小 。

人

国

CO 0 思

四 加 加 加 加 吕

OOMNOIONNROG

(G)

(b)

(9

(d)

图 7.29 由 4 个 叶子 结 点 构成 的不同 的带权 二 叉 树

237

| 数据结构 教程SEA5

782 哈 夫 曼 树 的构造 算法

那么给定 m 个权 值 ,如 何 构造 一 棵 含有 me 个带有 给 定权 值 的叶子结 点的二 又 树 ,使其

带权 路 径 长度WPL 最 小 呢 ? 哈 夫 曼 最 早 给 出 了 一 个带有 一 般 规 律 的 算法 , 称 为 哈 夫 曼 算

法 。哈 夫 曼 算法如下 :

(1) 根据给定的 mm 个权 值Cr ,zz,...,,zow)

,对应结点构成 mn 棵 二 又 树 的森林 下一

CT,T

To) ,其 中 每棵二 又 树 盖(1 志 ;过 wo) 中 都只有 一 个 带权 值为rw 的 根结 点 ,其

左 \ 右子树 均 为 空 。

(2) 在 森林 正中选取 两 棵 结 点 的权 值 最小 的 子树分别 作为 左 、 右 子树构造一棵 新的二

又树 ,并 且 置新的二 叉 树 的根结 点 的权 值 为其左右 子 树 上 根的权 值 之和 。

(3) 在 森林 下 中 ,用 新 得 到 的 二 又 树代 替 这 两 棵 树 。

(4) 重复 (2)和 (3) ,直到 下 只 含一棵 树 为 止 。这 棵 树 便 是 哈 夫 曼 树 。

例如 ,假设仍采用 上 例 中 给 定 的权 值 克=(1,3,5,7)

来构造一棵哈夫曼树,按照 上述算

法,则图7. 30 给 出 了 一 棵 哈 夫 曼 树 的 构造过 程 ,其中图 7. 30(d) 就 是 最 后 生成 的 哈 夫 曼 树 ,

它 的 带 权 路 径 长 度为 29 。

09

Ooieke

ioio 名 0 包

但 外

0 名

0 名

@ie@

(9)

(Cb)

(9

图 7.30 构造哈夫曼树的过程

@iG@

(Cd)

定理 7.3: 对 于 具有 mo 个 叶子 结 点 的 哈 夫 曼 树 ,共有 2zo 一 1 个结 点 。

证明 : 在 哈 夫 曼 树的构造 过程中 ,每 次 都是将两棵 树 合 并 为一棵 树,所以 哈 夫 曼 树 中 不

存在 度为 1 的结点, 即 闭 天0。由 二 又 树 的 性 质 1 可知 mm 三 到 十1,即 罗 一 2 一1, 则 2 一 2 十

7 十22一 7o 十2 一zio 十7o

一1一2zo 一1。

为 了 实现 构造哈夫 曼 树 的算法,设计 哈 夫 曼 树 中 的结 点 类 型如 下 :

pe

typedef struct

{

char data;
double weight;
int parent;

int lchild;

int rchild;

HTNode;

// 结 点 值
// 权 重
// 双 亲 结 点

// 左 孩子结点

// 右孩子结点

用 ht[ ] 数 组 存放 哈 夫 曼 树 ,对 于 具有 mm 个 叶子结点的 哈 夫 曼 树 ,总 共有 2z 一 1 个结

。 其 算法 思路是,xz 个 叶子结点 (存放在 htL0] 一 ht[Lz 一1] 中 )只有 data 和 weight 域值,

238

7人力权和=村 |

先将2 一1 个结 点的 parent lchild 和 rchild 域 置 为 初 值 一 1。 然 后处理 每 个非叶 子结点

ht[订(存放在 htLzo]

一htL22一2中 ): 从 ht[O] 一 ht[Li 一 2 中找 出 根结 点 (其 parent 域为

一 1) 最 小 的 两 个结 点 htLlnode]和 ht[rnode]

,将它们作为 ht[ 的 左 、 右 子 树 , 将 htLlnode]和

htLrnode]

的双亲结点置为htL,并且 htLz. weight

王htLlnode]. weight

十htLrnode]. weight。 如

此 这 样直到 加 一1 个非 叶 子结 点 处 理 完毕。构 造 哈 夫 曼 树 的 算法如下 :

void CreateHTCHTNode ht[] ,int n0)

{

int ik,lnode,rnode;

double minl, min2;
for (i 一0;i<2xn0一1;i十十)

// 所 有 结 点的相关 域 置 初 值一1

ht[ 品 .parent一ht[D] .lchild一ht[D .rchild一一 1;

for (i 一n0;i<一 2x n0 一2;i十十)

// 构 造哈夫 曼 树的 n0 一 1 个 分 支 结 点

{ minl一min2一32767;

V//lnode 和 rnode 为 最 小 权重 的 两 个结点 位 置

lnode 一rnode一一1;
for (k 一 0;k< 一 i 一1;k 十十)

让 (ht[k]
. parent一一一1)

{

, 计 (Cht[ .weight< minl)

//在 ht[0..i 一 切中 找 权 值 最小 的 两个结 点

// 只 在 尚未 构造 二 又 树 的 结点中 查找

{

min2一minl;rnode一lnode;

minl 一 ht[k] . weight;lnode一k;

}
else i 计 (ht[k] . weight < min2)

{

min2一 ht[k] . weight;rnode一k; }

】}

ht[口 . weight王ht[lnode] . weight十htLrnode] . weight;

ht四 .lchild 一lnode;ht中 .rchild一rnode;

//ht跨作为 双亲结点

ht[lnode] . parent一i;ht[rnode] . parent一ii;

783 哈 夫 曼 编 码

在 数据 通信 中 ,经常需要 将传送的 文字 转换 为二进制字符 0 和 !1 组 成的二 进制字符 串 ,

称 这 个 过 程 为 编码 。显然,我 们 希望电文 编码 的 代码 长度最 短

。 哈 夫 曼 树 可 用 于 构造使电

文 编码 的代码 长度最 短 的 编码 方案 。

具体 构造 方法如下 : 设 需要 编码 的 字符 集合 为{d ,ds ,...',du ,各 个 字符在电文中 出

现 的 次 数集合 为

fear rz 六 以 oa du 作 为叶子结 点,以 zyrzs,...zom 作 为 各

根结 点 到 每个叶子结 点 的权 值构造一棵 哈 夫 曼 树 ,规定 哈 夫 曼树中 的 左 分 支为 0` 右 分 支 为

1, 则 从 根结 点 到 每 个叶子结 点 所经 过 的 分支对 应 的0 和 1 组 成 的 序列 便 是 该结 点 对 应 字符

的 编码。这 样 的 编码 称 为哈夫 曼 编 码(Huffman coding) 。

哈 夫 曼 编码 的 实质 就 是 使用 频率 越 高的字符 采用 越短的编码 。

为了实现 构造 哈 夫 曼 编码 的 算法 ,设计 存放 每 个结 点 的 哈 夫 曼 编码的类 型如 下 :

typedef struct

{

char cd[LN];

// 存 放 当 前 结 点 的哈夫 曼 码

int start;

部分是哈夫曼码
// 表 示 cd[start..n0]

) HCode;

239

扫一扫

吕

视频讲解

数据 结构教程

[第! 5版

由 于 哈 夫 曼树中 每个叶子结 点 的 哈 夫 曼 编码 长 度不同 ,为此 采用 HCode 类 型变量的

cd[start..no] 存 放 当 前 结 点 的 哈 夫 曼码 ,只 需 对 叶子结 点 求哈夫 曼 编码 。对 于 当前 叶子 结

点 ht[ 订 , 先 将对 应 的 哈 夫 曼码 hecd[ 的 start 域 值 置 初值 w ,找其双亲结点ht[门,若当前

结 点 是 双亲 结 点 的 左 孩 子结 点 , 则在 hcd[ 实 的 cd 数组中添加 0, 若 当前结 点是双亲 结 点 的

右 孩 子结 点 , 则 在 hcd[ 详 的 cd 数组中添加 1 ,并将 start 域减 1。再对双亲 结 点 进行同样

的 操作 ,如 此 这 样 直 到 无 双亲结 点 (即 到 达 根结 点) ,所以 start 指向 哈 夫 曼 编码 最开始 的

字符。

根据 哈 夫 曼 树求对 应 的 哈 夫 曼编码 的 算法如 下 :

void CreateHCode(HTNode ht[] ,HCode hcd[] ,int n0)

{人 intifc;

HHCode hc;

for (i一0;i<n0;i十十)

一n0ic一i
人 hec.start

{ 一 ht器.parent;

while (fl一一1)

// 根 据 哈 夫 曼 树 求哈夫 曼 编码

// 循环直到 无 双亲 结 点 ,即到 达 根 结 点

{

填 Cht[旧 .lchild一一c)

// 当 前 结 点 是 双亲 结 点 的左孩 子

hec.cd[hc.start一一] 一 '0';

else

// 当 前 结 点 是 双亲 结 点 的 右 孩 子

hec.cd[hc.start一一] 一 '1;

c 一 全 { 一 ht[ .parent;

// 再 对 双亲 结 点 进行 同样的操作

】》
hec. start 十十;

hcd[ 口一hc;

】}

/Vstart 指向 哈 夫 曼 编 码 最 开始 的 字符

哈 夫 曼 编码 的 平均 长度=

> di X rw。

说明: 在 一 组 字符 的 哈 夫 受 编码中 , 任 一 字符 的 哈 夫 曼 编 码不可能 是另一 字符哈夫曼

编码的前缓。

儿个字母组成,字母在电文中
【例7.20】 假设 用 于 通信 的 电文 仅由ab.c.d\e\f\g\h

出 现 的频率分别为 0.07.0. 19.0. 02.0. 06.0. 32.0.03、0. 21 和 0. 10, 试为这 些 字 母 设计哈

夫 曼 编码 。

构造 哈 夫 曼 树 的 过 程如下 。

第 1 步 选择频率 最 低的 c 和 上 构造一棵 二 又 树 ,其 根结 点 的 频率为 0.05,记为结点 di ;

EEE

第 2 步 选择频率 低的d 和 d 构造 一棵二 又 树 ,其根结 点 的 频率为 0.11 ,记为结点 心 ,

第 3 步选择 频率 低的 a 和 jh 构造一棵 二 又 树 ,其 根结 点 的 频率为0. 17, 记 为结 点 ds ;

第 4 步 选择频率低的ds 和 ds 构造一棵 二 又 树 ,其 根结 点 的 频率为 0.28, 记为 结点 必 ;

第 5 步 选择频率低 的2 和 8g 构造一棵 二 又 树 , 其 根结 点 的 频率为0.4,记为结点 ds;

第 6 步 选择频 率 低的 和 e 构造一棵 二 又 树 ,其 根 结 点 的 频率为0. 6 ,记为 结点 ds;

第 7 步 选择频率低的ds 和 ds 构造一棵 二 又 树 ,其 根结 点 的 频率为1. 0, 记 为结点 di。

最后构造 的 哈 夫 曼 树如 图 7. 31 所 示 ( 树 中 的 叶子结点用 圆 或椭圆 表示 ,分支 结点用 和矩

240

7人齐 村和二又村

形表示 , 其 中 的 数字 表示 结 点 的 频率 ) ,给所有的 左 分 支加 上 0, 给 所 有 的 右分支加上 1, 从 而

得 到 各 字母 的哈夫 曼 编码如 下 。

a: 1010

b: 00

c: 10000

d: 1001

e: 11

f: 10001

g: 01

h: 1011

0

b

4

0.40

0

C

1.00 |力

1

0

0.60 |

1

0

1

1

g

1

d

0

Ba

0.17

|d
了3

1

h

吧| 0.11

0

1

下

图 7.31 一 棵 哈 夫 曼 树

这 样 ,该 棵 哈 夫 曼 树 的带权 路 径 长度WPL=4X0.07十2X0.19十5X0.02十4X0. 06十

2X0.32十5X0.03十2X0.21十4X0.1 一

2.61。

用 并 查 集 求 解 等 价 问题 ”站

等价关 系是现实 世界 中 广泛 存在 的 一种关系 。对 于 集合 S 中 的 关系尺, 若具有 自反、对

称 和传递性,则尺 是一个 等价

关系。由等价关系 尽 可 以 产生 集合 S 的 等价类 ,可 以 采用 并

查 集 高效地 求解 等价类问题 。

791 什么叫并查集

并 查 集支持 查找 一 个 元 素所属 的 集合以 及 两 个元素 各 自 所 属 的集合 的

合并等运算。当 给 出 两 个元素 的 一 个 无 序对(ea,2) 时 ,需要 快速“合并?oa 和

视频讲解

2 分 别 所 在 的 集合,这 期间需要 反复 “查找? 某 元 素 所 在 的 集合.。“ 并”“查”

和*集?3 个 字 由 此 而 来 。在 这 种 数据 类 型中,” 个 不同的 元 素被分 为 若干 组。每 组是一 个
集合 ,这 种 集合叫 分 离集合 , 称 之 为 并 查集(disjointset)。

Sn

下 面通过 求 亲戚 关系 的 例子说明 并 查 集 求解 等价问题的过 程 。

问题: 对 于 亲戚 关系问题 ,现给 出 一些亲 不 关系 的 信息 ,如 Marry 和 Tom 是 亲戚.Tom

和 Ben 是 亲戚 等,需要 从 这 些 信息 中 推出Marry 和 Ben 是 否为亲戚。

输入: 第 一 部 分以NM 开始。N 为问题涉及的人 的 个 数(1 委 N 委 20 000)。 这些人的

编号 为 1.2.3、...\、N。 下 面有M 行(1 过 M 所 1 000 000),每行有两个数 w,表示已知w 和

241

数据 结构教程

[第! 5版

第二部分 以Q开 始 。以下Q行对应Q 个询问(1过Q反1 000 000) ,每 行为 c .di ,表示询

问 c 和 w, 是 否为亲戚。

输出: 对 于 每 个 询问 c di ,输出一行,若 c 和 wd

为 亲 威 , 则 输出“Yes”, 和 否则 输出“No”。

输入样例,

107

2 4

57

13

8 9

12

56

2 3

3

3 4

7 10

8 9

/N=10,M=7
// 表 示 2 和 4 是 亲 威
// 表 示 5 和 7 是 亲戚
// 表 示 1 和 3 是 亲戚
// 表 示 8 和 9 是 亲 威
// 表 示 1 和 2 是 亲 威
// 表 示 5 和 6 是 亲 威
// 表 示 2 和 3 是 亲 威
//Q=3
//问3 和 4 是 否为亲 威

//问7 和 10 是 否为亲 威
//间8 和 9 是 否为亲 威

问题分析: 亲戚关系 是 一种典型 的 等价关系。将 每 个人抽象 成 为一个 点 (每个点 用

其 编号 唯一标识) ,输入 数据 给出 M 个 边的关系 , 当 两 个人是 亲戚 的时 候 两 点 间 有 一 条

边 ,很 自然 地 就 得 到 了 一个 N 个 顶点.M 条 边 的图论 模型 ,在 图 的一个连通 块中的任意点

之间 都是亲戚 。对 于 最 后的Q 个 提问 ,即判断所 提问 的 两 个 顶点是 否 在同一 个 连通

块中。

采用 集合 的 思路 求解: 对 于 每 个人建立 一 个 集合 ,在 开始 的时 候 集合 元 素 是 这个人 本

身 , 表 示 开 始时 不 知道 任何人是 他 的 亲 威 ,以 后 每 次给出 一个亲戚关系 时 就 将 两个集合 合

并 ,这 样实时 地 得 到 了 在 当前 状态下总 的 亲戚 关系。如 果 有 提问 ,即在当前得 到 的 结果 中 看

两个元 素 是 否属于 同一 集合。对 于 样例数 据 的 解释如 表 7.6 所示。

表 7.6 对 亲 威 关系 样例数据 的 解释

输入关系

初始状态
(2,4)7

(5,7)

(1,3)

(8,9)

(1,2)

(5,6)

(2,3)

等 价 类

{1)(2}{13} (4)(5}(16}(7)(8}(9} (10}
{1)(2,4)(3}(5}16}(7)(8)(19}(10)}

{1) 2,4)(3)(5,7)(6}(18}(9)(10)

168) (910}
{1,3} (2,4)(5,7)

{1,3} (2,4)(5,7} (16)18,9}(10}

{1,2,3,4}{5,7}{16}{8,9}(10)}

{1,2,3,4}(5,6,7} (8,9}{10)}

{1,2,3,4}{5,6,7}(8,9}(110}

由表 7. 6 可以 看 出 ,操作 是 在 集合的基础上 进行 的 ,没有必要 保存所有 的 边 , 而 且 每 一

步 得 到 的 划分 方式是 动态的 。

并 查 集 的 数据结构记录 了 一 组 分 离 的动态 集合S= {Si,S:,...','Se}。 每 个 动态集合

Si(1 近 运 所 通过 一 个"代表 ”加 以标识 ,该代表 即为所代表 的 集合 中 的 某 个 元 素 。对于 集合

Si ,选取 其 中 哪个元 素 作为代表 是任意 的 。

242

7As

机和-X村 |

对 于 给 定 的编号为1~z 的”个 元 素,z 表示 其 中 的一个元 素 , 设 并 查 集为 S, 并 查 集 的

实现 需要 支持如 下 运算 。

(1) MAKE_SET(CS,m): 初始化并查集S,即 S王1S; ,S, ,...,S,) ,每个动态集合 S (1所

im 仅仅 包含 一 个编号为;的

元 素 ,该元素作为集合 S; 的“代表”。

(2) FIND_SET(S,z): 返回并查集S 中 元 素 所 在 集合 的 代表 。

(3) UNION(S,z,y): 在 并 查 集 S 中将zx 和 > 两 个元 素 所 在 的 动态集合(例如 S。和

S,) 合 并 为一个 新 的 集合SUS,。 并 且假设 在 此 运算 前 这 两 个动态 集合 是 分 离的,通常以

S. 或者 S, 的代表 作为 新 集合 的代表 。

792 并 查 集 的算法实现

扫 一扫

环节 ,选择不同 的 数据结构 可 能 会 在 查找 和 合并 的 操作 效率 上 有很大的 差

别。并 查 集 的 数据 结构 的 实现 方法 很 多 ,使用比较 多 的 有 数组 实现 、 链 表 实

现和树实现 。这 里 主要 介绍 树 实现 方法 。

用 有 根 树 表 示 集 合 , 树 中 的 每 个结 点 包含集合 的 一 个元 素 , 每 棵 树 表示 一 个 集合。多个

集合 形成一个 森林 ,以 每棵树 的 树根作为 集合 的代表 , 树 中 每 个 结 点 有 一 个 指向 双亲结 点 的

指针 , 根结 点 的 双亲 结 点 指针指向 其自身 。

注意: 在同一 棵 树 中 的 结 点属于 同一 个 集合 ,虽然 它们 在 树 中 存在 父子 结 点 关系 ,但 并

不 意味 着 它们 之间 存 在 从 属 关系。树 中 的指针 起 的只是 联系集合 中 元 素 的作用 。

在 并 查 集中 ,每 个 分 离集合对 应 的 一 棵 树 称 为分离 集合 树。整个并 查 集 也 就 是一个 分

离 集合森林 。 图 7. 32 所 示 为 表示 前 面 亲戚 关系 中 的 各 分 离集合 树 , 其 包含 4 个集合,即

{1,2,3,4) 15,6,7) (18,9} 和 {110) ,分别 以 4.7.9 和 10 表示 对 应 集合 的编号 。

(a)1 2. 3, 4} 集 合

(b) {5, 6,

7} 集 合

(c) {8, 9} 集 合

(d) 110} 集 合

图 7.32 用 树 表示 集合

显然在 一 棵 高度较低的树中 查找 根结 点 的 编号( 即 该 集合 的代表 ) 所 花 的时 间 较 少 , 那

么 如 何 保证 构造的分 离集合 树 较 低 呢 ?

as

如 果 有 两棵分 离集合树 A 和 已 ,高度分别为 aa 和 Aha, 若ja二Am ,应 将已树 作为A 树的

子树; 否则 ,应将A 树 作为 下 树 的 子 树

。总 之 ,总 是 将 高度较小 的 分 离集合 树 作 为子树 。

得 到 了 新 的 分 离集合树 C 的 高度 Ac ,如以召 树 作 为A 树 的 子 树 ,nc王MAX{Pa hn十 1)。

这 样合并得 到 的 分离集合 树 的 高度不 会超过 logw,是一个比较 平衡 的树, 对 应 的 查找

与合并 的时间 复 杂 度 也 就稳定在O(logxz) 了 。

为 此 给 每个结 点 增加 一 个 秩 (Crank) 域 ,它是一个 近似 子 树 高度的 正 整数,同时 它 也 是 该

数据 结构教程

[第! 5版

结 点 高 度 的 一 个上界 。

为 了 方便 ,采用 顺序 方法存储 森林 ,对 于 前 面 的求亲戚关系 的 例子 ,其中 结点的 类 型 声

明 如 下 :

typedef struct node

{

int datai

int rank;

int parent;

} UFSTree;

全 并 查 集 酝 的初始化

// 结 点 对 应人的编号

// 结 点 对 应 秩

// 结 点 对 应 双亲 下 标

// 并 查集树 的 结 点 类 型

建立 一 个 存放 并 查 集 树 的 数组 ... 对 于 前 面 的求亲戚 关系 的 例子 ,每个结 点 对 应的人 ,

结 点的data 值 设 置 为 该人的 编号,rank 值 设 置为0,parent 值设置 为 自己。算法如下 :

void MAKE_SETCUFSTree t[] ,int n)

// 初 始 化并查 集 树

{

inti;

for (i王1;i<一nii十十)

人 t 口.data一ii

t口.rank一0;

t[回 .parent一i;

)}

2 和 找 一 个并素所 属 的集合

// 数 据 为 该人的 编号

// 秩 初始化为0

// 双 亲 初 始化指向 自己

在 分 离集合森林中 ,每一棵 分 离 集合树对 应 一 个 集合 。如 果 要 查找 某 一 元 素 所 属 的集

合 , 就是要 找 这 个 元 素 对 应 的 结 点 所 在 的 分 离集合 树 。

不 妨 以 分 离 集合 树 的根结 点 的编号 来标识 这 个 分离集合 树 , 这 样 查找 一个结 点 所 在 的

分 离 集合树也 就是查找 该 结 点 所 在 分 离集合 树 的 根 结 点 。

查找树的根结点的方法很简单,只 需任 取 树 中 的 一 个 结 点 (不 妨 取 要 查找 的那个 结 点 ),

沿 双 亲 结 点 方向一直 往 树 根走: 初始时 , 取 一 个结点 , 走 到 它 的 双亲 结点,然后以双亲 结 点

对应的算法如下 :

四

int FIND_SETCUFSTree t[] ,int x)

//在x 所 在 的 子树中 查找 集合编号

让 (xl一tx .parent)

// 双 亲 不 是 自己

return(FIND_SET(t,t[xaq .parent)); // 递 归 在 双亲 中 找 x

else

TeturnCx) ;

// 双 亲 是 自己 ,返回x

{

)}

对 于 个人 ,构成的分离集 合 树 的 高度最 高为 log:>, 所 以 本 算法的时间 复 杂 度为O(logzz) 。

3 两 下 元素 各 训 所 必 的集合 的 合并

在 进行 合并 的 时 候 , 只 需要让 具有 较小 秩 的根 指向具有较大秩的 根。如 果 两 根 的秩相

3

7As放机和=村 |

等,只 需要 使其中 一

指向 另 一个,同时秩增加 1。 对 应 的算法如下 :

void UNIONCUFSTree t[] ,int x,int y)

//将xx 和 y 所 在 的子树合并

{ ,x 一 FIND_SETCt,x);
y=FIND_SETCt,y);
这 (t[ 芭 .rank>t[y].rank)
t[y] .parent 一 xi;

else

{

t[x.parent一y;

// 查 找 x 所 在 分 离集合 树 的 编号
//查找y 所 在 分 离集合 树 的 编号
//y 结 点 的 秩小于x结点的秩
//将y 连到x 结 点上,x 作 为 y 的 双亲 结 点
//y 结 点 的 秩大于 等于x结点的秩

//将x 连 到 y 结 点上,y 作为x 的双亲结点

这 (t[x] .rank 一一t[Ly] .rank)

t[Ly] .rank 十十 ;

//x 和 y 结 点 的秩相同
结点的秩增 1

V//y

)}

对于 ) 个 人 ,本 算法 的时 间 复 杂 度为O(log:z)。

一 -本章 小结 一一

本 章 的 基本 学 习 要 点如 下 :

(1) 掌握树的相关概念 ,包括树、结点 的 度 、 树 的 度 结 点 .叶子结

点 、 孩 子 结点 .双亲结点 、子孙结点 、祖先结点 、结点层次、相

定义。

(2) 掌握 树 的 表示 ,包括树形 表 示法 、文氏 图表示法.四 入 表示 法 和 括

(3) 掌握 树 的 性 质 、树 的 遍历 方法 。

(4) 掌握 树的 3

种 存储结

(5) 掌握 二 又树 的概念,包括 二 又树 、 满 二 又树 和 完全 二 又树 的 定义 。

(6) 掌握 二 叉树 的性 质 。

(7) 掌握 树 / 森林 和 二 又树的 转换与还原 。

(8) 重点 掌握二叉树 的 存储结构 ,包括二又树 顺 序存储 结构 和 二 又链 存储结

(9) 掌握 二 叉树 的 基本运算实现 。

(10) 重点 掌握二 又树的各 种 遍历 算法 及 其应用 。

(11) 掌握二 叉树 的 构造 方法 。

(12) 掌握线索 二 又树 的概念 和 相关 算法 的实现 。

(13) 掌握哈 夫 曼树 的 定义、.哈 夫 曼树 的 构造过 程和 哈 夫 曼 编码产生 的 方法 。

(14) 掌握并查 集 的相关概念 和 算法 。

(15) 灵活运用 二 叉 树 这种数据结构 解决一些综合应用问题

1. 有 一 棵 树 的 括号 表示为A(B,CCE,F(G)),D),

回答下面的问题:

(1) 指出树的根结点

数据 结构教程

[第! 5 【版

(2) 指出 这 棵 树 的所有 叶子 结 点 。

(3) 结点 C 的 度是多 少 ?

(4) 这 棵 树 的 度 为 多少?

(5) 这 棵 树 的 高 度是多 少 ?

(6) 结点 C 的 孩子结 点 是哪些?

(7) 结点 C 的 双亲 结 点 是谁?

2. 若一棵度 为4 的树中 度为2.3、4 的 结 点 个 数 分 别为 3.2、.2, 则 该 树的叶子 结 点 的 个

数是多少?

3.

为 了 实现以下各 种 功能 ,z 结 点 表示 该 结 点 的 位 置,给出树 的 最 适合的存储 结构 :

(1)

求zx和>y 结 点 的 最 近 祖 先 结 点 。

(2)

求 z 结 点 的所有 子孙 结 点 。

(3) 求根结 点 到 z 结 点 的 路 径 。

(4)

求 结 点 的所有 右边 兄弟 结 点 。

(5) 判断z 结 点 是 否为叶子 结点 。

(6) 求 结 点 的所有 和 孩子结 点 。

4. 设 二 又 树 bt 的 一 种 存储结构 如 表 7.7 所 示。其中,bt 为 树 根 结 点 指针 ,1lchild、

rchild 分 别为结 点 的 左右 孩子指针 域 ,在这 里 使用结 点 编号作为 指针 域 值,0 表示 指针 域值

为空; data 为 结 点 的数据域。请完成下列各题:

(1) 画 出 二 又 树 bt 的 树 形 表示。

(2) 写 出按先 序.中序和 后 序 遍 历 二 又树 bt 所得 到 的 结 点 序列 。

(3) 画 出 二 叉 树 bt 的后序 线索 树 ( 不 带头 结 点 ) 。

表 7.7 二 叉树 bt 的 一种存储结构

lchild

data

Tchild

1

0

j

0

2

0

h

0

3

2

于

0

作

3

d

9

5

了7

b

作

6

5

Ba

0

了7

8

C

0

8

0

ee

0

9

10

g

0

10

1

工

0

5. 含有 60 个 叶子 结 点 的 二 又 树 的 最 小 高 度 是多少 ?

6. 已 知 一 棵 完全 二 又 树 的第 6

层 ( 设 根 结点 为第 1 层)有 8 个 叶子 结 点 , 则 该完全 二 又

树 的 结 点 个 数最多 是 多 少? 最 少是多 少 ?

7. 已 知 一 棵 满 二 又 树 的 结 点 个 数为 20一40 ,此 二 又 树的叶子 结 点有多 少个?

8. 已 知一棵 二 又 树 的 中 序 序列为cbedahgijf\

给出该二又树的
后序序列为cedbhjigfa,

peee 树形表示。

9. 给定 5 个 字符 a 一 上,它们的权值集合克 二 42,3,4,7,8,9}, 试 构造 关于 攀 的一棵哈

夫 曼 树 , 求 其 带权 路 径 长度WPL 和 各 个 字符 的 哈 夫 曼 树 编码 。

10. 假设二 又 树 中 每个结 点 的 值 为 单个字符 ,设计 一 个 算法 ,将 一棵以 二 又 链 方式存储

的 二 又 树 0 转换 成对 应 的 顺序 存储 结构 a 。

11. 假设二 又 树 中 的 每个结 点 值 为 单个字符 ,采用顺序 存储 结构 存储。设 计 一 个算法,

求 二 又树 上 中 的叶子结点个数。

246

7As放 和村 |

12. 扑 0 中 的 每 个 结点 值 为 单个字符 ,采用二又 链 存储结构 存储。设计一个算

法 ,计算一棵给 定 二 又树思 中 的所有 单 分 支结点 个 数 。

13. 机又树中 的 每 个 结点 值 为 单个字符 ,采用二又 链存储结构 存储。设计一个算

法,求 二又树 2 中 最小 值 的结点 值 。

14. 假设二又树中 的 每个结点 值 为 单个字符 ,采用二又 链 存储结构 存储。设计一个算

法 ,将二又链 01 复制到二又链02 中。

15. 假设二又树中 的 每个结点 值 为 单个字符 ,采用二又 链 存储结构 存储。设计一个算

法,求二又树2 中 第 &

层 上 的 叶子结点 个 数 。

16. 假设二又树中 的 每个结点 值 为 单个字符 ,采用二又 链 存储结构 存储。设计 一 个 算

法 ,判断值为zx 的结 点与 值为 y 的结 点 是 否 互 为兄弟 ,假设这 样的结点 值 是 唯一的。

17. 假设二又树中 的 每个结点 值 为 单个字符 ,采用二又 链 存储结构 存储 。设计 一个算

法 ,采用 先 序 遍历 方法 求二 叉树0 中 值为z 的结点 的 子孙结点 ,假设值为z 的 结点是 唯

一的。

18. 假设 二 叉 树 采用 二 又 链 存储结构 ,设计 一 个 算法把二 又 树 0 的 左 、 右 子 树 进行 交

换 , 要 求不破坏原 二 又 树 ,并 用 相关 数据 进行 测试 。

19. 假设二 又 树 采 用 二 又 链存储结构 ,设计 一 个 算法判断 一 棵 二 又 树 2 的 左 、 右子树 是

否 同 构 。

20. 假设 二 又 树以 二 又 链 存储 ,设计 一 个 算法 判断 一棵二 又 树 2 是 否 为完全 二 又 树 。

实验题1: 实现 二 叉 树 的 各种 基本 运算 的 算法

目的: 领会二又 链 存储 结构和 掌握二又 树 中 的 各 种 基本 运算 算法 设计 。

内容: 编写一个程序btree. cpp, 实 现 二 又 树的基本 运算 ,并 在 此 基础上设计 一 个 程序

exp7-1.cpp 完成以下功能。

(1) 由 图 7. 33 所 示 的 二 又 树 创建对 应 的 二 又 链 存储 结构 5,该二 又 树 的 括号 表示 串 为

“A(CB(D,ECHG ,KGCL,MCN))))) ,CCF,GC,D))”。

(2) 输出二又树 0。

(3) 输出 史 '结 点 的 左 . 右 孩 子结点值。

(4) 输出二又树 0 的高度 。

(5) 释放二又树 0 。

实验题2: 实现 二 叉树的 各种 遍历 算法

设计。

内容: 编写一个程序 exp7-2. cpp, 实 现 二 又 树 的 先 序

遍历.中 序 遍历和 后 序 遍 历 的 递归和 非递归 算法 ,以 及 层次

遍历的算法,并对图 7. 33 所 示 的 二 又树0 给出求解结果。

图 7.33 一 棵 二 又 树

247

数据 结构教程

[第! 5版

实验题3: 由 遍历 序列 构造二叉树

目的: 领会二又 树的构造过程以 及 构造二又 树 的 算法 设计 。

内容: 编写一个程序exp7-3. cpp ,实现 由 先 序 序列 和 中 序 序 列 以及由 中 序 序列 和 后 序

序列 构造 一棵二 又 树 的功能 (二 又 树 中 的 每个结 点 值 为 单个字符 ) ,要 求以 括号 表示 和凹人

表示法输出 该 二 又 树 , 并 用 先 序 遍历序列“ABDEHJKLMNCFGI”和中 序 遍 历 序列

“DBJHLKMNEAFCGI” 以 及 由 中 序 遍 历 序 列“DBJHLKMNEAFCGI” 和后序 遍 历 序列

“DJLNMKHEBFIGCA?进行验证。

实验题4: 实现 中 序 线索 化 二 又 树

目的: 领会 线索二 又 树的构造过程以 及 构造线索 二 又 树 的 算法设计 。

内 容: 编写一个程序exp7-4. cpp, 实 现 二 又 树 的 中 序线索 化 ,采用 递归 和 非递归 两 种 方

式输出 中 序 线索 二 又 树 的 中 序 序列 ,并以图7. 33 所 示 的 二 叉 树 对 程序进行 验证 。

实验题5: 构造哈夫 曼 树 和 生成哈夫 曼 编码

目的: 领会哈夫 曼 树 的 构造 过 程以 及 哈 夫 曼编码 的 生成过程 。

内 容: 编写一个程序exp7-5. cpp, 构 造一棵 哈 夫 曼 树 ,输出对 应 的哈夫 曼 编码 和 平均 查

找 长 度,并 对 表 7. 8 所 示 的 数据 进行 验证 。

表 7.8 单词及出现的频度

单词 | The | of

| altoland|

in

|that | he

is

| atlon|l

for | His | are | be

出 现 频度| 1192 | 677

|541| 518|

462 | 450 | 242 | 195 | 190

|181|174|

157 | 138 | 124 | 123

民 设计 性 实验

实验题6: 求二叉 树 中 的 结点个 数.叶 子 结 点 个 数 、 某 结 点 层次和 二 叉 树 宽 度

目的: 掌握二 又 树 遍历 算法 的 应用,熟练 使用先 序.中 序 、 后 序 3 种递归 遍历 算法和 层

次 遍历 算法 进行 二 又 树问题的 求解。

内容: 编写一个程序exp7-6. cpp 实现以 下 功能 ,并 对 图 7. 33 所 示 的 二 又 树 进 行 验证 。

(1) 输出二又树 2的 结 点 个 数 。

(2) 输出二叉树六的叶子结点个数。

(3) 求二又 树 0 中 指定 结 点 值(假设所有 结 点 值 不同) 的 结 点 的 层次 。

(4) 利用 层次 遍历 求二又树 2 的 宽度 。

实验题7: 求 二 叉 树中从 根 结 点 到 叶子 结 点 的 路径

目的: 掌握二 又 树 遍历 算法 的 应 用 ,熟练 使用先 序.中 序 、 后序 3 种 递归和 非递归 遍历

算法以 及 层次 遍历 算法 进行 二又树问题的 求解。

2 内容: 编写一个程序 exp7-7. cpp 实现以 下 功能 ,并 对 图 7. 33 所 示 的 二 又 树 进行 验证 。

(1) 采用 先 序 遍历 方法 输出所有 从 叶子 结 点 到 根 结 点 的 逆 路 径 。

《2) 采用 先 序 遍历 方法 输出 第 一 条 最 长的逆 路 径 。

(3) 采用 后 序非递归 遍历 方法 输出所有 从 叶子 结 点 到 根 结 点 的道路 径 。

(4) 采用 层次 遍历 方法 输出所有 从 叶子 结 点 到 根 结 点 的 逆 路 径 。

实验题8: 简单 算术 表达 式 二 又 树 的 构建和 求值

目的: 掌握二 又 树 遍历 算法 的应用 ,熟练 使用先 序.中 序 、 后序 3 种递归 遍历 算法 进行

(zs

7放权和=村 |

二 又 树问题的求解。

内 容 : 编写一个程序exp7-8. cpp, 先 用 二 又 树来表示 一 个 简单算术 表达 式 , 树 的 每一个

结 点 包括 一 个 运算 符 或运算 数。在 简单算术 表达 式 中 只 包含 十 .一 .* /和 一 位 正 整数且 格

式 正确 (不 包含 括号) ,并 且 要 按照 先 乘除 后 加 减 的 原则 构造二 又 树 ,图 7. 34 所 示 为“1十 2x

3 一 4/5? 代 数 表 达 式对 应 的 二 又 树 ,然后由 对 应 的 二 又 树计 算 该 表达 式 的 值 。
从 综 合性实验

@@

实验题 9: 用 二 叉 树 表示 家 谱 关 系 并 实现 各 种 查找

功能

局

已

目的; 擎握二 又 树 遍 历 算法 的应用 ,熟练 使用先 序.中

CD 人 加 加

序\后序 3 种递归 遍历 算法 进行二又 树 问题 的 求解。 中

内 容:编写一个程序exp7-9. cpp, 采 用 一 棵 二 又 树 表 示

一 个 家 谱 关 系 ( 由 若干家谱 记 录 构 成,每个家谱记 录 由 父

亲 、 妻子和 儿子 的姓名 构成 ,其中姓名 是关键字) ,要求程序

图 7.34 二 叉树表示 简单 算术

表达式

具有以下功能。

(1) 文件 操作 功能 : 家 谱 记 录 的 输入,家 谱 记 录 的 输出 ,清除 全 部 文件记录 和 将 家 谱 记

录 存 盘。要 求 在输入 家 谱 记 录 时 按 从 祖先 到 子孙 的 顺序 输入,第 一 个 家 谱 记 录 的 父亲 域 为

所 有 人 的 祖先。

(2) 家 谱 操 作 功 能 : 用 括号 表示 法 输出 家 谱 二 叉 树 ,查找某人 的所有 儿子 ,查找某人 的

所 有 祖先 (这 里 的 祖先 是 指 所 设计 的 二 又 树 结构中 某 结 点 的所有 祖先 结 点 ) 。

实验题 10: 大 学 的 数据 统计

目的 : 掌握树 的 存储 结构 ,熟练 使用树 遍 历 算法 进行 问题 的求解 。

内 容 : 编写一个 程序 exp7-10. cpp 实现 大 学 的 数据 统计。某 大 学 的 组 织 结构如表 7.9

所 示 ,该数据 存放 在 文本 文件 abc. txt 中。要 求 采用 树 的孩子 链 存储 结构 存储 它 ,并 完成 以

下 功能 ,

单

位

中 华 大 学
中 华 大 学

计算 机 学 院

计算 机 学 院

计算 机 学 院

计算 机 科学

计算 机 科学

计算 机 科学
计 科 1 班
计 科 2 班
计 科 3 班
信息 安全
信息 安全
信安 1 班
信安 2 班

表 7.9

某 大 学的组织结构

下 级 单位(人 数 )

单

位

下 级 单位(人数)

物 联 网
物 联 班

电信 学 院

电信 学 院

电子 信息 类

电子 信息 类

电子 信息 类

电信 1 班
电信 2 班
电信 3 班
信息 工程
信息 工程
信息 1 班
信息 2 班

物 联 班
38

电子 信息 类

信息 工程

电信1 班

电信2 班

电信 3 班

40
38
42
信息1 班
信息2 班
38
35

计算 机 学 院
电信 学 院

计算 机 科学

信息 安全

物 联 网

计 科 1 班

计 科 2 班

计 科 3 班
32
35
33
信安 1 班
信安 2 班
36
38

249

Ra

数据 结构教程

[第! 5人版

(1) 从 abc. txt 文件 读数 据 到 尺 数组中。

(2) 由数组尺创建树: 的 孩子链 存储 结构 。

(3) 采用 括号 表示 输出 树 :。

(4) 求 计算 机 学 院 的专业 数 。

(5) 求 计算 机 学 院 的班数 。

(6) 求电信 学 院 的学生 数 。

(7) 销毁树 。

实验题11: 二 叉 树 的 序列化和 反 序 列 化

目的: 深入 掌握二 又 树的遍历和 构造 算法 。

内容: 编写一个程序exp7-11. cpp 实现 二 又 树 的 序列化和 反 序 列 化 。

这 里 介绍 通过 先 序 遍历 实现 二 又 树 的 序列化和 反 序列 化(也 可 以 采 月

日层次 遍历 实现 序

列化和 反 序 列 化) ,假设二 又 树 的 每 个 结 点 值 为 单个字符 (不 含'#', 这 里 用 '# 字符 表示 对 应

空结 点 )。所 谓 序列 化 就 是对二 又 树 进行 先序遍历 产生 一 个 字符 序列的过 程,与一般先序遍

历 不 同的是,这 里还要 记录 空 结 点 。

例如 ,对 于 如 图 7. 35 所 示 的 一 棵 二 又 树 ,一 般 的先序 遍 历 序列 是”ABDEGCFHI” ,而 这

上昭

的 先序序列 化 的 结果 是“ABD# # 正 #井G# 并 C#FH# 间 I# #” 相 当 于 在 二 又 树 中标记

上 所 有 的 空 结 点 ,如图 7. 36 所 示 ( 也 称 为 扩展 二 又 树 ) ,然后进行先序遍历 。

(oO) 人 (OOD

刘 [的区

图 7.35 一棵二又树

图 7.36

加 上 空 结 点 的 二 叉 树

所谓 反 序列 化 就 是通过 先 序 序列 化 的结果 串 str 构建对 应 的 二 又 树 ,其 过 程 是用 ;从头

到尾扫描 str, 采 用 先 序 方法,当 ; 超界时 返回 NULL; 否则当遇到 '# 字符时返回 NULL,

当 遇 到 其他 字符 时 创建一个 结 点 ,然后递归 构造它的 左 、 右 子 树 。可 以证

明 , 采 用 先 序 遍 历

实现 的 二 又 树 序列 化和反 序列化的 结果 是 唯一的。

pe

实现上述 过 程 ,完成 以下功能 ,
(1) 创建二又链0。

(2) 采用 括号 表示 输出 二 又 链 2。

(3) 对 二 叉 链 0 进行先序 遍历 ,产生 先 序 序列 化 序列 str。

(4) 输出 先 序 序列 化 序列 str。

(5) 由 str 构建二又链 21( 反序列化) 。

(6) 采用 括号 表示 输出 二 又 链 21 。

(7) 销毁二叉 链训和 21。

250

7As放本和村 |

对 于 串 的操作 可 以 使用第 4 章 设计 的 串 基本 运算 算法 。

实验题12: 判断二叉树 01 中 是否有 与 !2 相同的子树

目的: 深入 掌握二 又 树的遍历 算法 。

内容: 编写一个程序exp7-12. cpp 判断二又树 1 中是否有与02 相同 的子树 ,要 求 算法

尽 可 能 高 效 。

实验题13: 判断二又树 !1 中 是否有 与 22 树 形 结构相同 的子树

目的: 深入 掌握二 又 树的遍历 算法 。

内容: 编写一个程序exp7-13. cpp 判断二又树01 中是否有与02 树 形 结构相同 的子树 ,

要 求 算法尽可 能 高 效 。

251

图 形 结构 属于 复杂 的 非线性 数据结构, 在 实际应 用 中 很 多问题

可 以 用 图 来 描述。在 图 形 结构 中 , 每个元 素可以有 零 个或多 个 前 驱

元素, 也 可以有 零 个 或多个 后 继 元 素 , 也就 是说 元 素 之间 的 关系 是

多对多的。

本 章 介 绍 图 的 基本 概念 图的 存储 结构、 图的遍历和相关应用

算法的实现等内容。

DOOR

811 图 的 定义

无论多 么 复杂 的 图 都是由 顶点和 边 构 成 的 。采 用 形式 化 的 定义,图(graph)G 由 两个集

合 VCvertex)和 下 (edge)组成 ,记为G=(V,E), 其中冯 是 顶点 的 有 限 集合 ,记 为V(G) ,无 是

连接 V 中 两 个不同顶点 (顶点对)的 边 的有限 集合,记 为 EC(G) 。

可 以 用 字母 或 自然 数 来 标识图中 的 顶点 ,这里 约定用 ;0所;i生2一 1)表 示 第 ;个 顶点 的

编号,其中 ) 为图中 顶点 的 个 数。当 开(G)为 空集时 ,则图 G

只 有 顶点 ,没有边 。

在 图 G 中 ,如果 表 示 边 的 顶点 对(或序偶 ) 是有序 的 ,则称 G 为有向 图 (digraph)。 在 有

向 图 中 代表 边 的 顶点 对 用 尖 括 号 括 起来,用于 表示 一条有 向边, 如<i,j) > 表示 从 顶点 ;到顶

点地的 一 条 边 ,可 见 < ij > 和< 7 > 是 两 条 不 同 的 边 。

如 果 在图G 中 , 若<ij >EE(G)必有<思 i>EECG), 即忆C(G) 是 对 称 的 , 则 用 (, 力代 蔡

这 两 个顶点 对 ,表示 顶点 ;与 顶点 j) 的一条 无 向边, 则 称 G 为 无 向 图(undirgraph)。 显然在

无 向图中 人 力 和 人 ,六所 代表 的 是 同一条 边 。所 以,无向图 可 以 看 成 是有向 图 的 特例 。

图 8. 1(a) 所 示 为一个 无向图 Gi ,其 顶点 集合V(G:) =一10,1,2,3,4},边集合 已CG)一

{(1,2),(1,3),(1,0),(2,3),(3,0),(2.4),(3,4),(4,0))。

图 8. 1(b) 所 示 为 一 个有向 图 G: ,其 顶点 集合V(G: ) 一10,1,2,3,4},边集合 已(Gs) 一

发 1,2>,必 1,3>,必 0,1>,<2,3>,<0,3>,<<2.4>,必4,3>,攻4,0>)。

(a) 无 向 图 Gi

(b) 有向图O>

8.1 无 向图G 和 有 向 图 G*

图 的 抽象数据 类 型 定义如 下 :

ADT Graph
{ 数据对象:

D={ al 1<i生 mx>0,a 为 ElemType 类型

数据 关系 :

//ElemType 是 自定义类 型标识符

aa

R={(<w,o> |awsawED,1 扩is 其 中 每 个 元 素 可 以有零 个 或多个 前 驱 元 素 ,

可以有 零 个或多 个 后 继 元 素 }

基本 运算 :

CreateGraph(&g): 创建图,由 相关 数据 构造 一个图 g.
DestroyGraph(&sg): 销毁图,释放图 g 占用的存储空间.
DispGraph(g): 输出 图 ,显示图 g 的顶点和边信息.

253

数据 结构教程

(第5 【版

DFSCg,v): 从 顶点 出 发 深度优先 遍历图5 .

BFSCg,z): 从 顶点 出 发 广度优先 遍历图g.

812 图 的 基本 术语

有 关 国 鸭 各 种 芋 不 人请下 如 下 。

在 一 个 无 向图中 , 若 存在 一 条 边 (i, 力 , 则 称 顶点;和 顶点 7 为 该边的两 本

个 端点(endpoint) ,并 称 它们 互 为邻接 点(adjacent) , 即 顶点 守 是 顶点 7 的 一 个 邻接 点 ,顶点

也 是 顶点 守 的 一 个邻接 点 , 边 G7 力 和 顶点 让 7) 关联。关 联 于 相同 两 个 端点 的两条 或 者两条

以 上 的 边 称 为 多 重 边 ,在 数据结构 中讨论 的 图 都 是指 没有多 重 边 的 图 。

在 一个有 向 图 中 , 若 存在 一条有 向 边< ij) >( 也 称 为 弧), 则 称 此 边是顶点 ;的一条出

边,同 时 也 是 顶点 7 的一条 入 边 ,; 为 此 边 的 起 始 端点 (简称 为 起 点 ),7 为 此 边 的 终止端点

(简称 终点) ,顶点7 是顶点; 的 出 边邻接点 ,顶点守是 顶点 7 的入边邻接点。

2 顶吉 的 度 大 度 和 中度

在 无向图 中 ,一 个 顶点 所 关联 的 边 的数目 称 为 该 项点的 度(degree)。

在 有 向 图 中 ,顶点的

度 又 分 为 入度和 出度,以 顶点 7 为 终点的边数目, 称 为 该 顶点的入 度 (indegree)。 以 顶点 ;为起

点的边数目 ,称为该 顶点 的 出 度(outdegree)。一 个 顶点的人 度与 出 度的和 为该项 点 的 度 。

若 一 个 图中有 交 个 顶点 和 e 条边,每个顶点 的 度为di (0 和 i 过 2 一1) ,则 有 :

e 一 加 4
一工 》\U,

也 就 是 说 ,一个图中所有 顶点 的 度之和 等于边 数 的 两 倍 。因 为图中 的 每 条 边 分 别 作为两个

邻接点的度各计一次。

车 无 向图中 的 每 两 个 顶点 之 间都 存在 着一条 边,有 向图中 的 每 两个顶点 之间都存在

着方向 相反 的 两条边 , 则 称 此 图 为完全 图Ccompleted graph) 。显然,无 向完全 图 包含有

ax一D/2 条边,有 向完全 国 包 含有一D)条边。例如 ,图 8. 2(a) 所 示 的 图 是 一 个具有 4

个顶点 的 无 向完全 图 ,共有 6 条边。图 8. 2(b)所示的图是 一 个具有 4 个顶点的有向完全

oo
站 7

(a) 无向完全图

(b) 有 向 完全图

图 8.2 两 个具有 4 个顶点的完全图

254

ESAS国 |

天 客人全 和 种 咏 全

当 一 个 图 接近 完全 图 时 , 称 为稠密 图Cdense graph)。 相 反 , 当 一 个 图 含有较 少 的 边 数

(如 e<zlog:z)

时,则称为稀朴图(sparse graph) 。

于 了网

设有两个图G=(V,E)和 G 一 (人 ,E),若了 是 六的子集, 即 V V,且已 是已 的子集 ,

即 开' 瓦 , 则称G' 是 G 的 子 图(subgraph)。

说明: 图 G 的 子 图 一 定 是 个图,所 以 并 非 V 的 任何 子集V 和下 的 任何子集下"都能构

成G 的 子图,因为 这样 的(W' ,已 ') 并 不 一 定 构成一个 图 。

下

在 一 个图G=(V,E)中,从顶点守 到 顶点7) 的 一 条 路 径(path) 是 一 个 顶点 序列(Gin ,

ij。 若 此 图 G 是 无 向图, 则 边CG) Gilyi) Cn 属于 EC(G); 若

此 图 是有向 图 , 则 < im >,<i > ii>,区和,J> 属于 天 (G)。 路 径 长 度C(path

length) 是 指一条 路径上经 过 的 边 的 数目。若 一 条 路径上 除开 始点和 结束 点 可以 相同以 外 ,

其 余 顶 点 均 不相同 , 则 称 此 路 径 为 简单路径 (simple path) 。例 如 ,在图8. 2(b)中(0,2,1)就

是 一 条 简单 路 径 , 其长度为2。

7 加 喀或环

若一条 路径上 的 开始 点 与结束 点 为同一 个 顶点 , 则 此 路 径 被 称 为回路或环(cycle) 。 开

始点 与结束 点相同 的 简单路径 被称为 简单 回路 或 简单 环(simple cycle) 。例如,在图 8. 2Cb)

中 (0,2,1,0)

就是一条简单回路,其长度为3。

放生 放 何 和 连 放 他 重

扫一扫

的 各 机

在 无 向图G 中 , 若 从顶点守到 顶点) 有 路径, 则 称 顶 点 和 顶点 7 是连

通的。若图G 中 的 任意 两个顶点 都 是 连通 的 , 则 称 G 为连通 图(connected

graph) ,和 否则 称 为 非连通 图。无向图 G 中 的极大 连通 子图称为G 的 连通 分 襄 用

量(connected component) 。 显 然,连通 图 的 连通 分 量只有 一 个 ( 即 本 身 ) ,而 非 连通图有多

个 连通 分 量 。

9

秆 j表 全 利和于 证 j首放 合

在有向图 G 中 , 若 从顶点站到 顶点) 有 路径, 则 称 从 顶点 守 到 顶点 7) 是连通的。若图CG

中 的任意两个 顶点 和7都 连通, 即 从顶点 守 到 顶点) 和 从 顶点 7 到 顶点 i 都 存在 路 径 , 则 称 图

G 是 强 连 通 图 (strongly connected graph) 。有 向 图 G 中 的极大 强 连 通 子图称为G 的 强 连 通

分 量 (strongly connected component) 。 显然, 强 连通 图只有 一 个 强 连通 分 量 ( 即 本 身 ) ,非 强
连通图有 多 个 强 连通分量 。

aa

在 一 个非 强 连通 图 中 找 强 连通 分 量 的 方法如 下 :

(1) 在图中找有 向 环 。

《2) 扩展该有向环: 如 果 某 个 顶点 到 该环中 的任 一 顶点有 路 径 ,并 且 该环中 的任 一 顶

点 到 这 个 顶点也有 路 径 , 则 加 入 这 个 顶点。

例如 ,图 8. 3(a) 所 示 的 是 一 个非 强 连 通图,其 中 顶点 0`1、2 构成 一 个有向 环 , 然后考察 顶

点 3, 可以 将 它加 入 ,而

顶点4和 5不能加入。最 后得到 3 个 强 连 通 分量, 如 图 8. 3(b)所示。

六 55

数据 结构教程

[第! 5版

(a) 一 个非强连 通 图

(人b) 3 个 强 连 通 分 量

图 8.3 一 个非 强连通图的 3 个 强连通分量

人 权利网

图 中 的 每一条 边 都 可以 附有一 个 对 应 的 数值,这 种 与 边相关 的 数值 称 为 权。权 可以 表

示 从 一 个 顶点 到 另一个 顶点 的 距离 或花费 的代价 。边 上 带有权 的 图 称 为带权 图 (weighted

graph) ,也称作 网Cnet) 。例如,图 8.4 是 一 个 带权有 向 图 Gs 。

【例8. 1〗

2”(z*2) 个 顶点 的 强 连通 图 至 少有多 少 条边? 这 样 的有向 图 是什么 形状 ?

根据 强 连 通 图 的 定义 可 知 , 图 中 的任意 两 个 顶点; 和 )7 都 连通 ,即 从 顶点 站 到 顶点 7

和 从 顶点 7 到 顶点 ;i 都存在路径。这 样 ,每个顶点 的 度 尺 二2,设图中总 的 边 数 为 ,有:

“二 号 4 > 二 呈 2=,

即 e 三 2。 因 此 渡 个 顶点 的 强 连通 图 至 少有 ”条边。

而只有交 条 边 的 强 连通 图 是环形 的 ,即 从顶点 0 到 1 有 一 条 有 向 边,从 顶点 1 到 2 有 一

条 有 向 边 ,..., 从 顶点 2 一1到 0 有 一条有 向 边 ,如 图 8.5 所示。

图 8.4 一 个 带权有 向 图 Gs

图 8.5 具有?7个顶点 条 边 的 强 连 通 图

的 存储结构 和 基本 运算 算法 语

图 的 存储 结构除了 要 存储图中 各 个 顶点 本 身 的信息以外,同时

还 要 存储 顶点与顶点 之

间 的所有 关系 ( 边 的 信息 )。常用 的 图 的 存储 结构有邻接 矩阵和 邻接表 。 本 节 主 要讨论图的

两种存储 结构和 基本 运算 算法 的 设计 。

821 邻接 矩阵存储 方法

图 的邻接 矩阵(adjacency matrix) 是 一 种 采用 邻接矩阵 数组表示 项 点 之 间 相邻关 系 的

存储 结构。设 G=(V,E)是含有7(Cz 盖 0) 个 顶点 的图,各顶点的编号 为 0 一(2一1D) , 则 G 的

256

邻接矩阵 数组4 是 阶 方阵, 其 定义如 下 :

(1) 如果 G 是 不 带权 无向图 ,则 :

4[训[7门王

1

, 著 Gj) EECG)

0 其他

(2) 如 果 G 是 不 带权 有 向图, 则 ,

4[训[7门 一

1 若<ij>E ECG)

0 其他

(3) 如 果 G 是 带权 无 向图, 则 :

视频讲解

zi 若z天7) 上且(Gi7E ECG),该边的权为zwy

4[让[Li门=

0 =

cs 其他

(4) 如 果 G 是 带 权 有 向 图 , 则 :

区 若; 天) 上且 <iJ > EEC(G) ,该 边 的权为ruy

4[i[门= 0

zi一
co 其他

例如 ,图 8. 1(a)所示的无向图C; 对 应邻接矩阵 数组 4 ,图 8. 1(b)所示的有向图G 对

应 邻接矩阵 数组 4 ,图 8.4 中 的 带权 有 向 图 Gs 对 应邻接矩阵 数组 4 ,这 3 个邻接 和矩阵数组

如图8.6所示。

01011

01010

10110

00110

0

om

8 m35 om

0

3 mm

4=|01011

4=|00011 43=|mm0 om 6

11101

00000

oo

om

9

0

om

10110

10010

oomoo 0

图 8.6

3 个邻接矩阵 数组

图 的 完整邻接矩阵 类 型 的 声明如 下 :

# define MAXV < 最 大顶点个数>
井 define INF 32767

// 定 义 co

typedef struct

{

int noi

JInfoType info;

) VertexType;

typedef struct

// 顶 点 的 编号

//顶点的 其他 信息

// 顶 点 的 类 型

{

int edgesLMAXV]LMAXV] ;

int nei

VertexType vexs[MAXV] ;

// 邻 接 矩 阵数组

// 顶 点数, 边 数

// 存 放 顶 点

信息

} MatGraph;

// 完 整 的 图邻接 矩阵 类 型

邻接矩阵的特点如下 :

(1) 图 的邻接 矩阵 表示 是 唯一的 。

(2) 对 于 含有宛 个 顶点 的 图 , 当 采 用 邻接 矩阵存储时 ,无论是有 向 图还是 无向图 ,也 无

257

数据 结构教程

[第! 5人版

论 边 的 数目是多 少 ,其 存储 空间 都 为 0(22),所以邻接 矩阵 适合 于 存储 边的数目 较 多 的 笛

密图。

(3) 无 向 图 的邻接 矩阵 数组一定是 一个对 称 和 矩阵,因此 可以采用 压缩 存储 的 思想 ,在 存

放 邻 接 和 矩阵 数组时只需 存放上 (或下) 三 角部 分的元 素即可 。

(4) 对 于 无 向 图 ,邻接矩阵 数组 的 第 ; 行 或第; 列非 零元 素 、.非 "= 元素 的 个 数 正好 是 项

点守的度。

(5) 对于有向 图 ,邻接 算 阵 数组 的 第 守 行 (或第; 列 ) 非 零元 素 、.非 元素 的 个 数 正好 是

顶点守 的 出 度 ( 或人度 ) 。

(6) 在邻接 矩阵 中 ,判断图中两个顶点之间 是 否 有 边 或 者 求 两个顶点 之 间边 的权 的 执

行时间为O(1) 。所以 在需要 提取边权 值的 算法 中通常采 月

i

阵

822 邻接表存储方法

图 的邻接 表 (adjacency list)是一种顺序与 链 式 存储相结合 的 存储 方法 。

于 含有 ?7 个 顶点 的 图 ,每个顶点 建立 一 个单链表 ,第 ;0 和 ;和受2 一 1) 个 单链表 中 的结

点 表示关联于顶点:的

边 (对 有向 图 是以 顶点 ;为

起 点 的边) ,也 就是将 顶点 守 的 所 有邻接点

(对有向图是出 边邻接 点 ) 链 接 起 来 ,其 中 每 个

结点 表示一条 边 的 信息。

每 个 单 链 表 再 附设 一 个头 结点 ,并 将 所 有头 结点构成一个头 结点 数组 adjlist,adjlist[实

结4

表示 顶点 ;的 单链表 的头结 点 ,这 样就可 以通过 顶点 ;快速地找到对应的单

扫--扫

链表 。

在 邻接表中有两 种类 型的结点 ,一种是 头结点 ,其个数恰好为图中 项点

的 个 数 ; 另 一 种 是 边结 点 ,也就 是 单 链表 中 的结点。对 于 无向图,这 类 结点

的 个 数 等于边 数 的 两 倍;对于 有向 图 ,这类 结 点 的个数 等于 边 数 。

视员if册

边结点和 头结 点 的结构 如 下 :

边 结 点

头 结 点

adjvex | nextarc | weight

data

firstarc

其中 ,边结点 由 3个域组成 ,adjvex 表示 与 顶点 ;邻接

的 顶点 编号,nextarc 指向下一个

边 结点 ,weight 存储 与该 边相关 的 信息 ,如权值等 。头结 点由两 个 域 组 成,data 存储 顶点

的 名 称 或其他 信息 ,firstarc 指向 顶点 守的单链表中的首结点。

例如 ,图 8.1(a)

所示的无向图G 对 应 的邻接 表 如 图 8.7(a)所示,图8. 1(b)所示的 有向图

G 对 应 的邻接 表 如 图 8.7(Cb)所示,图 8.4 中 的 带权 有向图Gs 对 应 的 邻接表如图8.7(Cc)所示。

一 般情 况下 ,对 于 不 带 有 权 的 图,邻接表中的边结点没有画出weight 域。

PE

图 的 完整邻接 表 存 储 类 型 的声明 如 下 :

typedef struct ANode

{

int adjvex;

// 该 边 的邻接 点编号

Struct ANode #* nextarc;

// 指 向 下 一 条 边 的 指针

int weight;

} ArcNode;

typedef struct Vnode

// 该 边 的相关 信息 ,如 权 值(这 里 用 整 型表示 )
// 边 结 点的类 型

258

PASS国 |

{

InfoType info;

//顶点的 其 他 信息

ArcNode * firstarc;

) VNode;

typedef struct

// 指 向 第 一 个 边 结 点
// 邻 接 表 的 头结点 类 型

{

。 VNode adjlist[UMAXV];

// 邻接表 的头结 点 数组

int n,e;

} AdjGraph;

// 图 中 的 顶点数 n 和 边 数 e

// 完 整的图 邻接 表 类 型

data
从

firstarc

adjvex nextarc

AAA

上

0| 页

一|

1]

一| 3

和| 4

1 责

一| 0

一| 2

一| 3

2|

一| 1

一| 3

一| 4

3| 上

一| 0

| 1

| 2

症| 4 | 八

4| 王

| 0

一| 2

| 3 | 八

0|责

=| 1

=| 3 |从 0 二1 |8| 十下 3|15|^

(a) 图 CI的 邻接 表

adjvex weight nextarc

旭

1| 疝

一 2

呈 3|

人入

1 |天 | 村 -23 从

2| 雹

一| 3

| 4 |从

2 |克| 村 -4|5|

3引|六|和

3

||

村-2|9

人 入

4| 商

一| 0 呈3 |从

4| 台 |和

(b) 图 Gz的 邻接表

(c) 图 G;的 邻接表

图 8.7

3 个 邻接 表

由 于在有 向 图 的 邻接表 中 只 存放 了 以 一 个 顶点 为 起 点 的 边,所 以 不 易 找 到 指向 该 顶点

的 边 ,为此可以 设计 有 向 图 的 逆 邻接表 。 所谓 逆 邻接表 (inverse adjacency list) ,就 是 在有向 图

的邻接 表 中 对 每个顶点 链接 的 是 指向 该顶点 的 边 。例如有向图 G

中 有 边< 1,3 >,< 2,3 >,

<4,3>, 则以 下标 3 为 头 结 点 的 单链表 包含1.2 和 4 的 结 点 。

例如 ,图 8. 1(b)所示的有向图Gx 和 图 8.4 中 的 带权 有 向 图 Cs 对 应 的 逆邻接 表 分 别 如

和(b)所示。
图 8.8(a)

0| 而 | 一 汪 4| 人

1 天 | 二 二 o |入

2|豆 | 二|= 1 |入

0| 而 |六

1|| 村 下 olg|人和

aa

2|挛

| 1|3 -= 3|9人从

3五| = 二 0| -1 -2 -4 人

3|右| 村 志 o|5人和

4|丙| 二=|2 [入

4|玉| 村 二 2|16|^

(a) 图 G>的 逆 邻接表

(b) 图 G; 的 逆邻接 表

图 8.8 两个着 邻 接 表

259

数据 结构教程

[第1 5 【版

邻接表的特点如下 :

(1) 邻接 表 的 表示 不 唯一,这 是 因为 在 每 个 顶点对 应 的 单链表 中 各 边 结 点 的链接次序

可以 是 任意 的 ,取决于 建立 邻接表 的 算法以 及 边 的 输入次 序 。

(2) 对于有盖 个 顶点和 e 条 边 的无向图,其 邻接表 且 个头 结点 和 2e个边结点; 对于

有 并 个 顶点和 e 条 边 的有向 图 ,其 邻接表 有 交 个 头 结点和 e 个边结点。显 然 ,对 于 边 数目 较

少 的 稀疏 图 ,邻接 表 比邻接矩阵 更 节省 存储 空间 。

(3) 对 于 无向图 , 邻接表 中 顶点 守对应的第;个 单链表 的 边 结 点 数目 正好是 顶点 :

的度。

(4) 对于有 向 图 ,邻接 表 中

顶点站对应的第; 个 单链表 的 边 结 点 数目仅仅 是 顶点 ;的出

度。顶 点 之 的人度 为 邻接表 中 所 有 adjvex 域 值 为站的 边 结 点 数目 。

(5) 在 邻接 表 中 ,查找 顶点 守 关 联 的所有 边 是非常 快速 的,所 以 在 需要 提取 某 个 顶点 的

所 有 邻接 点 的 算法 中 通常 采用 邻接 表 存 储 结 构 。

要-要

823 图 基本 运算 算法设计

这 里 介绍 创建图.输出图和 销毁 图 的 基本 运算 算法 设计。对 于 邻接矩

阵 实现相关 算法是十 分 容易 的,下 面讨论邻接 表 的 相关 算法 设计 。

全 全 奸 鲍 的运算 算半

根据邻接 矩阵数组 4、 顶 点 个数 上 和 边 数 e 来 建立图的 邻接表 G( 采 用 邻接 表 指 针 方

式)。首 先 为 邻接表 分 配 G 的 存储 空间 ,并 将 所 有 头 结 点 的 firstarc 指针 设置 为 空 。扫 描 数

组 A 查 找 不为 0\ 不为ce的 元 素 , 若 找到 这 样 的 元素 AL 让 [让 , 创 建 一个 adjvex 域为六

weight 域为 AL 可 [7门 的边结 点 ,采用 头 插 法 将 它插入 到 第 ;个单链表中。算法如下 :

void CreateAdj(AdjGraph * &G,int ALMAXV][IMAXV] ,int n,int e)

“ // 创建图 的 邻接 表

{

intij;ArcNode xpi;

G=(AdjGraph * )malloc(sizeof(AdjGraph)) ;

for (i=0;i<n;i十十)

// 给邻接 表 中所有 头 结 点 的 指针 域 置 初值

G->adjlist中 .firstarc王NULL;

for (i=0;i<nii十十)

// 检 查 邻 接 和 矩阵中 的 每个元 素

for (j王n 一 1;j> 王 0;j 一一)

让 CA 加 四 !=0&& AD 口中 :=INF)

// 存 在 一 条 边

{

, p=(ArcNode * )malloc(sizeof(ArcNode)) ;

// 创 建 一个结点 p

p -> adjvex一j;

p -> weight一A上 口中 ;

// 存 放 邻 接点

// 存 放权

pD 一 nextarc一G -> adjlist[ 站 .firstarc;

// 采 用 头 揪 法 插入 结 点 p

peee

G 一 adjlist 吕 .firstarc一p;

}

G一n 一 ni G一>e 一 ei

)}

2的运算算半

扫描邻接 表 G 的头结 点 数组 adjlist, 对 于 每 个 单链表 , 先 输出头结 点 的 顶点 信息 (这 里

输出 顶点 编号) ,然后逐一 输出 单链表 中 的所有 结 点 的 顶点 编号。算法如下 :

260

PASS国 |

void DispAdj(AdjGraph * G)

// 输 出邻接表 G

{

intisArcNode *p;

for (i王0;i<G 一> njii 十十)

{

, p=G 一 adjlist[品 .firstarc;

printf("%3d: ",iD;

while (p!=NULL)

printf("%3d[ 上四一 ",p 一 adjvex,p 一> weight) ;

p王p 一>nextarc;

{

】}

printf(" 人 \n") ;

】}

了 销 有 网 的 运算 算 关

对 于邻接表 G, 扫 描 其 头 结 点 数组 adjlist 指向的所有的 单 链表 ,逐个 释放 单链表 中 的 边

结 点 ,最后释放 头 结 点 数组 。算法如下 :

void DestroyAdj(AdjGraph * &G)

// 销 毁 邻接表

{

int i;ArcNode * pre, xx pi;

一> nii十十)
for (i=0;i<G

// 扫 描 5所 有 的 单链表

{

, pre一G 一 adjlist跨 .firstarc;

//p 指向第 i 个单链表 的 头 结 点

i (pre!王NULL)

{

,p王pre 一> nextarc;

while (p!王NULL)

freeCpre) ;

pre一p; p 王 p 一>nextarc;

{

】}

free(pre) ;

】》

}
free(CG) ;

}

// 释 放 第 i 个 单链表 的所有 边 结点

// 释 放 头 结 点 数组

说明: 将 图 的 两 种存储 结构 的声明代码 存放 在 graph. h 头 文件中,将 图 的 基本 运算 算

法代码 存放 在 graph. cpp 文件 中 。

【例8. 2〗

对 于具有 ) 个 顶点 的 图 CG :

(1) 设计 一 个 将邻接矩阵 转换 为邻接 表 的 算法 ,

(2) 设计 一 个 将邻接 表 转 换 为邻接 矩阵 的 算法 ;

(3) 分析上 述 两个算法 的时间 复 杂 度 。

(1) 在 图 G 的邻接 矩阵g 中查找值不为 0\ 不为cc的 元 素 , 若 找到 这

样的元 素 , 例 如 g. edges[ 让 [7门,表示 存在一条 边 ,创建 一个adjvex 域为7 的

边结 点,采用 头 搬 法 将 它 插 和人到 第 ;个单链表中。算法如下 :

void MatToList(MatGraph g,AdjGraph * &G)

// 将邻接失阵g 转换成邻接表 G

{

intij;

261

数据 结构教程

[第! 5版

ArcNode * pi;
G=(AdjGraph * )malloc(sizeof(AdjGraph)) ;

for (ii一0;i<g.nii十十)

// 将邻接 表 中所有 头 结 点 的 指针 域 置初值

G->adjlist[吕 .firstarc一NULL;

for (i一0;i<g.nii十十)

for (j一g.n 一1;j> 王 0;j 一一)

// 检 查邻接 和 矩阵中 的 每个元 素

让 (g.edges上 口中 ! 一0&& g.edges[中中 ! 王INF)

// 存 在 一 条 边

{

, p一(ArcNode * )malloc(sizeof(ArcNode) ) ;

//创 建 一 个 边 结 点 p

p -> adjvex一 j; p 一 weight一 g.edges[口D ;
p 一 > nextarc一G 一> adjlist[申.firstarc;

G 一 adilist加 .firstare一pb;

// 采 用 头 插 法 插 和人结 点 p

》

G->n=g.niG->e=g.ei

)}

(2) 初始时将邻接矩阵 g 中 所 有 边 对 应 的元 素值设 置为0, 扫描 邻接 表 G 的所有 单链

表 ,通 过 第 ; 个 单 链表 查找 项 点; 的 相 邻结 点 户,将邻接矩阵 g 的元 素 g. edges[i让[加一>

adjvex]

修改为该边的权 刀 一> weight。 算法如下 :

void ListToMat(AdjGraph * G,MatGraph &g)

//将邻接表 G转换成邻接矩阵 g

{人 inti3

ArcNode * pi;
nj;i十十)
for (i=0ji<G->

品.firstarc;
{ , p=G一adjlist

while (p!=NULL)

g.edges 目 [p -> adjvex] 王 p 一 weight;

D一D 一 nextarc;

{

】}

}

g.n一G一nig.e一G一 el;

)}

// 扫 描所有 的 单 链表

//p 指向第 i 个 单 链表 的头结点

// 扫 描 第 i个单链表

(3) 算法(1)中有两重 for 循环 ,其 时间 复 杂 度为0(袜)。算 法(2) 中 虽然 有 两 重循环 ,

但 只 对 邻接 表 的所有 头 结点和 边结 点 访问 一 次 ,对 于 无向 图 ,访问 次 数为2 十2e, 对于 有向

图 ,访问次数为 2 十e, 所以 算法(2) 的 时间 复 杂 度为OCz十e) ,其中 e 为图的 边 数 。

824 其 他 存储 方法

EEEE

十 字 链 表 (orthogonal list) 是 有向 图 的 另外 一 种 存储结构 , 它 是 邻接表
和 道邻接 表 的结合 。下 面以图 8. 9(a) 所示 的 有向 图 来 说 明 十 字 链 表 的创

。。 训 下

(1) 图 中 的 每个顶点 对 应 一 个 头 结 点,结构 为(data,firstin,firstout),其中 data 表示该

顶点 的信息 ;, firstin 表示入边信息; firstout 表示出边信息。这 里 有 4 个 顶点 ,构造 4 个头

结点,编号为 0 一3 ,与 顶点 编号相对 应,如 图 8. 9(b)所示 。

(2) 图 中 的每条 边 对 应 一 个 边结 点 ,结构 为(tailvex,headvex,hlink,tlink,weight),其

中 tailvex 和 headvex 分 别 表示 该边的 起 点和 终点; hlink 指向

相同 起 点的下 一 个 边 结 点

262

data 。 firstin

firstout

起点 终点 tink

hlink

0|ml|,

十 -人 0|1

[1

人

1 mA

Cr一问 3 |

十 BLoTALGTIALST2TAIA

(a) 一个有向图

(b) 一 个十字 链 表

图 8.9 一 个有向 图 的十字 链 表

tlink 指向 相同 终点的下 一 个边结 点; weight 表示 该边的 信息 ,例如 权 ( 这 里 没有画 出 来 ) 。

该图有 7 条 边 ,构造 7 个 边 结 点 ,首先标出起点和 终点 。

(3) 构造横向 链接: 对 于 顶点 0,以 它为起 点 的 边有 (0,1) 和 (0,2), 让 头 结 点 0 的

firstout 指向(0,1) 边 结 点 ,让 (0,1) 边结 点的hlink 指向 (0,2) 边 结 点,(0,2) 边 结 点的 hlink

置 为 空

。 对 于 其他 顶点 ,采用 类 似 方法构建,与邻接 表 的 构造 过 程类似 , 如 图 8. 9(b)中的实

(4) 构造纵向 链接 : 对 于 顶点 0, 以 它 为 终点 的 边有(2,0) 和 (3,0) ,让 头结点0 的 firstin

指向(2,0) 边 结 点,让 (2,0) 边 结 点 的 tink 指向(3,0) 边 结 点 ,(3,0) 边 结 点的 tink 置 为 空 。对

于 其 他 顶点 ,采用 类 似 方法 构建,与 道邻接 表 的 构造 过 程 类似, 如 图 8. 9(b) 中 的 虚线 箭头 。

在 图 的 十 字 链 表 表 示 中 , 既 容易 找到 以 顶点 v 为 起 点 的所有 边 ( 方 便 求 其 出度) ,也 容易

找到以顶点 " 为 终点 的所有 边 (方便 求 其人度 ) 。

2 汕接 多 重 表

邻接 多 重 表 (adjacency multirlist)是无向图 的 另外 一种存储 结构 ,与十字 链 表 类似。下

面 以图 8. 10(a)所示的无向图 来说明邻接 多 重 表 的 创建过 程 。

data

firstare

,

ilink

六
IF |

jlink

0| 列 一 一

0

1

,

0|1A作 31 人

|

本 | 到- 人

|

2 必丈

-一一|

2

1|

,

2

3

2| 人 4| 八

3| 下 本一-一人一一

4| 下 一|一

4

1 |八

(a) 一 个 无向图

(b)

一 个邻接多重表

图 8. 10 ”一个有 无图的邻接 多 重 表

(1) 图 中 的 每 个 顶点 对 应 一 个 头结 点 ,结构 为(data,firstarc), 其中 data表示该顶点的信

息; firstarc 指向 第 一 条 依附 该 顶点 的 边。这 里 有 5 个 顶点 ,构造 5 个 头结 点 ,编号为 0一人,与

263

数据 结构教程

[第! 5人版

顶点 编号 相对 应 。

(2) 图 中 的 每条边 对 应 一 个 边 结 点 ,结构 为(mark,i'ilink,j,jlink,weight),其中mark

为标志 域,可 用 来标记 该 边是否 被 搜索过 (这 里 均 为 空); ;7 表示 该边的 两 个 顶点; ilink指

向 下 一 条 依附 于 顶点 ;的边结点; jlink 指向下 一 条 依附 于 顶点 7) 的 边结点; weight 表示该

边 的 信息 ,例如权 ( 这里 没有画 出 来 )。 该图有 6 条边 ,构造 6 个 边 结 点 ,首先标 出 依附 的 顶点 ,

如图 8. 10(b)所示。注 意 ,由 于 是 无 向图 , 边< ij) > 和< 习 > 只 构造一个 边 结 点 。

(3) 构造 链接 : 对 于 顶点 0, 依 附 的有边 (0,1)和 (0,3) ,让 头 结 点 0 的 firstarc 指向(0,1) 边

结 点 ,让 (0,1)边结点的 ilink 指向(0,3) 边 结 点,(0,3) 边 结 点 的 ilink 置 为空,在图 8. 10(b)中用

指向(0,1)边结
对 于 顶点 1 ,依附 的有边 (0,1)、 (2,1) 和 (4,1) ,让 头 结点 1 的 firstarc

点 ,让 (0,1) 边 结 点 的 jlink 指向(2,1) 边 结 点 ,(2,1) 边 结 点 的 jlink 指向 (4,1) 边 结 点,(4,1)

边 结 点 的 jlink 置 为空,在图8. 10(b) 中 用 实 线 箭 头 表示 。

对 于 顶点 2, 依 附 的有边 (2,1)、(2,3)

指向(2,1)边结
和(2,4) ,让头结点 2 的 firstarc

点 ,让 (2,1)边结点的 ilink 指向(2,3) 边 结 点 ,(2,3) 边 结 点 的 ilink 指向 (2,4) 边 结 点 ,(2,4)

边 结 点 的 ilink 置 为空 。

对 于 顶点 3, 依 附 的有边(2,3) 和 (0,3),让 头 结 点 3 的 firstarc 指向(2,3)边结点,让

(2,3) 边 结 点 的 jlink 指向(0,3) 边 结 点 ,(0,3) 边 结 点 的 jlink 置 为空。

对 于 顶点 4, 依 附 的有边(4,1) 和 (2,4),让 头 结 点 4 的 firstarc 指向(4,1)边结点,让

(4,1)边结点的 ilink 指向 (2,4) 边 结 点,(2,4) 边 结 点 的 jlink 置 为空。

在邻接 多 重 表 中 所 有 依附 于 同一 顶点 的 边串联 在 同一 个 链表 中 。 与 邻接表 相 比 , 邻 接

表 中 的 同一 条 边 对 应 两 个 边结点 ,而邻接 多 重 表 中 只 有 一 个 边 结 点 ,它们 的 各 种 基本 操作 是

相似的。

831 图 的遍历的概念

从 给 定图中任意 指定 的 顶点 ( 称 为初始点) 出 发,按照某种搜索 方法沿着 |

图 的 边 访问 图 中 的所有 顶点 ,使 每个顶点 仅 被访问 一 次 ,这 个 过 程 称 为图的 遍

历 。如 果 给 定 图 是 连通 的 无向图 或 者是强 连 通 的有向 图 , 则遍历过程一次就

能 完成,并 可 按访问 的 先后顺序 得 到 由 该 图 的所有 顶点组 成 的一个 序列 。

pe

图 的 遍历 比 树 的 遍历 更复杂 ,因为从树 根 到 达 树 中 的任意 结 点只有 一 条 路 径 ,而 从 图 的

初始 点 到 达 图 中 的 每个顶点 可 能 存在 着 多 条 路 径 。当 沿 着 图 中 的一条 路 径 访问 过 某 一 顶点

之后,可 能还沿 着 另一条 路 径 回 到 该顶点 ,即存在 回路。为 了 避免 同一 个 顶点 被重复 访问 ,

大 家 必须记 住 每 个 被访问 过 的 顶点。为 此 ,可 设置一个访问标记 数组 visited, 当 顶点 ;被访

问 过 时 ,数组中的 元 素 visited[置为 1, 和 否则 置为0。

根据 搜索 方法的 不同, 图的遍历 方法有两种: 一 种叫 深 度 优先 遍历(Depth First

Search,DFS) , 另 一 种 叫 广度 优先 遍历(Breadth First Search,BFS)。

264

DOOR

832 深度 优先 遍历

深度 优先 遍历 的 过 程 是从图 中 的 某 个 初始点, 出 发,首先访问初始点 w,,然 后选择一个

与 顶点才相邻且 没 被 访问 过 的 顶点 邮 , 以 zw 为 初始 顶点 ,再 从 它 出 发 进行 深度 优先 遍历 , 直

到 图 中 与 顶点 v 邻接 的所有 顶点 都 被 访问 过 为 止 ,显然这 个 遍历 过 程是一 个递归 过 程 。

例如 ,对 于 图 8.4 所示 的 有向 图 ,从 顶点 0 开始 进行 深度 优先 遍历,可 以 得 到以 下 访问

序列 :01243,03241。

以邻接 表 为存储 结构 的 深度优先 遍历 算法如 下 (其 中中是 初始 点 ,visited 是 一个全 局 数

组,初始时所有元素均为 0, 表示 所 有 顶点 尚未 被访问 过 ) :

int visitedLMAJ] 一 {0} ;

// 全 局 数组

void DFSCAdjGraph * G,int v)

// 深 度 优先遍 历 算法

ArcNode * pi;
visited[] 一 1;
Printf( "只 dv);

// 置 已 访问标记
// 输 出 被 访问 顶点 的编号

p=G 一> adjlist[v] .firstarc;

//p 指向 顶点 的 第一个邻接点

while (p!=NULL)
{

庄 Cvisited[p

一 adjve忆= 一 0)

, //若p 一 adjvex 顶点未被访问,递归 访问 它

DFSCG,p一> adjvex);

p 一 p 一 nextarc;

//p 指向 顶点 的 下 一 个邻接 点

{

】}

以邻接矩阵 为存储 结构 的 深度优先 遍历 算法与此类似, 这 里 不 再 列 出 。

下 面 以图 8.7(a)

所示 的 邻接 表 为例调用DFS 算法 ,假设 初始 点 "一2,

的执行过程如下。
调用 DFS(CG,2)

O@ DFS(CG,2): 访问 顶点 2,找 顶点 2 的相邻 顶点 1, 它 未被访问过,

转 @;

视频讲骨

@ DFS(G,1): 访问 顶点 1,找 顶点 1 的相邻 顶点 0, 它 未被访问过,

转@四;

@@ DFS(G,0): 访问 顶点 0,找 顶点 0 的相邻 顶点 1, 它 已 被访问 ,找 下 一 个相邻 顶点 3,

它 未 被访问 过 , 转 @;

田 DFS(G,3): 访问 顶点 3,找 顶点 3 的 相 邻 顶点 0.1、.2 ,它们 均 已 被 访问 ,找 下 一个相

邻 顶点 4, 它 未 被 访问 过 , 转 @;

@ DFS(G,4): 访问 顶点 4,找 顶点 4 的 相 邻 顶点,所 有 相 邻 顶点 均 已 被访问,退出

DFSCG,4),转@;

继续 DFSCG,3): 顶点 3 的所有 后 继 相 邻 顶点 均 已 被 访问,退出 DFSCG,3),转〇;
G@ 继续 DFS(G,0): 顶点 0 的所有 后 继 相 邻 顶 点 均 已 被 访问 ,退出 DFSCG,0),转@;

Ca

@@ 继续 DFS(G,1): 顶点 1 的所有 后 继 相 邻 顶点 均 已 被 访问 ,退出 DFSCG,1),转@四;

@ 继续 DFS(G,2): 顶点 2 的所有 后 继 相 邻 顶 点 均 已 被 访问 ,退出 DFSCG,1),转@;

如图 8. 11 所示 , 从 顶点 2 出 发的深度 优先 访问 序列 是 210314。

对 于 具有 宛 个 顶点.e 条 边 的 有向 图 或 无向 图,DFS 算法 对 图 中 的 每个顶点 最 多 调用 一

数据 结构教程

[第! 5 【版

本
DFS(G, 2)

|
访问 项点 4,顶 点 4的所 有 邻接 点 均 已被访问--- |

的执行过程
图 8.11 DFS(G,2)

次 ,因此 其递归 调用 总 次 数 为2。 当访问某个 顶点 时,DFS 的时间 主 要 花 在 从 该 顶点 出 发

查找它的邻接点上。当月

日邻接 表 表 示 图时 ,需要 痪历 该 顶点 的所有邻接点,所以DFS 的总

时间为O(z十e); 当 用 邻

接 和 矩阵表示 图时 ,需要 遍历 该 顶点行 的所有 元 素,所以DFS 的总时

间为O(0z2)。

从 上 面 可以 看 出 ,在 深度 优先遍历 中 ,每次沿着边 * 前 进”( 纵 向 ) 一 个 顶点,相当 于 对 图

“层次化”,使图中 的 每 个

质点都有一个层次 号,只 是 深度优先 遍历 中 这 个 层次 号不如 广度 优

先 遍历中 的 层次号有 意义 。

833 广度 优先 遍历

广度 优先 遍历 的 过 程 是 首先 访问 初始 点 "接着访问 顶点 " 的所有 未 被 访问 过 的邻接

点 mm,ut; 然后再 按照

mm,...u 的 次 序 访问 每 一个顶点 的所有 未 被 访问 过 的邻接

点 , 依 此 类 推,直 到 图 中

所 有 和 初始点 v 有 路径相 通 的 顶点 都 被访问 过

要-要

为止。

例如 ,对 于 图 8.4 所 示 的有向 图,从 顶点 0 开始 进行广度优先 遍历 ,可

以 得 到 以 下 访问 序列 : 0

1324:031214。

以 邻接 表 为存储 结构,在用广度 优先遍历图时 需要 使 用 一 个队列 ,这里 一 洒天宙

采用 环形 队列 ,以 类 似 于 二

二 又 树 的层次 遍历 方式来遍历 图 。对 应 的 算法如

下 (其 中 心 是初始 点 ) :

void BFSCAdjGraph * G,int v)

{

int w,iArcNode * p;

SqQueue * qui
JInitQueue(qu) ;

int visitedLMAXV] ;

PE

/定义环形队列指针
// 初 始化队列

// 定 义 顶 点 访问 标记 数组

for (i=0;i<G 一 nii 十 十) visited加一0;

// 访 问标记 数组 初始化

printf(" 吧 2d",v);

visited[V] 一 1;

enQueue(Cqu,v);

while (1QueueEmptyCqu))

{

deQueue(qu, w);

// 输 出 被 访问 顶点 的编号

// 置已访问标记

// 队 不 空循环

//出队一个顶点 w

266

OA

p=王G一> adjlist[w] .firstarc;

while (p!I=NULIL)

// 指 向 w 的 第 一 个邻接点

// 查找 w 的所有邻接点

{

寺 (visited[p -> adjvea一一0)

// 若 当前邻接 点 未被访问

{

printf(" 邓 2d",p 一> adjvex);

visited[p 一 adjve对一1;

enQueue(qu,p -> adjvex);

// 访 问 该邻接点

// 置已访问标记

// 该顶点进队

】}
p一pb 一 nextarc;

// 找 下 一 个邻接点

}

}
printfC"\n") ;

)}

以邻接矩阵 为存储 结构 的 广度优先 遍历 算法 与 此 类似 , 这 里 不 再 列 出 。

下 面以图 8.7(a)

所示 的邻接 表 为 例 调用BFS 算法 ,假设 初始 点 v 一2, 调用 BFSCG,2)

的执行过程如下。

g@ 访问 顶点 2,2 进 队 , 转 @;

@ 第 1 次 循环: 顶点 2 出 队 ,找 其 第 一 个相邻 顶点 1, 它 未 被 访问 过 ,访问 之 并 将 1 进

队; 找 顶 点 2 的 下 一个相 邻 顶点 3 , 它 未 被 访问 过 ,访问之并 将 3 进队; 找 顶点 2 的 下 一 个

相 邻 顶点 4, 它 未 被访问 过 ,访问 之 并 将 4 进 队 , 转 @四 ;

@@ 第 2 次 循环: 顶点 1 出 队 ,找 其 第 一 个相邻 顶点 0, 它 未 被访问过 ,访问 之 并 将 0 进

队; 找 顶 点 1 的 下 一个相 邻 顶点 2, 它 被访问过; 找 顶点 1 的 下 一个相 邻 顶点 3,它被访问

过,转@;

图 第 3 次 循环: 顶点 3

均已被访问过,转@;
出 队 , 依 次找 其相邻 顶点0.1.2.4,

加 第 4 次 循环: 顶点 4 出 队 , 依 次找 其相邻 顶 点 0.2、3 , 均 已 被访问 过 , 转 @;

均已被访问过,转〇;
第 5 次 循环: 顶点 0 出 队 , 依 次找 其相邻 顶点 1.3、4,

@ 此 时 队列 为 空 ,遍历 结束 , 即 21340。

如图 8. 12 所示 , 从 顶点 2 出 发 的 广度 优先 遍历 序列 是 21340。

对 于 具有 交 个 顶点 e 条 边 的 有向 图 或 无向图,在 BFS 算法 中 每 个 顶点都进队 一 次 , 因

此 执行时间 与 DFS 相同 。当 图 采用 邻接 表 表示 图时,BFS 的 总时 间为O(z十e); 当 图 采用

邻接 矩阵 表示 图 时 ,BFS 的 总 时间 为 O0z2) 。

从 上 面可以 看 出 ,在 广度 优先遍历 中 ,每次沿 着 边 * 前 进”( 横 向 ) 一 个 顶点,也 相当 于 对

图 "层次 化”, 使图中 的 每 个 顶点都 有 一 个层次 号,由 于 在 搜索 中 不 同 路 径 可 能 会 有 多 条 边 到

达 ,在 广度优先 遍历 中 取 离 出 发 点 最 短 者 ,即层次 号 最 低 的那个 。也 就 是 说,从 顶点 立 出发

进行 广度优先 遍历 到 顶点 wx,取v 到 zx 的 一 条 最 短路 径 (长 度 为 0) ,如果v 的层次号 为2, 则

顶点 x 的 层次 号 一 定 为!十 1。

834 非连通图的遍历

Rs

前 面 讨论了 图 的 两种遍历 方法,对 于 无向图来说,若是连通 图 , 则 一 次

遍历 能 够 访问 到 图 中 的所有 顶点 ; 若 无向 图 是非 连通图, 则 只 能 访问 到 初

的。为 此 需要 从 其他 每个连通 分 量 中 选择 初始 点 ,分 别 进行 遍历 ,这 样 才能 视顺讲角

267

数据 结构 教程

虹 第人5 【版

调用BFS(G.2)

队列 状态

1

012345 6

ES
访问2,2进队

了

2

人
front rear

2 出队
找 2的 相 邻 点1, 访问1,1 进队
找 2的 相 邻点3, 访问3,3进队
找 2的 相 邻 点4,访问4,4进队
]

0

LL2 3 4 56

113|4

Tear

下
位 ont

1 出 队

0 123435 6

找 1的 相 邻 点 0,访问0,0进队
找 1 的 相 邻 点 2( 已 访问 )
乒 1的 相 邻 点 3( 已 访问 )

3|4|0
下
Tear

front

3 出队

乒 3的
相 邻 点 0( 已 访问)
二 3的 相邻 点1(已访问)
线 3 的 相 邻 点 2( 已 访问)
找3的相 邻 点 4( 已 访问 )

0123435 6

4|0
[|

front

rear

4 出队

0123435 6

生4的相 邻 点0( 已 访问)
找4的 相 邻 点 2( 已 访问 )
找 4 的 相 邻 点 3( 已 访问 )

0
7

front

rear

0 出队

0123435 6

0的相 邻 点1( 已访问)
乒 0的 相 邻 点 3( 已 访问)
乒 0的 相 邻 点4( 已 访问)

NAN

front

rear

的执行过程
图 8.12 BFSCG,2)

够访问 到 图 中 的所有 顶点 。

对于有向图 来说, 若 从 初始 点 到 图 中 的 每 个 顶点 都有路 径 , 则 能 够 访问 到 图 中 的所有项

点 ; 否则 不 能 访问 到所有 项 点 ,为此 同样需要 再 选择 初始 点 ,继续 进行遍 历 , 直到图中的所

有 顶点 都被访问 过 为止。

采用 深度 优先 遍历非连通无向 图 的算法如下 :

DFS1CAdjGraph * G)

{人 inti

for (i王0;i<G 一 nii 十十)

这 (visited[品一一0) DFSCG,D;

}

采用 广度 优先 遍历非连通无向 图 的算法如下 :

268

DOOR

BFSICAdjGraph * G)

{人 inti;

for (i=0;i<G一>nii 十十)

这 (visited[口二 一 0) BFSCG,iD;

}

【例8.3】 假设图G 采 用 邻接表 存 储 ,设计 一 个 算法 ,判断 无 向图 G 是 否 连 通。若连

通,返回 true,和否则返回 false。

可 采用 某种遍历 方式判断 无 向图 G 是 否 连通。这 里 用 深度 优先 遍历 方法 , 先 给

visited 数组 (为 全 局 变量 ) 的所有 元 素 置 初值 0, 然 后从 0 顶点 开始 遍历 该 图。在 一 次 遍

历 之后, 若所有 顶点 守 的 visited[实均为 1, 则 该图是 连通 的 ,和 否则 不 连通 。对 应 的 算法

如下:

bool Connect(AdjGraph * G)

// 判 断 无 向图 G 的 连通 性

{

inti

bool flag一true;

一nii十十)
for (Gi=0ii<G

//visited 数组置初什

visited[ 丫一0;

DFS(CG,0);

for (i王0;i<G 一> nii 十十)

// 调 用 前 面 的中DSF 算法 ,从 顶点0 开始 深度 优先 遍历

这 (visited[品一一0)

//若有 顶点 没有被 访问 到 ,说 明 是不连通 的

{ , flag一false;

break;

】》

return flag;

835 图 遍历 算法 的 应 用

图 遍历 主要 有 深度 优先遍历和 广度 优先遍历 两 种 方法,下 面 讨论这 两种遍历 方法 在 图

算法 设计 中 的 应 用 及 其 差异 。

要-要

图 的 深度 优先 遍历 过 程 是从初始 点出发,以纵向的 方式 一 步 一步向 前

访问 各 个 顶点 的 ,一 旦 找 不 到 相 邻 的 顶点 就 回 退。从图 8. 9 可 以 看 到,DFS
算法的执行过程是 DFS(G,2)一DFS(CG,1) 一 DFSCG,0) 一DFSCG,3) 一

训 末讲 角

DFS(CG,4)。 如 果 图 是 连通 的 ,可 以 通过 这 样的重复调用 找 遍 图 G 中 的所有 顶点。这 种思

路 常用 于 图 查找 算法 中 。

【例8.4】 假设图G 采用 邻接 表 存 储 , 设计 一 个 算法判断 图 G 中 从 顶点 到 v 是 否 存

在 简单路 径 。

所 谓 简单 路径是 指 路径上 的顶点不重复 。采 用 深度 优先 遍历 的 方法,从 顶点 wx 出

发遍历到顶点 w 的 过 程如图 8.13 所 示 。 为 此 在 深度 优先 遍历 算法 的 基础 上 增加 w 和 has

两个形 参 ,其中 has 表示 顶点 wx 到 vw 是否有 路 径 , 其 初 值为false,当从顶点 x 遍历到顶点

后 ,置has 为 true 并 返回。查 找 从 顶点 wx 到 v 是 否 存在 简单 路 径的过 程如 图 8. 14 所 示 。

269

PIGGOOO

图 8.13 从 顶点 v 到 的深度优先遍历过程

mV

Guvhas)

置 visited[z]=1 , 找zx 的 未被访
问 过 的邻接点zm ,并继续 下 去

Guwhas)

置 visited[zm]=1, 找刀 的 未被访
问 过的邻接点如 ,并 继续 下 去

LT

用 Gosvhas)

1

|

Govhas)

若zw=y,
置has=true并返回

图 8.14 查找从顶点 x 到 是 否 存在简单路径

对应的算法如下 :

void ExistPath(AdjGraph * G,int u,int v,bool &has)

{

,V//has 表示 u 到是否有路径,初值为false

int w;ArcNode *p;

visited[Jj 一 1;

让 (u=一v)

{ has一true;

Teturni

}
p 一 G 一 > adjlist[u] .firstarc;

while (p!=王NULL)

// 置已访问标记

// 找到了 一 条 路 径

//置has 为 true 并 返回

//p 指向 顶点 的 第 一 个邻接 点

{ wmw=p一> adjvex;

V//w 为 顶点 的 邻接 点

if (visited[w]=一0)

// 若 w 项 点 未 访问 ,递归 访问 它

了ExistPath(G, w,v,has) ;

p 一 p 一 > nextarc;

//p 指向 顶点 的 下 一 个邻接 点

}

)》

其 中 粗 体 部 分 对 应 深度 优先遍历 过 程 。

【例8.5】 假设图G 采用 邻接 表 存 储 , 设计 一 个 算法 输出图G 中 从 顶点 wx 到 v 的 一 条

简单路径(假设图G 中 从 顶点 x 到 v 至少有 一 条 简单 路 径 ) 。

采用 深度 优先遍历 的 方法,从 顶点 x 出 发找到 顶点 v 的 一 条 路 径 的 过 程 如图 8. 15

所 示 。 为 此 在 深度 优先 遍历 算法 的 基础上 增加 vw\path 和 & 儿 个 形 参 ,其中 path 存放 顶点 v

到 v 的 路 径 ,4 表示 path 中 的 路 径 长度, 其 初 值 为 一 1。当 从 顶点 “遍历到顶点 v 后 ,输出

path 并 返回。查 找 从 顶点 x 到 的 一 条 简单 路径的 过 程如 图 8. 16 所 示 。

270

OO

图 8.15 从 顶点 wx 到 v 的 深度 优先 遍历 找 路 径的过 程

Zn=V

Gaewpath.a)

寺+;path[d=

寻置visited[d=1, 若找到 zx

| 的 未 被 访问 过 的 邻接 点 四 ,继续下去

九G.wDy:path.d)

寺+;path[dl=;

置visited[z]=1, 若找到 加

| 的 未被 访问 过的 邻接点加 ,继续下去

GonwpathaD)

1

故 Gunvpath.a)

若zn=v, 输 出 path 并 结束

图 8.16 查找从顶点 x 到

的 一 条简单路径

对应的 算法如下:

void FindaPath(AdjGraph * G,int u,int v,int path[] ,int d)

{ //d 表 示 path 中 的 路 径 长度, 初 始 为一1

int w,iiArcNodex* p;

visited[同一 1;

d 十十; path[d]一ui

让 (u=一v)

{

for (i一0;i<一dii十十)

printf("%d ",path口 );

printfC"\n");

Teturni;

}
p 一 G 一 > adjlist[u] .firstarc;

while (p!王NULL)

{ wmw=p一> adjvex;

这 (visited[w]=一0)

// 路 径 长度 4 增 1 ,顶点 u 加入到 路 径 中

// 找 到 一 条 路 径 后 输出并 返回

/Vp 指向 顶点 的 第 一 个邻接 点

// 邻接点的编号为 w

FindaPath(G,w,v,path,d);

p 一 p 一> nextarc;

//p 指向 顶点 的 下 一 个邻接 点

}

}

Is

【例8.6】 假设图G 采 用邻接表存储 ,设计一个算法 输出图G 中 从 顶点

& 到 的所有 简单 路 径 (假设图G 中 从 顶点 wx 到 v 至 少 有 一 条 简单 路 径 ) 。

本 题利用 回溯 的 深度优先 遍历 方法,由 于 在 遍历 过程中 每个顶点 只访

间 一 次 ,所以 这 条 路 径 必 定 是一条 简单 路 径。在 深度 优先遍历 算法 的 基础上

增加 w\path 和 qd 几 个 形 参 ,其中 path 存放 顶点 v“ 到 的 路 径 ,d 表示 path 中

271

数据 结构教程

(第5 【版

的 路 径 长 度 , 其 初 值 为一1。

当 从 顶点 zx 出 发遍历时,先将 visited[zq]置为 1, 并 将 wx 加 到 路 径 path 中 ,如果满足顶

点 & 就 是 终点 的 条 件 , 则 表示 找到 了 一 条 从 顶点x 到 的简单路径,输出path。 再从终点

回退(置 "的 访问标记为 0) 继 续 找 其 他 路 径 , 也 就 是 说 ,允许 曾经访问 过 的 顶点出现在 另

外 的 路 径 中。查找从顶点 x 到 v 的所有 简单 路 径的过 程如图 8. 17 所示 。

刀 Gevpath.d)

置visited[xq=1,d+;path[dl=若找到x的未被 访问过

| 的 邻接 点 四 ,继 续 下 去 ,否 则 置visited[x]=0并返回

Genwpath.d)

若找到的未被访问
置visited[x]=1,d++:path[dj=wi:
+ 过 的邻接点加 ,继续下去,否 则 置 visited[x]=0并返回

用 Govpath.d)

t
Gunwpath.d)

回 退

若 w=v, 输出path

图 8.17 查找从项点x 到 的所有简单路径

对 应 的算法如下 :

void FindAllPathCAdjGraph * G,int u,int v,int path[] ,int d)

{

//d 表示 path 中 的 路 径 长度, 初 始 为一1

int w,i;ArcNode * p;
d 十十; path[吕一ui;

visited[ 由 一 1;

让 (u==v&& d>=0)

{

for (ii一0;i<一dii十十)

printf("%2d",path口);

printfC"\n");

}
p一G -> adjlist[u] .firstarc;

while (p!王NULL)

{ wmw=p一> adjvex;

//路径长度d增 1, 顶点u 加 入 到 路 径 中

// 置已访问标记

// 若 找到 一 条 路 径 则 输出

//p 指向 顶点 的 第 一 个邻接 点

V//w 为 顶点 的 邻接 点

if (visited[w]=一0)

// 若 w 项 点 未 被 访问,递归 访问 它

FindAllPath(G, w,v,path,d);

p 一 p 一> nextarc;

//p 指向 顶点 的 下 一 个邻接 点

二

}

visited[由一0;

// 恢 复 环 境 , 使该顶点 可 重新使用

)}

【例8.7】 假设图G 采 用 邻接 表 存 储 , 设计 一个算法 ,输出图G 中 从 顶点x 到 v 的长度

为 的所有简单路径。

遍历 思路 和 上 例 相 似 , 只 需将路 径 输 出 条 件 改为x王=吉上且以 = 一/。 查找从顶点 v

到 的所有 长 度为! 的 简单路径 的 过 程如图 8. 18 所 示 。

272

PASS国 |

GewPpath.d)

置visited[dj=1,ct++:path[d=
刀若找到zx的未被访问过

| 的 邻接 点 四 ,继续下去,否 则 置 visited[xj=0并返回

GaswLpatha)

若找到的未被访问
置visited[x]=1,d++:path[dj=wi:

| 过 的邻接点 ,继续下去,否 则 置visited[x]=0并返回

Go:wLpath,d)

!
1

回退

所 Gypath,dD)

若zm=vy且 qd=/, 输出path

图 8.18 查找从顶点 x 到 的所有 长 度 为! 的 简单路径

对

应 的算法如下

void PathlenAll(AdjGraph * G,int u,int v,int l,int path[] ,int d)

{

//d 表示 path 中 的 路 径 长度, 初 始 为一1

int w,i;ArcNode * p;

visited[d 一1;

d 十十; path[吕一 ui

//路径长度 4 增 1 ,顶点 u 加 入 到 路 径 中

这 (Cu==一 v&& d=一D)

// 输 出一条 路 径

人

printf("");

for (i一0;i<一dii十十)

printf("%d ",path口 );

printf(C"\n");

}

p=G -> adjlist[u] .firstarc;

//p 指向 顶点u 的 第 一 个邻接点

while (p!王NULL)

wmw=p 一> adjvex;

//w 为 则 的邻接 点

这 (visited[w] = 一 0)

// 若 该 项点未 标记 访问 , 则 递归 访问 之

了PathlenAll(G, w,v,1l,path,d);

pp一p 一>nextarc;

//p 指向 项 点 的 下 一 个邻接点

{

}

visited[ 同一0;

// 恢 复环境 , 使 该项点 可 重新 使用

)}

设计以下主函数:

int main()

{

int pathLMAXV] ;

int u一1,v一4,]一3;

int n 一 5,e一8;

int ALMAXV]LMAXV]={{0,1,0,1,1) ,11,0,1,1,0},

{0,1,0,1,1) ,11,1,1,0,1),{11,0,1,1,0})};

AdjGraph * G;

CreateAdj(G,A,n,e);

// 建立图 8.1(a) 所 示 的邻接 表

273

数据 结构 教程

[第! 5 【版

for (int i 一0;i<ni;i 十十)

visited[ 丫一0;

V//visited 数组置初什

printf("图G:\n");DispAdj(G);
printf("从中d到 %%d 的所有 长 度为%d 的 路径:\n" ,uv,D;

// 输 出邻接表

PathAll(G,u,v,l path, 一

1);

// 销 毁 邻 接 表

printfC"N\n");

DestroyAdj(G) ;

Teturn 1 ;

)}

程序 的 执行 结果如下 :

图 G:

0:

1:

10] 30] 一4[D] 一人
0[] 一2[] 一 3[] 一人

1[0] -3[] 一4[] 一人

2:
3: 0[] 一1[0] 一20] 一4[] 一人
4: 0[] 一2[] 一3[D] 一人

从 顶点 1 到 4 的所有 长度为 3 的 路 径 :

1034

1234

1304

1324

人

【例8.8】 假设有向图 G 采 用 邻接 表 存 储 , 设 计 一 个 算法 , 求

图 中通过某顶点& 的所有 简单回路 ( 若 存在) ,并 输出如 图 8. 19 所

CC)

(4) 示 的 有向 图 的 邻接表和 通过 顶点 0 的所有简单回路 。

AAA
G] G)

所 谓 简单回路 是指 路径上 的 顶点 不 重复 ,但 第 一个顶点
与 最后一 个 顶点 相同 的 回路 。 利 用 回溯 的 深度 优先 搜索 方法从

图 8.19 一个有向图 ”度 大 于 1, 表示找到 了 一 条 回路 ,输出 path 数组

顶点 开始 搜索 与之相 邻 的顶点 邮 , 若 z等于顶点 , 且 路 径 长
继续 搜索

顶点 x 的 未 访问 的邻接 点 查找 其 他 回路 。对 应 的 算法如下 :

int visited[MAXV] ;

// 全 局 变量

void DFSPath(AdjGraph * G,int u,int v,int path[] ,int d)

{

//d 表示 path 中 的 路 径 长度, 初 始 为一1

int w,i;ArcNode * p;

visited[ 同一1;

d 十十;path[吕一 ui;

p一G -> adjlist[u] . firstarc;

//p 指向顶点 u 的 第一个邻接点

//w 为 顶点 u 的 邻接点
// 找 到 一 个 回路,输出之

视频讲解

while (p!=NULL)

人

, w王 p 一 adjvex;

这 (w=一 v&& d>1)

{

printf(C"”");

for (i一0;i<一dj;i十十)

printf("%%d ",path口);

printf("%d \n",v);

274

ESAS 国 |

}
if (visited[四一一0)

DFSPath(G, w,v,path,d);

//若w 未 被 访问 , 则 递归 访问 之

p一p 一> nextarc;

//找u 的 下 一 个邻接点

}
visited[加一0;

// 恢 复 环境, 使该顶点 可 重新使用

)}
void FindCyclePath(AdjGraph * G,int k)

// 输 出经过 顶点 k 的所有 回路

int pathLMAXV];

DFSPath(G,k,k,path, 一

1);

{

)}

设计以下主函数:

int main()

{

intn 一 5,e一7;
int ALMAXV][IMAXV]={

{0,1,1,0,0},{0,0,1,0,0},{0,0,0,1,1},{0,0,0,0,1},{1,0,0,0,0}};

AdjGraph * G;
CreateAdj(G,A,n,e);
for (int i=0;i<ni;i 十十)

visited 四 一0;

// 建立图 8.19 所 示 的邻接表
V//visited 数组置初值

printf("图G:\n");DispAdj(G);

// 输 出邻接表

int k 一 0;
printf("图 G 中 经 过顶点%%d 的所有 回路 :\n",k);

FindCyclePath(G,k) ;

printfC"\n");

DestroyAdj(G);

return 1;

)》

程序的执行结果如下:

图G:

// 销 毁 邻接表

coee天局

: 1 一2[ 一人

2[0] 一人

3[D] 一4[] 一人

4[] 一人

4:

0[] 一人

图 G 中 经 过顶点 0 的所有 回路

012340

01240

02340
0240

aa

2 基于 度优和 所 历算法的订 用

图 的 广度 优先 遍历 算法 是 从 初始 点 zx 出 发 ,以 横向 方式 一 步 一 步 向 前

访问 各 个 顶点 的 ,即 访问 过 程是一 层 一层地向 前 推进 的 。从图 8. 12 可 以看

到 ,每 次都 是从一 个 顶点 x 出 发找所有 相 邻的未 被 访问 过 的 顶点 ui yxz ,...,

tm 并 按 ma ,zaom 依次进队 , 若 采 用 非环形 队列 (出 队 后 的 顶点 仍 在 队

数据 结构 教程

[第! 5版

列中), 则 队列 中 的 每 个 顶点 都 有 唯一的 前 驱 顶 点 ,可 以利用 这 一特征 采用 广度 优先 遍历 算

法找从顶点 wx 到 顶点 v 的 最短路径。

【例8.9】 假设图G 采 用邻接表存储 ,设计一个算法 , 求不带权 无 向 连通 图 G 中 从 顶点

& 到 顶点 v 的一条 最短路径。

Cr|-

图 G 是 不 带权 的 无向连通 图 ,一 条 边 的 长度计 为

1,因此 求 顶点 x 和 顶点 v 的 最短路 径即求 距离顶点 v 到 顶

点 v 的边数 最 少的顶点 序列。利 用 广度 优先遍历 算法,从

& 出发进行 广度 站 历 类 似 于 从 顶点 w 出 发 一 层 一层地 向 外

图 8 20 查找 顶点和 项点,的 扩展 ,当 第 一 次 找到 顶点 时 队列 中 便 和 包含了从 顶点 v 到
顶点 的 最短路径, 如图 8. 20 所示,再 利用队列 输出 最 短
路径(道路径序列)。

最 短路径

由 于 要利用 队列找 出 路 径 ,所以设计成非环形队列,其 类 型 声明 如 下 :

typedef struct

{

int datai

int parent;

) QUERE;

//顶点编号
// 前 一 个 顶点 的 位 置

// 非 环形队列类型

在算法中直接用 qu 数组 存放 队列 中 的 元 素,用 front 和 rear 两个整 型变量 分别 作为 队

头、队 尾 指针。对 应 的 算法如下:

void ShortPath(AdjGraph * G,int u,int v)

{ // 输出从顶点 u 到 顶点 v 的 最 短 逆 路 径

ArcNode * piint w,i;

QUERE quLMAXV] ;

一一1,rear一一1;
int front

int visitedLMAXV] ;

// 非 环形 队列

// 队 列 的头、 尾 指针

一nii十十)
for (Gi=0ii<G

// 访 问标记 置 初值 0

visited[ 品一0;

rear 十 十 ;

qu[rear] . data一ui

qu[rear] . parent一一 1;

visited[由一 1;

while (front!一rear)

{

front十十 ;

w一qu[front .data;

让 (w 一一v)

{

ii 二 front;

四

// 顶点u 进 队

// 队 不 空循环

//出队 顶 点 允

// 找 到 v 时 输出 路 径 之 逆 并 退出

// 通 过 队列 输出 逆 路 径

while (qu[申.parent!一一 1)

printf("%2d ",qu[丫.data);

i一qu[ .parent;

{

】}

printf("%2d\n" ,qu[癌.data) ;

Teturni

}

p=王G 一 > adjlist[w] .firstarc;

//找 w 的 第 一 个邻接点

276

DOOR

while (p!=NULL)

{

这 COCvisited[p -> adjve对王一0)

{

visited[p 一> adjve对一 1;
rear 十十 ;

qu[rear] . data一p 一 adqjvex;

qu[rear] . parent王front;

}
p 一 pb 一 nextarc;

// 将 w 的 未 访问 过 的邻接 点进队

// 找 的 下 一 个邻接点

)》

}》

)}

通过 本 算法 求 得 ,在 图 8. 19 中 顶点 0 到 顶点 4 的 最 短 逆 路 径 为 4.2、0。

【例8. 10〗 假设图 G 采用 邻接表 存储 ,设计 一 个 算法 , 求 不 带权 无 向连通 图 G 中 距离

图 G 是 不 带权 的 无 向连通 图 ,一 条 边 的 长 度计 为 1, 因 此求距离顶点"的最远的项

点 即 求 距 离 顶点 v 的 边 数 最 多 的 顶点 。 利 用 广度 优先 遍历 算法 ,从

顶点 露出 发 进行 广度 遍

历 类似于 从 顶点 , 出 发 一 层 一层地 向 外 扩展 ,到 达 顶 点 思 ...... ,最 后 到 达 的 一 个 顶点 & 即 为 距

离 最 远 的 顶点 ,如 图 8. 21 所示。在 遍历时 利用 一 个 队

列 逐 层 暂 存 各 个 顶点,最 后 出 队 的 一 个 顶点 上 即为所求。

由 于 本 题 只 需要 求 距 离 顶点 " 最 远 的 一 个 顶点 ,不

CC

需要 求 路 径,所以 采用 的 队列 可 以 是 环形 队列 。和 上 例

一样,直接用 qu 数组 存放 队列 中 的 元 素,用 front

和 rear

两 个 整 型变量 分 别 作为 队 头、.队 尾指针 。

对应的算法如下 :

图 8.21 查找 距离 顶点 "最 远 的

顶点

int Maxdist(AdjGraph x G,int v)

{

ArcNode *p;
int QuLMAXV] ;

int front一0,rear一0;

int visitedLMAXV] ;

int ij,k;

// 环 形队列数组

// 队 列 的 头 、 尾 指针

// 访 问标记数组

for (Ci一0;i<G一> nii 十十)

// 初 始 化访问 标记 数组

visited[ 品一0;
rear 十 十;Qu[rear] 一 v;
visited[V] 一 1;

while (rear!一front)
{
front= (front 十
k一Qu[front] ;

// 顶点v 进 队
// 标 记 v 已 访问

1)%MAXV;

// 顶点k 出 队

p 一 G 一 adijlist[l] .firstarc;

// 找 第 一 个邻接点

while (p!I王NULL)

{ j=p一adjvex;

这 (visited中一一0)

// 所 有 未 被访问 过 的 邻接 点进队

// 邻接点为顶点j
//若j未 被访问过

{

visited[D] 一 1;
rear 一 (rear 十1) %MAXV;
Qu[rear] 一 j;

// 顶点j 进 队

277

数据 结构教程

[第! 5版

p 一 p 一 nextarc;

// 找 下 一 个 邻接 点

】}

}

return k;

}》

通过本算法求得图 8. 1(a)中离顶点 0距离最远的是顶点 2 。

了 用同调 历方关 求解六 宫亲 全

在第 3 章 介绍 了 用栈和 队列 求解 迷宫 问题 ,实际 上迷宫就是一个图,用

栈 搜索 迷宫 路 径 采用 的 是 深度 优先 遍历 ,而用队列 搜索 迷宫 路 径 采 用的是广

度优先遍历。

在 采用 图 算法 求解迷宫 问题时 首先 要 创建迷宫 图对 应 的 邻接 表 , 图 8. 22

所 示 的 是 一 个 小 迷宫 图对 应 的邻接 表 , 迷 宫 中 的 一 个 可 走 方 块(i7 对 应 一

个 顶点 ,邻接 表 的 头结 点 是 一个二 维 数组 。对 应 的 邻接 表 类 型 声明 如 下 :

typedef struct ANode

{

)

inti j;

Struct ANode * nextarc;

ArcNode;

// 边 结 点 类 型

typedef struct Vnode

{

ArcNode * firstarc;

// 指 向 第 一个相邻可 走 方块

) VNode;
typedef struct

{

VNode adjlistLM十][N 十人 ]; // 头 结 点 数组

} AdjGraph;

// 迷 宫 图 的 邻接 表 类 型

adjlist[MX+2][N+2

(0.0) | 入 | firstarc

(人 记
并
一 (1.2)

(11)

nextarc

一| (2.1)| 八

(12)

一 (1.1)

m生| (1.3) | 八

(1.3)

一| (1.2)

一| (2.3)| 和八

(4.4)

一|一| (4.3)| 八

图 8.22 由迷宫产生的邻接表

在 搜索 迷宫 路 径时 可以 采用 DFS 或者BFS 算法 ,将访问标记 数组 改为visitedLM十2]

LN十2?](其中M、N 表示 迷宫 的行 \ 列 数 ) 。入 口 作为初始 顶点 ,结束 条 件 为找到 出

口 。

278

OO

采用 回溯 的 DFS 求解 迷宫 问题时可以 搜索从人口到 出 口 的所有 迷宫 路 径 ,采用 BFS

算法 求解迷宫 问题时 可 以 搜索从 人 口 到 出 口的最短路径。

玫 深度优先 遍历和 度优多 遍历 求解路和 下 亲 二 午

当 在 一 个 不带权 图 中搜索从顶点 “到

的 一 条 路 径 时 ,采用 DFS 求出的 路 径 不 一定是

最短路径 ,而采用 BFS 求出的 路 径 一 定 是 最短路径, 这 是 为 什么呢 ?

以图8. 23(a) 为例, 假 设搜索 路 径 的 起 点 为 顶点 0终点为顶点4。 从图

中 可以 看 出 :

0一1 的 最 短路 径 为 (0,1) ,长 度为1;

0->~2 的 最 短路 径 为 (0,1,2) 或 者 (0,3,2) ,长 度为2;

0-~~3 的 最 短路 径 为 (0,3) ,长 度为1;

视频讲解

0一4 的 最 短路 径 为 (0,3,4) ,长 度为2。

按 最 短路 径 长度将 顶点 分层, 顶 点1和 3 的 最短路径长度 为1, 放 在 第 1 层; 顶点2 和 4

的 最短路径长度为 2, 放 在第 2 层 。其结果如图 8. 23(b)所示。

(b) 以 起 点 到 该 顶点 的 最 短路 径 构成 的 分层

图 8.23 一 个图和 按 最 短路 径分层

在 采用 DFS 算法时 求 出 的一条 可 能 的 路 径 是 (0,1,2,4), 其 中 顶点 2.4 在 同一层中;

而 采用 BFS 算法 求出的一条 路径只 能 是(0,3,4)。 也 就 是 说,DFS 算法 求 出的路径中 的 顶

点 可 能 在 同一层中 ,所以 该路径不一定是 最 短路 径 ,而 BFS 算法求 出 的 路径中 的所有 顶点

一 定 在不同 层中,所 以 该 路 径一定 是 最 短路 径 。

生成 树 和最小生成树 漆

841 生成树的概念

一 个 连通 图的生成 树(spanning tree) 是 一 个 极 小连通 子图,其 中含有

图 中 的 全 部 顶点,和 构成一棵 树 的(2 一1) 条 边 。如 果 在 一 棵 生成树上 添加

任何 一 条 边 ,必定 构成 一 个环, 因 为 添加 的 这 条 边 使 得它关联 的那 两个顶点

视 上和

之间有了第 2 条 路 径 。

一 棵 有 交 个 顶点 的 生成树( 连 通 无回路 图)有 且 仅有(z 一1) 条 边 。如 果 一 个图有 盖 个顶

点 和小 于 (一1) 条 边 , 则 是非 连通 图。如 果 它 多 于 (一1) 条 边 , 则 一定有 回路 。

279

数据 结构教程

[第! 5版

对 于 一 个 带权 ( 假 设 每 条边上 的权 均 为大于 零 的实数 ) 连 通 无向 图 G 中 的 不 同 生成树 ,

其 每 棵 树 的所有 边 上 的权 值之和 也 可 能 不 同; 图 的 所 有生成树中具有边 上 的权 值 之 和 最小

的 树 称 为 图的 最 小 生成 树C(minimal spanning tree) 。

最 小 生成树的 准则 有以下 3 条 :

(1) 必须只使用该 图中 的 边来构造 最 小 生成 树 ;

(2) 必须 使用且 仅 使 用 (一 1) 条 边 来连接 图 中

的 个 顶点 ;

(3) 不 能 使 用产生 回路 的 边 。

求图的 最小 生成树有很 多 实际应用 ,例如 城市之间的 交通 工程 造价最优问题 就 是一个

最 小生成树问题 。求 图 的 最小 生成 树 的 两 个 算法即 普 里 姆 算法和 克 鲁 斯卡尔 算法 ,将 分 别

在 后 面 介绍 。

生得

842 无向图 的 连通 分量和 生成 树

在 对 无向图进行 遍历 时 ,若是 连通 图 , 仅 需调用 遍历 过 程(CDFS 或 BFS)

一 次,从 图 中 的任 一 顶点出 发 便 可以 遍历图中 的 各 个 顶点。若 是非连通图,

训 末讲解

则 需 多 次 调用 遍历 过 程 , 每 次调用得 到 的 顶点 集 连同相 关 的 边就构成了图 的 一 个 连通 分 量 。

设 G=(V, 已)为连通 图 , 则 从 图 中 的任 一 顶点 出 发 遍历 图时 必定 将 ECG)分成两个集合

工筷,其中工 是 遍历图过 程中走 过 的 边 集合,B 是 剩余的边集合:TB=,TUB=

下 (G)。显 然,G' 一(V,T)是G 的 极 小连通 子 图 ,即 G'是G 的 一 棵 生成树 。

由 深度 优先 遍历 得 到 的 生成树称 为 深度优先 生成 树(DFS tree)。在深度优先遍历中,

如 果 将 每次“前 进”( 纵 向 ) 路 过 的 (将 被访问 ) 顶 点和 边 都记录 下 来 ,就 得 到 了 一 个 子 图 ,该 子

图 为以 出 发 点 为根的树 ,就 是 深度 优先 生成 树。相 应 地 ,由 广度 优先 遍历 得 到 的 生成树称 为

广度优先生成树(BFS tree)。

这 样 的 生成树由 遍历 时访问 过 的 ”个 顶点和 换历时经 历 的

(一1)条边组成。

对 于 非 连通 图 ,每个连通 分 量 中 的 顶点 集和 遍历时 走 过 的 边

一 起 构成一棵 生成树 ,各 个 连通 分 量 的 生成树组 成 非连通 图 的 生

成森林 (spanning forest)。

【例8.11〗

对 于 如 图 8. 24 所示 的 图 G,画 出 其 邻接 表 存 储

结构 ,并 在 该 邻接表 中 以 顶点 3 为 根 画 出图G 的深度优先生成树

和广度优先生成树 。

图 8.24 无向图 C

BE

图 G 的 邻接表如图8. 25 所 示 (注 意 , 图 G 的 邻接表 不 是 唯一 的 ) 。对 于 该邻接表,

从 顶点 3 出 发的深度 优先 遍历 过 程如下 :

3 -一0 -一] -一4

闪

5 一 2 一 6-一7 一 10

S

9

280

一| 2 |3 | 入

一| 4 二5 | 入

| 3 盖| 5 | 王下 6 |从

一| 2 |7 | 人

盖| 2 | 八

| 了 二8 | 王下 9 |从

| 6

一| 10 | 八

0 | 评

1 |三

2 | 歼

3 | 克

| 1

一| 0

一| 0

一| 0

4

| 再 | 本1和

5 |

6 | 亚

7 | 丈

一| 1

一| 2

一| 3

8

9

| 束 | 汪 二 6|人入

|两 | 滞 6 |从

10 | 二 二 7 |入

图 8.25

图 G 的邻接表

将两个 顶点 之 间 的 一 条 连 线 构 成深度 优先 生成 树 的 一 条 边 , 因 此 对 应 的 深度 优先 生成

树 如 图 8. 26(Ca)所示 。

从 顶点 3 出 发 的 广度 优先遍历 过 程如 下 :

3 一一0 一] -一4

NS 一一5

ec
,

7 一一 10

同样,将两个 顶点 之 间 的 一 条 连 线 构 成广度 优先 生成 树 的一条 边 , 因 此 对 应 的广度 优先

生成树如图 8. 26Cb)所示 。

@

@

已 包

加 大Ge

NGNNOG

GD

知名

GO

GD 0

(a) 一 棵深度优先 生成 树

Cb) 一 棵 广度 优先 生成 树

图 8.26

图 G 的生成树

843 普里姆算法

普 里 姆(Prim) 算 法 是 一种构造性算法。假设G=(V,E)是一个具有守 个顶点的带权连

通 图,T=一(U,TE)是G 的 最 小生成树,其 中 口是了 的顶点集,TE 是 工 的 边 集 , 则 由 G 构造

从 起 始点呈 出发的 最 小生成 树工 的步骤如下 :

(1) 初始化DU一 (以 ”到 其他 顶点 的所有 边 为 候选边 。

281

数据 结构 教程

虹 第人5 【版

(2) 重复 以 下步骤 (一1) 次 ,使 得 其 他(2 一1) 个 顶点 被 加 入 到 U 中。

@ 从 候选边中 挑选权 值 最 小 的 边加入TE, 设 该 边在V 一 U 中 的顶点是&,将上 加 入 口中;

@) 考查 当前 V 一 U 中 的所有 项 点 7 汤,修改 候选 边 , 若(&,7 的权 值 小于原来和顶点 7 关

联的候选边, 则 用 (, 力 取代 后者作为 候选边 。

计算机科学家简介

Robert Clay Prim(1921 年出生) ,美国 数学家和 计算机 科学 家 ,

1941 年 获得电气 工程 学士 学 位, 1949 年 从普林斯顿

大 学 获得 数学 博士 学 位。在第二次 世界 大 战(1941一

1944年)期间, 他担任通用电气 工程 师 。1944一1949

年 ,他 受聘于美国 海军 军械 实验 室担 任 工 程 师, 后 来

成为数学家 。1958一1961 年 ,他 在 贝尔实验 室 时担任

数学研究部主任,1957 年 提出 了 Prim 算法。

打扫

人

对 于 图 8. 27 所 示 的 带权 连 通 图 ,假设起始点为顶点 0, 采 用 Prim 算法构造最小生成树

的 过 程如下 :

28

10,

5

51) 首先的最小生成树 工 仅 包 含所有 的 顶点,如 图 8. 28(a)

所示。

在这两个顶点集之间选
(2) U={0),V一U=11,2,3,4,5,6),

1
四 择第 1 条 最小 边(0,5)添加到工 中 ,如图8.28(b)所示。
12

在这两个顶点集之间选
(3) U={0,5)V 一U=(1,2,3,4,6},

择第 2 条 最 小 边(5,4)添加到工 中 ,如图 8.28(c)所示 。

图 8. 27 ”一 个 带 权连通图

(4) 依 此 类 推,中 间 步又如 图 8. 28(d)

一(g)所示 ,直到 U 中包含所

有 的 顶点 ,这 样 一共 选择了 6 条 边 ,产生 的 最 小 生成 树 为图8. 28(g)。

ORG

中

加 品

ORG

(a) 仅包含所有项点

(b) 选择第1条边 (0,5)
图 8.28 用 普 里姆算法 求解 最小 生成 树的过 程

282

(g)选择第6条边

(1,6)

图 8.28

( 续 )

283

数据 结构教程

(第【5 【版

从 上 例 可 以 看 出,Prim 算法 是 一种增 量 算法 ,一步 一步地 选择 最 小边, 并 在 U 集合中

添加 相应 的 顶点,每一步都是从U 和 一U 两个顶点 集合 中 选择 最小 边 ,而 且 每 一 步都 是

在 前 面的基础 上进行的。

下 面的Prim(g,v)算法利用上 述 过 程 来 构造 最 小 生成树,其中 参数 g 为邻接 矩阵、 为

由于 Prim 算法 中 需要 频繁地取 一 条 条 边 的权 , 所以图采用 邻接矩阵更合适 。

Prim 算法 中 的 候选 边 是指

集合OU 和 YVY 一 U 之 间 的所有 边 ( 称 为QU 和 V 一 CU 两个顶点集

合的割集) ,如 果 把 这 些 边都保存 起来是非常 消耗空间 的 ,实际 上 考虑 候选边 的目的 是求U

和 YV 一 U 之 间 的 最 小边( 指权 最小 的 边) 。 为 此 只 考虑 V 一 U 集合 的 顶点 (因为 两个顶点 集

之间 的 边 是 无向边) ,建立两个数组 closest 和 lowcost,用于记录 V 一 U 中 顶点 了 到 U 中项

点的最小边。

Cllowcost[l=0)

closest[ 站=大

广 Ulowcostz0) 对于V 一 吕 中 的 一 个顶点 7), 它 的 最小边对 应 DT
中 的 某 个 顶点 ,用 closest[L7门保存U 中 的 这 个 顶点,

如图 8. 29 所 示 ,顶点了的 最 小边对 应 U 中 的 顶点

&, 有 closest[ 门一&, 并 且用 lowcost[让存储该 最小

边 的 权。也 就 是说,这 样的最 小 边 为(closest[L7 门,7)
边 ,对 应 的权 为 lowcostL门。

图 8.29 顶点 到 U 的 最小 边 的

那么如 何 确定 一 个 顶点属于 U 集合还是属于

存储 方式

V 一 避 集合呢? 这 里 的约定 是 若某个 顶点 守 有

lowcost[让=0, 表示iEU; 若 0 二 lowcost[i让二co

(或者 lowcost[i让天0) ,表示 iiEV一U。

初始时,U 中 只 有 一 个

顶点。对 于 所 有 顶点 守 这时 (ui)边就是 顶点大到 U 的 最小

边,置lowcost[让一 g. edges[v][Li] (没有 边时 为 co,u 到

为 0),closest[Li 一 ww。 由 于

lowcost[z]

已经被置为 0, 表示 它 添加到 U 集合中了 。

在 候选边中 求一条 最 小边的 过 程 是 扫描 V 一 U 中 的所有 顶点) ,通过 比较 lowcost 值求

就是最小边,输出这条最小边,并将顶
出 最小 lowcost 值对 应 的 顶点 &,那 么(closest[LA],)

点 不 添加到避 中 , 即置lowcost[LA]一0。

接着 做 调整 ,也 就是修改 候选 边,也 仅仅 考虑V 一 U 集合的顶点 。 对 于 JEV一U(C即

lowcost[让!=0) ,在 上一步(顶点& 还 没有添加 到 U 中 时 )lowcost[

让保存的是顶点7 到 U

中 顶点 closest[L

门的最小边 ,而 现在 U 发 生 了 改变(改变是仅仅在U 中 增加 了 顶点 &) ,所以

门小,选择(&,力作为新
需要将原来的lowcost[让与 g. edges[A][门进行比较 ,如 果 g. edges[R][

的最小边 ,即置lowcost[让王 g.edges[LA]L

门,closest[L门一&,否则顶点7的候选边不改变。

对 应 的 Prim 算法如下 :

void Prim(MatGraph g,int v)

{

int lowcostLMAXV] ;

int MIN;

int closestLMAXV] ,i,j,k;

for (i=0;i<g.nii十十)

{

lowcost[癌二 g.edges[v] 口 ;

//给 lowcost中和 closest 门 置 初值

284

EEEE

OA

closest[品一 v;

)》
for (ji 一1;i<g.n;i十十)

(1

MIN=INF;
for Gj王0;j<g.njj十十)

// 找 出Cn 一 1) 个 顶点

// 在(V 一 U) 中 找 出离 U 最 近 的 顶点上

让 (lowcost[D] !一0 &&& lowcostD]< MIN)

MIN=lowcostD] ;
上 一 j;

{

)》

/人 记录 最 近 顶 点 的 编号

printf(" 边 (%d, %d) 权 为:%dNvn" ,closest[kg ,k,MIN);

// 输 出 最 小 生成树的 一 条 边

lowcost[国一0;

// 标 记 k已经加入 U

for Gj=0;j<g.n;j十十)

// 对 (V 一U) 中 的 顶点 j 进行 调整

让 (lowcost[ 门 !王0 && g.edges[k] [站< lowcostD门)

lowcost[丫=g.edges[N 中 ;
closest[让一 k;

//修改数组 lowcost 和 closest

{

】}

)}

Prim()算法中有两重 for 循环,所以 时间 复 杂 度为O(吧) ,其中7 为图的 顶点 个 数。大

家 可以 看 出,Prim() 算 法 的 执行 时 间 与图中 的 边 数 。 无关, 所以它 特 别 适 合用 稠密 图 求 最小

生成树。

844 克 鲁 斯 卡尔算法

克 鲁 斯 卡尔(Kruskal) 算 法 是 一种按权 值 的递增 次 序选择 合 适 的 边来构造 最小 生成 树

的 方法。假设G=(V,已)是一个具 且 个 顶点 的 带权 连 通 无 向 图,T=(U,TE)是G 的 最小

生成树, 则 构造 最小 生成 树 的 步 又 如 下 :

(1) 置U的 初 值 为V(即包含有G 中 的 全 部顶点 ),TE 的 初 值 为 空 集 ( 即 图 工 中 的 每 一

顶点 都 构成 一 个 分量) 。

(2) 将图G 中 的 边 按 权 值 从 小 到 大 的 顺序 依次选取 , 若选取 的 边 未 使生成树 工 形成回

路,则加入 TE, 和 否则 舍弃 ,直到 TE 中 包含(” 一1) 条 边 为止。

对 于 图 8. 27 所 示 的 带 权 连 通 图 ,采用 Kruskal 算法 构造 最 小 生成 树的过 程如 下 :

(1) 将所有 边 按 权 值 递增 排序 ,其 结果 如 图 8. 30(a)所示。图 中边上 的 数字 表示 该边是

第 儿小 的 边 ,如 1 表示是最小的边,2 表示 是 第 2 小 的边 ,依此 类 推 。

计算机科学家简介

Joseph Bernard Kruskal(1928一2010 年) ,美国数学 家 ,统计学家和

计算机科学家 。1954 年 获得普林斯顿大学博士学

扫-扫

位。当 克 鲁 斯卡尔还是二 年级的 研究生时 ,他发明了

产生 最 小 生成树的 算法 ,当时

他 甚至不 能 肯定关于这

个 题目的 两 页半 的论文是否 值得发表 。除 了 最 小 生

成 树 之 外 , 克 鲁 斯 卡尔还 因对 多维分析 的 贡献 而

著名。

数据 结构 教程

眶 第 5 人乒

(2) 首先的最小生成树工仅包 含所有 的 顶点 ,如 图 8. 30(b)所示。

(3) 选取 最小 边(0,5) 直 接加 入 到 工 中 ,此 时 不 会 出 现回路 ,如 图 8. 30(c)所示 。

(4) 选取第 2 小 的 边(2,3) 直 接 加 入 到 工 中 ,此 时 不 会 出现回路 ,如 图 8. 30(d)所示。

说明: 在 采用 Kruskal 算法 构造 最 小 生成树时 ,前面 的两条 边 可以 直接 加 入 到 下 中 , 因

为只有 两 条 边 的 图不可 能 存在 回路 。

(5) 选取第 3 小 的 边(1,6),加入到 工 中 不 会 出现回路 ,将 其加入,如 图 8. 30(e)所示。

(6) 选取第4 小 的 边(1,2) ,加 入 到 T 中 不 会出现 回 路 ,将 其加入,如 图 8. 30(f)所示 。

(7) 选取第 5 小 的 边 (3,6) ,加 入 到 工 中 会出现 回路 ,舍弃它。选 取 第 6 小 的 边(3,4),

加 入 到 丰 中 不 会 出现回路 ,将 其加入,如 图 8.30(Cg)所示 。

(8) 选取第 7 小 的 边 (4,6) ,加 入 到 工 中 会出现 回路 ,舍弃它。选 取 第 8 小 的 边(4,5),

(a) 按 权值 递 增 排序的 结

人) 仅包含所有项点

DO Oo

Geoogj oO

2

ORG

(CO) 选择第1条边
加 癌

gj

3

g@

人) 选择第5条边

人) 选择第6条边

图 8. 30 用 克 鲁 斯卡尔 算法 求解最小 生成树的 过 程

286

DOOR

加 入 到 工 中 不 会 出现回路 ,将 其加入,如 图 8.30(h)所示。

这 样一共 选 择了 6 条 边 , 产 生 的 最小 生成 树 为图 8. 30(h)。 从 中 可以 看出,这 里

Kruskal 算法和 Prim 算法 的 求解结果 相同 。实际 上 , 当一个图有多 个 最小 生成 树时 ,这 两

个 算法 的 求解结果 不 一 定是相同 的 。

下 面的Kruskal(g) 算 法利用 上 述 过 程来构造 最小 生成树 ,其中 参数 g 为邻接 矩阵 。和

Prim 算法 一样 ,在 该 算法 中 需要 频繁地取 一 条 条 边 的权, 所以 图 采用 邻接矩阵 更 合适 。

设计 Kruskal 算法 的 关键 是如何判断选取 一 条 边(Gi, 力加 入 到 工 中 是 否出现回路,可 以

通过 判断 顶点 7 是 否 属于 同一个连通 分 量 的 方法 来 解决。

为 此 设置 一 个 辅助数组 vset[0..2 一1],vset[ 革 用 于 记录 一 个

顶点站所 在 的连通分量编

门王7所有顶点的连通分
号。初 值时 每个顶点 构成 一个连通 分 量,所 以 有 vset[L计 =ivsetL7

量 编号等于 该顶点 编号) 。 当 选中(i,7 力 边时 ,如 果 顶点7 的 连通 分 量 编号相同,表示 加 入

后 会出现 回路 ,不 能加入; 和 否则 表示 加 入 后 不 会 出现回 路 ,可以加 入 ,然后将 这 两个顶点 所

在 连通 分量中 所 有 项 点 的 连通 分 量 编号 改 为相同 ( 改为vset[详或者vset[L7均可) 。

例如 ,对 于 如 图 8. 31(a) 所 示 的 带权 连通 图 (所有 边 按权 值递增 排序),采用 Kruskal 算

法 构造 最 小 生成 树的过 程如 下 :

(1) 首先的最小生成树 工 仅 包含所有 的 顶点 ,如 图 8. 31(b)所示 ,顶点劳边的数字为该

顶点的连通分量编号。

(2) 选取最小边(0,3) ,顶点 0、3 的 连通 分 量 编号分别为 0.3,两者不相同,表示加入到

G@),

(b) 仅包含所有项点

@),

(9) 选择第1条边

(e) 选择第3条边 : 选(2,0) 边时 出现 回路

图 8.31 判断加 入 一 条 边 是 否 出现回路

287

数据 结构 教程

[第! 5版

下 中 不 会 出 现 回路 ,将 其加 入 ,并 将 顶点 0、3 合并 后 的 连通 分 量 中所有 顶点 的 连通 分 量编号

改 为0, 如 图 8.31(c)所示。

(3) 选取第 2 小 的 边 (2,3), 和 (2) 相 类似 , 将 其加入,如 图 8.31(d)所示。

(4) 选取第 3 小 的 边 (0,2) ,顶点 0、2 的 连通 分 量 编号 都是 0, 两 者相同 ,表示加入到 工

中 会 出 现 回路 ,舍弃它。选 取 第 4 小 的 边(0,1) ,加 入 到 T 中 不 会 出 现 回路 ,将 其加 入 ,如

图 8. 31(e)所示。

另外,用一个数组E[]存放图 G 中 的所有 边 ,要 求 它们 是 按权 值 从 小 到 大 的 顺序 排列

的 ,为此先从图 G 的 邻接 矩阵中 获取 所 有 边 集 已,再 采用 直接 插入 排序法对 边 集 下 按权值

递增 排序。克和鲁 斯卡尔 算法如 下 :

typedef struct

{人 int ui

int vi

int w;

} Edge;

// 边 的 起 始 顶点

// 边 的终止顶点

//边的权值

void Kruskal(MatGraph g)

// Kruskal 算法

{

intij,ul,vl,snl,sn2,k;

int vsetLMAXV] ;

Edge E[MaxSize];

kk一 0;

// 存 放 图 中 的所有 边

//e 数组 的下标从 0 开始 计

for (i一0;i<g.nii十十)

//由g产生边集 下 ,不 重复 选取同一 条 边

for (j王0;j < 一 ij 十十)

让 (g.edges上 口中 !一0 && g.edges中中 ! 王INF)

{

下 [D.u=iE[k] .v一j;E[Lk] .w 一 g.edges[ 口;

上十十;

}
JInsertSort(E,g.e) ;

// 采 用 直接插入 排序 对 下 数组按权 值递增排序

for (i一0;i<g.ni;i十十)

// 初始化 辅助数组

vset[丫一 i

一 1;
j一0;

/人 表示 当前 构造生成 树 的第几 条 边 , 初 值为1
//E 中 边的下 标 , 初 值为0

while (k< g.n)

// 生 成 的 边 数小于nm 时 循环

人

u=ED.uiv=ED.v;

// 取 一 条 边 的 两个顶点

snl一vset[ul] ;

sn2一vset[v]1] ;

让 (snl!一sn2)

// 分 别 得 到 两 个 顶点 所 属 的集合 编号

// 两 顶点属于 不 同 的 集合 ,该边是 最小 生成树的 一 条 边

BE

{

printf(" (中 d,%d):%dvn"
k 十十 ;

// 生 成 边 数 增 1

ul,vl,ED门.w); // 输 出 最 小 生成 树 的 一 条 边

for (i=0;i<g.nii 十 十) // 两个集合 统一 编号

if (vset口二 =sn2) “ // 集 合编号为sn2 的 改为snl

vset[j中一 snl;

j 十 十 ;

// 扫 描 下 一 条 边

288

DOOR

如 果 给 定 的 带权 连通图 G 有 ?7 个 顶点.e 条 边 ,在 上 述 算法 中 ,对 边 集 已 采用 直接 插入

排序的时间复杂度 为O(e:)

。while 循环是在 e 条 边 中选取 (" 一1) 条 边 , 而 其 中 的 for 循环

执行 对 次,因此 while 循环的时间 复 杂 度为O(巡十 e) 。 对 于连通无 向图,e三(2一1) ,那么

用 Kruskal 算法 构造 最小 生成 树 的时间 复 杂 度为O(e) 。

可 以 对 前面的Kruskal 算法 进行 两 方面 的 改进,其 一是将 边 集 排序 改为堆 排序 (将 在 第 10

章中介绍); 其 二 是采用第 7 章 介绍 的 并 查 集 进行连通 分 量 合并 , 先 通过MAKE_SET(z,z)进

行 并 查 集 树 的 初始 化 ,即 每个顶点 作为 一个分 离集合 树 ( 其编号 为 该 顶点 的 编号) ,当选 择 一

条 边(x,o)时,求出ws 顶点 所 在 分 离集合 树 的编号 , 若 不 同 则 将 顶点 x 和 项点 v 所 在 的 分
离集合 树 按 秩 合并。改 进的Kruskal 算法如下 :

void Kruskal(MatGraph g)

// 改 进的Kruskal 算法

{

intij,k,ul,vl,snl,sn2;

UFSTree tLMaxSize] ;

Edge ELMaxSiza] ;

一 1;

//e 数 组 的 下 标 从 1 开始计

for (ji一0;i<g.nii十十)

//由g 产 生 的 边 集 下

for (j王0;j < 一 ij 十十)

让 (g.edges[丫中 !=0 必 & g.edges 口 中 !=INF)

(1 E[.u=iE[g.v=一j;E[I.w

一 g.edges[口D;

k十十;

)》
HeapSort(E,g.e);

// 采 用 堆 排序对 王 数组按权 值递增 排序

MAKE_SET(t,g.n);

// 初 始 化并查 集树t

上 一 1;

j=1;

while (k< g.n)

1

u=ED.u;

v1王ED].v;

/信表 示 当 前 构造 生成树的 第 几 条 边 , 初 值为1

//正中 边 的下标从 1 开始

// 生 成 的边数小于mn 时 循环

// 取 一 条 边 的 头尾顶点 编号ul 和 v2

snl一FIND_SET(t,ul);
sn2一FIND_SET(t,v1);

// 分 别 得 到 两个顶点 所 属 的集合编号

让 (snl!一sn2)

// 两 顶点属于 不 同 的 集合 ,该 边 是 最 小 生成树的 一 条 边

printf(" (中 d, 中 d) :中 dvn'ul,vl,ED.w);
k 十十;
UNION(Ct,ul,vl);

// 生 成边数增 1
//将ul 和 Yvl 两个顶点 合并

{

)》

和 十 5

// 扫 描 下 一 条 边

)}

如 果 给 定 的 带权 连 通图G 有 ?7 个 顶点.e 条 边,上述改进的Kruskal算法中不考虑生成

边 数组 忆 的 过 程 , 堆 排序 的 时 间 复 杂 度为OCelogxe)

。while 循环是 在 e 条 边 中 选取(一1)

条 边 ,其中的 UNION ()

的执行时间为O(logsz), 因此 while 循环 的时间 复 杂 度 为

O(elogsz) 。 对 于连通无 向图,e*一1,那 么 改进的Kruskal 算法 构造 最小 生成 树的时间 复

杂 度为O(elogse)。可以 看 出,Kruskal算法的执行时间仅与图中 的 边 数 有 关 , 与顶点数无

关 , 所以 它特别 适合 用 稀疏 图 求 最小 生成 树 。

289

数据 结构教程

[第! 5版

【例8. 12〗 有 如 图 8. 32 所示的 一 个 带权 连通 图 ,在 求其最 小 生成 树时 ,问 (0,2)、

(0,3)、 (1,2)和 (2,3)这 3 条 边 中哪些可能是 Kruskal 算法 第 2 次选中但不是Prim 算法 (从

3 开始)第 2 次选中的边。

在 采用 Kruskal 算法 求 最 小 生成树时 首先 选中权 最小

的 边 (0,3),第 2 次 选中时有 3 条 边 的权 相 同 的 次小 边,可以 从

和(1,2)边中任选一条。
(0,2)、(2,3)

采用 Prim 算法(从 3 开始 ) 求 最小 生成树 ,首先 U 王 13} ,第

1 次 选中(3,0)边。修改U=13,0),V

一U=11,2)} ,第 2 次 只 能

图8. 32 ”一 个带权 连 通图 在 这 两个顶点 集之间选中 一 条 最 小 边,可以 是 边(0,2) 或 者

(2,3) ,不 可 能 是 边(1,2) 。

最 短路 径

851 路径 的概念

在 一 个 不 带权 图 中 , 若 从 一顶点到另一顶点 存在 着 一条 路径, 则 称 该 路

径 长度为 该 路径上 所 经 过 的 边 的 数目 , 它等于 该 路径上 的顶点数减 1。由

于 从 一 顶点 到 另 一 顶点 可 能 存在 着 多 条 路 径 ,每 条 路径上 所 经 过 的 边 数 可

能 不 同 , 即 路 径 长 度 不同,把 路 径 长度最 短 (即 经过的边数 最少) 的那 条 路 径 称 为 最短路 径

(shortest path) ,其 长度称 为最短路 径 长 度或最 短 距 离 。

对 于 带权 图 ,考虑 路径上 各 边 上 的权 , 则 把 一 条 路径上 所 经 边 的 权之和 定义 为该路 径 的

路 径 长 度 。从 源 点 到 终点 可 能 有 不 止一条 路 径 ,把 路 径 长 度 最小 的那 条 路 径 称 为 最 短路 径 ,

其 路 径 长 度 (权之和 ) 称 为最短路 径长度 。

实际上 ,只 要 把 不 带权图上 的 每条边 看 成 是权 值为 1 的边,那 么 不 带权图和 带权 图 的 最

短路径和 最 短 距 离 的定义 就 一 致了。

求 图 的 最 短路径有 两 个 方面 的问题 ,即 求 图中某 一 顶点 到 其 余 各 顶点 的 最 短路径和 求

图 中 每一对 顶点 之 间 的 最 短路 径 。

852 从 一 个顶点 到 其 余 各项 点 的 最短路径

问题: 给 定 一 个 带权 有 向 图 G 与 源 点 ,求从 源 点品到 G 中 其他 顶点 的 最 短路 径 , 并 限

定 各 边 上 的权 值大于 0。

PE

采用 狄 克 斯 特拉(Dijkstra) 算 法 求解,其 基本思想 是 ,设 G 一(V,尼)是

一 个 带权 有 向 图 ,把图中 的 顶点 集合 V 分 成 两组,第 1 组 为 已 求出最 短路径

的 顶点 集合 (用 S 表示 ,初始时 S 中只有 一 个 源 点 ,以 后 每 求 得一条 最 短路

径 mw ...、\z% ,就将顶点& 加 入 到 集合 S 中 ,直到 全 部 顶点 都加入到 S 中 ,算法

就 结束了 ) ,第 2 组 为其余 未 确定 最 短路 径 的 顶点 集合 (用 U 表示) , 按 最 短

路 径 长度的 递增次 序 依次 把第 2 组 的顶点加入S 中。

290

计算机科学家简介

ESASJ国 |

Edsger Wybe Dijkstra(1930年一2002 年) ,荷兰计算机 科学家 ,

毕业 就 职于 荷兰菜顿大学 ,早年 钻研 物理 及 数学 ,而 后 转 为计算 学 。

于 1972 年获得计算机 科学 界 最 高奖一一 图灵 奖 ,还 获得 过 1974 年

AFIPS Harry Goode Memorial Award 1989 年 ACM SIGCSE 计算机科

学 教育 教学杰出 贡献奖 ,以及 2002 年 ACM PODC 最 具影 响 力论

文奖。

他曾经提出“GOTO 有 害论 “信号量和 PV 原语 ,解决了有趣的

“哲学 家 就 餐问 题”, 提出了 目前应用广泛 的 最 短路 径 算法 。

Dijkstra 算法 的 具体步骤 如 下 :

(1) 初始时 S 只包含源点,即S={z》,源 点 立到自己的距离 为0。U 包含除源点 以外

的 其 他 顶点 , 源 点立到 UL 中任 一 顶点; 的 最 短路 径长度 为边上 的权 ( 若 源 点 v 只 ; 有边

<v,i>)或co (若源点vc 没有边) 。

(2) 从 U 中选取一个顶点wx ,使 源点vcv 的 最 短路 径长度 为 最 小,然后把 顶点 w 加入

S 中。

(3) 以 顶点 " 为 新 考虑的 中 间点 ,修改 源 点 上 到 避 的最各路

中 所 有 顶点 的 最短路 径长度 , 称 之为路 径 调整 ,其 过程 ”径, yt 机 务字

如图 8. 33 所 示 ( 图 中 顶点 之间 的 实 线 箭头 表示 边 ,虚线
箭头 表示 路 径) ,对 于 U 中 的 某 个 顶点 7 在 没有考虑 中
间点 时,假设求得从源点"号7 的一条 最 短路径为 "的最敌路径,长 度为cy

人
GO 一-

(maJ),其最短路径长度为 cv (如 果 没有这 样 的最 图 8.33 从 源 点 到 顶点 7 的
短路 径,cs = co) ,而 从 源点吃w 的一条 最 短路径为

路 径 比较

(aa),其最短路径长度为cv。 现在考虑 中间点 w,

假设从源点vs27 存在 另 一 条 经 过 顶点 x 的 路 径 (其中 顶点 wx 到 顶点) 有 一 条 边),其路径长

度为 cw 十 zw。 这样在考虑中间点wx 以 后,从源点vc>7 有 两 条 路 径 ,

"* 不经 过 顶点 x 的 原来的最 短路径 ,路径长度为cv 。

显然,在考虑中间点 wx 以 后,从源点vc27 的 最 短路 径 是上述两条 路径中 的 较 短 者。也

就是说,源点vc27 的 最 短路 径 长 度 调 整为MIN{cw十zu ,cv )。

(4) 重复步骤 (2)和 (3) ,直到 S包含所有的顶点 。

和 求 最小 生成树的 算法 一 样,Dijkstra 算法 中 需要 频繁地取 一 条 条 边 及 其权 值,所以 图

aa

采用 邻接矩阵 更 合适。用 一 个 一 维 数组 dist 存放 最 短路 径 长 度 , 如 dist[门表示源点uc

的 最 短路 径 长 度,其 中 源 点 是 默认 的 ,那么如 何存放 最 短路径呢 ?

从 源点习 到 其 他 顶点 的 最短路径有7 一1条 ,一 条 最 短路 径 用 一 个 一维数组 表示 ,例如

从 源 点 0 号5 的 最短路径 为 0.2、.3、5,表示为pathL5]={10,2,3,5)。 所有 7 一 1 条 最 短路径

可以 用 二 维数组 path 存储 。但 这 里 是 用 一 个 一 维 数组 path 来 存储 "一1 条 最短路径的,这

样 是如 何实现的呢? 先 看以下命题。

291

数据 结构 教程

虹 第人5 【版

命题: 若 从 源 点 到 某 个顶点7 的 最短路径是

(ww,...:,a,...

,xz 7) ,也 就是说 ,在 源 点 vc号

7 的 最短路径上顶点7的 前 一 个 顶点是wx ,那么其中 的(w,...,a,...'z0)

一定是源点vcx 的最

短路径。

这 个 命题 可以 采用 反 证 法 证 明 ,假设

(w,...,a,...,x,力是源 点 到 顶点 7 的 最短路径,

但Co,...,a,...,z0)不是源点vcx 的 最短路径。由 于 (u,...,,a,...,z)不是源点vcx 的 最 短

路径 ,设源点w 字 xz 的 最短路径为Co ,02z) ,如 图 8.34 所示 , 则 (om,0, ,zx 四 是 一

更短的新路径 ,与前面的假设矛盾 ,命题得证。
条比(o...,a,......x7)

借助上述命题,用 path[L门存放源点vc) 的 最短路径上顶点7的 前 一 个 顶点 编号 ,其 中

源点才 是 默认 的。例 如 从 源 点 0 史 5 的 最短路径为0.2、.3.5,

则最短路径表示为pathL5]一3,

path[3]

王2,pathL2]王0。当 path 求 出后 ,通过 反 推 求出从 源 点 到 每一个 顶点 的 最短路径。

再看一下图 8. 33 , 求源点vc7 最 短路 径时 ,不经过顶点 x 的 原来 的 最 短路 径 表 示 为

path[ 让 =a ,而经 过 顶点 x 的 路 径 若 是 最 短路 径 ,该路径 表 示 为 path[门=vw。 所以 ,在 考虑

中 间点 x 以后,dist[ 门二MIN{tdist[z]
path[ 门一ww, 否 则 不 修改 path[让。

十 zwo ,dist[7

让},若经过顶点 v 的 路 径 更 短 , 修 改

例如 ,对 如 图 8. 35 所示的 带权 有 向 图 采用 Dijkstra 算法求从顶点 0 到 其 他 顶点 的 最 短

路径 ,并 说 明 整 个计算 过 程 。

图 8.34 反 证 法示意图

图 8.35 一 个 带权有 向 图

源点0到其他
(1) 初始化: S={10),U 一11,2,3,4,5,6) ,dist[] 一40,4,6,6,co,co,co}(

各 顶点 的权 值,直接 来 源 于 邻接 和 矩阵) ,path[] 一10,0,0,0, 一1,一1, 一1})( 若 源 点 0 到 顶点

有 边< 0,z >, 它 就是当前 从 源 点 0 ci 的 最 短路 径 , 且 最 短路径上 顶点 守 的 前 一 个顶点是源

点 0, 即置path[计=0; 否则置 path[ 计 = 一 1, 表 示 源 点 0 到 顶点字没有路 径 ) 。

(2) 从 U 中 找 最小 的 顶点 ( 即

dist 值 最 小 的 顶点 ) 为 顶点 1, 将 它 添加到 S 中 ,SS一

{0,1),U

一(2,3,4,5,6} ,考查 顶点 1 ,发现从顶点 1 到 顶点 2

和 4 有边:

二1)一5(修改)
dist[L2]=MIN{distL2],dist[L1]

dist[L4]

王MIN{distL4] ,dist[L1]十7}一 11(修改)

则 dist[]=40,4,5,6,11,co,co},在 path 中 用 顶点 1 代替 dist 值 发生修 改的顶点,path[ ] =

一1,一1)。
{0,0,1,0,1,

(3) 从 U 中 找 最 小 的 顶点为顶点 2, 将 它 添加 到 S 中 ,S={0,1,2),U

一(3,4,5,6},考

查 顶 点 2,发现从顶点 2 到 顶点4和 5 有边:

dist[L4

王MIN{distL4] ,dist[2]十6}一11

dist[L5]=

十4}一9(修改)
王MIN{dist[5],dist[2]

则 dist[ ={0,4,5,6,11,9,co),在path 中 用 顶点 2 代替 dist 值 发生修改 的 顶点,path[ ] 王

292

DOOR

{0,0,1,0,1,2,一1)。

(4) 从 U 中找 最 小的顶点 为 顶点 3, 将 它 添加到 S$

一(4,5,6),考
中 ,S={10,1,2,3),U

查 顶 点 3,发现从顶点 3 到 顶点 2

和 5 有 边 ,由于顶点 2 已经考查 过 ,不 进行 修改 :

十5}一9
dist[L5]王MIN{distL5],distL3]

没有 修改 ,dist

和 path 不变 。

(5) 从 U 中找 最 小的顶点 为 顶点 5, 将 它 添加到 S$

一(4,6),考
中 ,S={10,1,2,3,5),U

查 顶 点 5,发现从顶点 5 到 达 顶 点4和 6 有边:

,distL5]十1}一10(修改)
dist[L4 王 MIN{distL4]

十8}一17(修改)
dist[L6]王MIN{distL6],distL5]

则 dist[]=40,4,5,6,10,9,17},在 path 中 用顶点5 代替 dist 值 发生修改 的 顶点 ,path[ ] 一

{10,0,1,0,5,2,5)。

一(6),考
(6) 从 U 中找 最小 的 顶点为顶点 4, 将 它 添加到 S 中 ,S=(10,1,2,3,5,4),U

查 顶 点 4 ,发现从顶点 4 到达 顶点 6 有 边 :

十6}一16(修改)
dist[L6]王MIN{distL6],dist[4

则 dist[j={0,4,5,6,10,9,16},在path 中 用顶点4代替 dist 值 发生修改 的 顶点,path[ ] 王

{0,0,1,0,5,2,41}。

(7) 从 U 中找 最小 的 顶点 为 顶点 6, 将 它 添加到 S 中 ,S==10,1,2,3,5,4,6),U一()从

顶点 6 不 能 到 达任 何 顶 点

一10,4,5,6,10,9,
。S 中包含所有顶点,过 程 结 束,此 时 dist[]

16} ,path[]=40,0,1,0,5,2,4}。 上 述 过 程如 图 8. 36 所示 。

即该最短路径
(8) 输出 最 短路 径 ,这 里以 源 点 0 只 6 的 最 短路 径 进行说明 ,dist[L6]=16,

长 度为16 。path[6] 王4,path[L4] 王5,pathL5]

王2,pathL2] 王1,pathL1] 王0, 反 推出最短路

径 为 01 一 2一5 一 4->6。

从 源 点 到 所 有 其他 顶点 的 求解结果如下 :

从 顶点 0 到 顶点 1 的 路径长 度 为 :4 路 径 为:0,1

从 顶点 0 到 顶点 2 的 路 径 长 度 为 :5 路 径 为:0,1,2

从 顶点 0 到 顶点 3 的 路径长 度 为 :6 路径为:0,3

从 顶点 0 到 顶点 4 的 路 径 长 度 为:10 路 径 为:0,1,2,5,4

从 顶点 0 到 顶点 5 的 路径长 度 为 :9 路 径 为:0,1,2,5

从 顶点 0 到 顶点 6 的 路 径 长 度 为:16 路 径 为:0,1,2,5,4,6

从 以 上过 程可 以 看 出,Dijkstra 算法具有以 下特点 :

(1) 在 执行中,一 个 顶点 一 旦 添加 到 S 中 后 ,其 最 短路 径 长 度 不 再改变 。

(2) 正 是 由于 具有特点(1), 所以 Dijkstra 算法 不 适合 含有 负 权 值 的 带权 图 求 单源 最 短路

aa

径。通 过 一 个反例说明,假设一个含有 3 个 顶点 的 带权有向 图,<0,1> 的权值 为 1,<0,2 >

的权 值为2,< 2,1 > 的权 值 为 一 3, 如 图 8. 37 所示 。 若源 点为 0, 在 执行 Dijkstra 算法时首先

选取的中间点为1,求出源点 0 到 顶点 1 的 最短路径长度 为1,以 后 不 再 改变。而 实际 上 ,

0-2一1 才 是源 点 0 到 顶点 1 的 最 短路 径 ,其 长 度 为一1。

(3) 按 顶点 进入 $S 的 先后 顺序 最 短路 径 长 度 越来越长 ,例如 图 8. 35 所 示 的 各 最 短路径

的情况 如 图 8. 38 所示。

293

数据 结构教程

[第! 5版

3
[0

忆
1 2 3,4,,5, 6

0123456
0466momm

0123456
0.0 00-1-1-l

dist

path

{0,1}

{2,,3,4,,5,,6}

10,1, 吨

4,5,6

本
最 小 路径 长 度的 顶点 : 1
01234356
04 回 5贺=

卫

最 小 路径 长 度 的 顶点 :
01234356
04561I 回 “

2

下
最 小 路径 长 度的顶点 : 3

01234356
0 四 。o 回 -!-!
0

0123456
00101回:

10,1,2,3)}

人 5, 6

01234356
043561l9m

01234356
001012=

工
最 小 路径 长 度 的顶点 : 5

{0,1,2,3, 引 )

全, 时

0123456
0123456
0456 四 。 因 0010目:昌

10,1,2,3,5,,纯

16}

{0. 1 2 3, 5 4 0

全

一0一

最 小 路径 长 度的 顶点 : 4

0123456
0456109 国
还
最 小 路径 长 度的 顶点 : 6

01234356
001052牟

0123456
0435610916

01234356
00105214

图 8.37 ”一 个 带权有 向 图

图 8.38 源 点 到 各 个 顶点 的 最 短路 径 长 度 是递增 的

对 应 的 Dijkstra 算法如下(z 为 源点 ) :

void Dijkstra(MatGraph g,int v)

/VDijkstra 算法

{

int distLMAXV] ,pathLMAXV] ;

int SLMAXV] ;

int MINdis,i,j,u;

for (i一0;i<g.ni;i 十十)

//S加=1 表示 顶点 i在S 中 ,S吕 一 0 表示 顶点 i在U 中

{

dist 品一g.edges[v] 口 ;
SD丫=0;

// 距 离 初始化

//SD]置空

过 (Cg.edges[v] [上 口 <INF)

// 路 径 初始化

294

ES国 |

path[品一 v;

// 顶点v 到 顶点1i有 边 时 ,置顶点 i 的 前 一个顶点为

else

path品一一1;

// 顶点v 到 顶点i 没边时 ,置顶点 i 的 前 一个顶点为一1

}》
S[ 中 =1;path[ 中 =一0;
for (i一0;i<g.n一1;i 十十)

{

MINdis=INF;

// 源 点 编号v 放 和人 S 中
// 循环直到 所 有 项 点 的 最 短路 径 都求出

//MINdis 置最大 长度初值

for (j=0;j<g.n;j十十) //选取不在S 中 (即U 中 ) 且 具有 最 小 最短路 径长度的 顶点

ii(S四 ==0 && dist中<MINdis)

{

au=j;
MINdis=一distD ;

}
S[Jj=1;
for (=0;j<g.n;j十十)

让 (CS中 = 一 0)

// 顶点u 加 入 S 中
// 修 改 不在S 中 ( 即 U 中 ) 的 顶点 的 最 短路 径

这 (g.edges[由 [<INF && dist[由十 g.edges[uD 中 < dist[D)

dist中一 dist[由十 g.edges[uj 口 ;
path[站一 ui

{

)}

}
Dispath(g,

dist, path,S,v);

// 输 出 最短路径

)}

输出单源最短路径的 Dispath() 函数如下 :

void Dispath(MatGraph g,int dist[D] ,int path[] ,int SU] ,int v)

// 输 出 从顶点 出 发 的所有 最 短路 径

{

intij,k;

int apathLMAXV],d;

for (i=0;i<g.n;i十十)

这 (S四==1 && il一v)

// 存 放 一 条 最 短路 径 (逆向)及 其 顶点个数

// 循 环 输出从顶点 "到 i 的 路 径

{

printf(" 从 顶点中d 到 顶点 %d 的 路 径 长 度 为:贤 dNt 路 径 为 :",v,i, dist[);

d一0; apath[d中一i;

// 添加路径上 的 终点

k 一 path[;

让(k一 一 一1])

printf(" 无 路 径\n") ;

else

{

while (k!一v)

, d+十; apath[d] 一 k;

k 王 path[k];

{

}

// 没有路 径 的 情况

// 存 在 路 径 时 输出 该路径

d 十十; apath[吕一v;

// 添 加 路径上 的 起 点

printf("%d" ,apath[d]);

// 先输出起点

for G 一 d 一1;j> 一 0;j 一一)

// 再输出其他项点

printfC", %d" ,apathD] ) ;

printf(C"N\n") ;

)》

不考虑路径的输出,Dijkstra 算法 的 时 间 复 杂 度 为 002) ,其 中 为图中顶点的个数。

数据 结构教程

虹 第人5 【版

【例8. 13〗 有 人 这 样 修改Dijkstra 算法 ,假设源点 为w, 每 次从U 中 选取非 ==的 距离 最

大 的 顶点 v“ 添加到 S 集合中,然后以x 为 新考虑的中间点 ,修改 源 点 到 U 中 各顶点的距

离 ,调整 为 非=的 最 大 距离 ,重复上述 过 程 直 到 S包含所有的顶点。问 这 样 修改后的 算法

能 和 否 求出源 点 v 到 图 中 其他 顶点 的 最 长路径 ?

不 一 定 。下 面通过 一 个 反例 说 明 。

例如 ,对 于 图 8. 35 所 示 的带权 有 向 图 ,假设 源 点 为 0。 按 照上述修改后的Dijkstra 算

法 ,求解过程如下 :

(1) S={10),U

一(1,2,3,4,5,6}), 源 点 到 1~6 各顶点的距离 dist 王(10,4,6,6,co,co,

ce}。 从 避 中 选取 非 ==的 距离最大 的 顶点为2。

(2) S=(10,2),U

一 (1,3,4,5,6) ,顶点 2 到 顶点 4.5 有 边,所以调整 顶点 4 的最大 距离

为 12 ,调整 顶点 5 的最大距离为10,即 dist=10,4,6,6,12,10,=o}。 从 UL 中选取非<=的距

离最大 的 顶点为4。

(3) S=(0,2,4),U

一 (1,3,5,6) ,顶点 4 到 顶点6 有 边,所以 调整 顶点 6 的最大距离为

18,即 dist= 王(0,4,6,6,12,10,18}。 从 U 中 选取非 =c的 距离最大 的 顶点为6。

(4) S 王 10,2,4,6),U

一11,3,5) ,图中没有从顶点 6 出 发 的边 ,不 调整 。由 于 顶点 6 已

添加到 S 中 ,以 后 不 会再调整 ,也 就 是说 源 点 0 到 顶点 6 的 最 长 路 径 长 度为18。 而 实际上 ,

0一3一5一6 才 是 源 点 0 史6 的 最 长 路径,其 长 度为 19 。

这 样 反证了 上 述 修改 后的Dijkstra算法用于求源 点 到 图 中 其 他 顶点 的 最 长路径 不 一

定是可行的。

853 每对顶点之间 的 最 短路 径

问题: 对 于 一 个 各 边权 值 均大于 零 的有向 图 ,对 每 一对 顶点 ; 夫) 求出顶点 ;与 顶点 了

之 间 的 最 短路径和 最 短路 径 长度。

可以通过以 每个顶点 作为 源 点 循环 求 出 每对顶点之间的 最短路径。除 此 之 外 , 弗洛 伊

德(Floyd) 算 法 也 可 用 于 求 两 顶点 之间 的 最短路径。

计算机科学家简介

Robert W Floyd(1936一2001 年) ,他 从小 就被视为神童,年 仅

17 岁 就获得 芝加哥 大 学 文学 学 士 学 位,22 岁 获 得 物

打扫

理学第二个学士学位 。他 27 岁被CMU 聘请 为 副教

8

授 一职 ,6 年后,获得了斯坦福 大 学 的 终身教授 的 职

务 , 在 斯 坦福大 学 ,他 与 Knuth 成 为 同事和亲密的朋

友。他 是 检验 系统 方法论 的 开创 者 ,在 词法分析 理

论 、 编 程语 言语义、自 动 程序验证 .自动

程序 综合 生成和 算法分析 等 方面做

出 杰出 贡献 ,于 1978 年获得计算机 科学 界 最 高奖一 一图灵 奖 。

假设有向图G=(Y,)采用邻接矩阵 g 表示,另外设置一个二维数组 4 用 于 存放 当前

顶点 之间 的 最 短路 径 长 度 ,即 分量ALi[为表示当前ic>7 的 最短路径长度 。Floyd 算法的

296

ESASJ国 |

基本思想 是 递 推产生 一 个矩阵 序列 4 ,Ai ,4 ,4 ,其 中 心 [ 熙 [ 门 表示 守7 的 路 径

上 所经 过 的 顶点 编号 不 大 于 A& 的 最短路径长度。

初始时有 4-;[让[7门王 g.edges[i[L门。若 AiLi[7门已求出,现在 考查 顶点 &,求;7

的 路径上 所经 过 的 顶点 编号 不大于 A 的 最 短路 径 长度4x[ 训 [7门,此时 守 sc>7 的 路径有 两 条 。

路径 1: 在 考查 顶点 & 之 前 求 出其最 短路 径 长 度 为 4-i[i][7 门 ( 若 没有这 样的路 径 ,

4x-i[
训[门取值为co) 。

路径2: 考查 顶点 &,zcj存在一条经过顶点A

的路径,如图 8. 39 所 示 ,该 路 径 分 为 两 段 ,即 守 cA

和A号 ) 其 长 度 为At_i[ 训 [LA 十At-iLAJL 门 (车没

有 这 样 的 路径,该 长度取 值为cc) 。

显然,如果路径 2 的 长 度 更短,即 At_i[ 可 [合十
4 _i[LA][ 门二4 [让 [ 门 , 则 取经 过 顶点 不 的 路 径

为 新 的 最 短路 径 。

有 一 条 路 径: 4 四

图 8.39

Floyd 算法 中 路 径 长度的

归纳起来,Floyd 算法 思想 的描述如下 ,

调整 情况

4-i[i[L门= g.edgesLi][7门

Ai[训[门= MIN{AL站,AL详[LA十 AL 0 和过 和 委 交 一 1

上 式 是 一 个 欠 代 表达 式 ,每 迭代 一 次,zc>7 的 最 短路径上 就 多 考虑了 一 个 顶点 ; 经过 ?7

次 迭代 后 所得 的4,-:[z[L7门 值 就 是 考虑所有 顶点 后 ic>j 的 最 短路径, 也 就是最 终 解 。

门存放着考
另外用二维数组 path 保存 最 短路 径 , 它与当前 迭代 的 次 数有关 。paths[[

查 顶点0.1、...\人之后得到的; 余 ) 的 最 短路径中 顶点 7 的 前 一 个 顶点 编号,这 和 Dijkstra

算法 中 采用 的 方式相似 。

初始 时 尚未 考查任何 顶点 , 若 ;c>j) 有 边<i,) >, 将 该边看 成是zc27 的 最 短路 径 ,该 路 径

上 顶点 了 的 前 一 个 顶点 是 ;所以置path_i[i[

方二定理则 path_i [Li[让二 一1( 表 示 无

路径) 。

在 考查 顶点 & 之前 ,zc) 的 最 短路 径 是 人 :07 ,即 pathe_i[i[门=2; RS7 的 最 短

路 径 是 (A,...,a,力,即patht_iLA][门=a。

考虑 顶点 & 的 调整情况 如 图 8. 40 所 示 ( 图 中 虚线 箭头 表示 路 径 , 实 线 箭 头 表示 边 ) : 若

经过顶点 & 的 路 径 较 长 , 则 4[ 可 [让 二 4-:[ 可 [7门,不 需要 修改 路 径 ; 若经 过 顶点 & 的 路 径 较

短 , 则 需要 修改 最 短路径和 路 径 长 度

,4[襄[ 门王AiL 说 [LA 十 AiLA]T门,pathe[ 训 [7门一

a 一 pathe -LA 让 。

在 算法 结束 时 ,由 二 维 数组 path 的 值追溯 ,可以得 到 从 ic>7 的 最短路径 。

有 一 条 路径 :
4i[[ 娄

有 一 条 路径
ci[[

ss

(好 ----------

有 一 条 路径: 4四

pathy-i[站四,Pathe-i[ 妇 [=a,
若4j-i[D>4j- 辐 [和+4-[ 妇
pathx四四-co=pathe-i[ 妇 四

办,

图 8.40

Floyd 算法 中 路 径 的 调整情况

297

数据 结构教程

[第5 【版

例如 ,对 于 图 8. 41 所 示 的有向 图 ,对 应 的邻接矩阵 数组

如下:

0

cs

3

5

0

3

cs

cs

cs

4

0

1

7

2

2

0

采用 Floyd 算法 求解的过 程如 下 :
51) 初始时有:

图 8.41 一 个有带 权 向 图

4- 一

0

co

3

5

0

3

co

co

cs

4

0

1

7

2

2

0

,

path_; 一

一 1

0 一1

一1 一1

1

2

2 -1

0

1

2

一1 一1

3 一1

(2) 考虑 顶点 0,4o[

让[让表示由顶点站 cc) 经 由 顶点 0 的 最 短路 径 长 度 ,经 过 比较 , 没

在任何 路径上得 到 修改 (例如 ,2 只 1 的 路 径 长 度 为3, 尽管 存在 2一0 一 ] 的 新 路 径 , 但 其 长 度

为 8, 大 于 原来 路 径 的 长 度), 因 此 有 :

0

5

co 7

-1

0 -1

c 0 42

-1 -1

1

oo

1

4 302,pPtr 2 21 ,

cc 10

-1 -1

3-1

(3) 考虑 顶点 1,0S2 由原来没有路径变 为 01-~2,其长度 为9, 所以 4;[0]L2]修改为

9,path[0][2]由一1 修改 为 1。 其 他 最 短路 径 无 变化 。因此有:

4 一

0

co

3

5

0

3

cs

ce

9

4

0

1

7

2

2

0

, pathi一

一 1

0

一1 一1

工

1

2

2 一1

0

1

2

一1 一1

3 一1

(4) 考虑 顶点 2,1 呈 0 由原来没有路径变为1-~2一0,其长度 为 7,所以 4*[1][0]修改为

7,pathz[1][0]由一1 修改 为2; 3 号0 由原来没有路径变为32一0,其长度 为4, 所 以

4s[3][0]修改 为 4,paths[3][0]由一1 修改为2; 3 衬1 由原来没有路径变为 3一2一1, 其 长

度 为4, 所以 4:[3][1]修改 为4,paths[3]L1]由一1 修改为2; 其 他 无修改 。因此有:

peee

4 一

, path,一

3 302
4410

9

5

0
7
7 .042

-1

0
2 -1

1
1

0
1

2
2

2 -1
2

2
3 -1

现有一条更短的路径
(5) 考虑 顶点 3,0 吃 2 原来 的 最 短路 径 长 度为 9, 路 径 为01-~2,

0-~3一2 ,其长度为 8, 所以 4:[0]L2]修改 为 8,paths[0][2]修改为3;

1c0原来的最短路径

长 度为7, 路 径为1-~2-~0,

现有一条更短的路径1-~3-2-~0,其长度为 6,所以 4:[1]L0]修

改为6,paths[1][0]修改为2; 1 空 2 原来的最 短路 径 长 度为 4, 路 径为1~2,现有一条更短

的 路径13一2,其长度为 3, 所以 4:[1][2]修改为3,paths[1][2]修改为3, 其 他 无修改。

因此有:

298

05 8

7

一 1

0

, paths一

2 一1

4: 一

603 2

3

3

.0

44 1

2

0

3

3

0

1

2

2 一1

2

3 一1

因此 ,最 后 求 得 的 各 顶点 最 短路径 长度和矩阵 4 为 :

0

6

3

4

求 得 的 各 顶点 最 短路 径 矩阵path 为

一 1

5

0

3

4

0

2 一 1

8

3

0

1

7

2

2

0

3

3

2

2

2 -1

2

3 一 1

2

2

0

1

2

在 得 到 最 终 的4和 path 以后 ,由 4 数组可 以 直接 得 到 两 个 顶点 之间 的 最短路径长度

如 4L1]Lo]=6,说明顶点 1 到 0 的 最短路径长度为6。

由 path 数组 可 以推导 出所有 顶点 之 间 的 最 短路 径 ,其 中 第 (0 所;i受 2 一1) 行用于 推导

顶点 守 到 其 他 各 顶点 的 最 短路 径 。下 面 以求1 号0 的 最 短路径为例说 明 求 路径 的 过 程 。

path[L1][0]

一2,说明顶点 0 的 前 一顶点是顶点2,path[1][L2]

王3,表示项点 2 的 前 一 个

顶点是顶点 3,pathL1][3]=1,

表示顶点 3 的 前 一 个 顶点 是 顶点 1, 找 到 起 点。依 次得 到 的

顶点 序列 为 0.2.3、1,则 1 号 0 的 最短路径为1-~3-一2一0。

图 8. 41 采用 Floyd 算法 求出的 最终结果如图 8. 42 所 示 。

从 0 到 1 路径 为 : 01 路径长度为: 5
从0到2 路径 为 :03.2 路径长度为: 8

5 03

全 长度为 7

从 0 到 3 路径为: 0, 路径 长 度为:

从 1 到 0 路径 为: 1.3,.2.0 路径长度为: 6

从 1 到 2 路径 为 : 13,2 路径长度为: 3
从1到3 路 径 为 13 路径长 度 为: 2

人 20 路径长度 为,3

从 2 到 0 路径 为: 2

径 长 度 为

:

从2到 1 路径 为 : 21 路径长度为: 3

3

从2到 3 路径 为 : 23 路径长 度 为: 2
径 长 度 为: 4
从 3恒 中 ,
从 3 到 1 路径 为: 32,1 路径长度为: 4

到 0 路 径 为 : 3.2.0

中全 民

从 3 到 2 路径 为 :3.2 路径长 度 为: 1

A(0) :

path(0) :

0

5

om

7

-1

0

-1

20 4
0
3
3

2 -1 1
2
2?

2

0

1

op

训
A(D;

0

om
3

5

0
3

1

9

4
0

om 1
AO),

0

7
3
4
AG),

0

6

3

4

5

0
3
4

5

0

3

4

9

4
0
1

8

3

0

1

0

7

-1
-1L
path(1) ,

3

-1

-1

0 10

-1

11
2
> 2

-1

0

7

2
2?
0

7

2

2

0

-1
-1
path(2) ,

3-l

-1

0

1

0

2 -1 1
2
2
2
-l
2
2
path(3):

-1
3

-10

2

2

2

-1

2

2

3

3

-l

3

0

-=-!

2

=-

Ce

(a) 最短路径长度

(b) 最短路径

图 8. 42 采用 弗 洛 伊德算法 求出的 结果和求解过程

299

数据 结构 教程

[第! 5 【版

对 应 的 Floyd 算法如下 :

void FloydC(MatGraph g)

//Floyd 算法

{

int ALMAXV]JLMAXV] ,pathLMAXV]LMAXV] ;

int i,j,k;

for (ji王0;i<g.nii 十十)

二 GOj<eaHHH)

{ A 口喇=g.edges品中 ;

计 (il=j && g.edges[ 品中<INF)

path品中一i;

// 顶 点 i 到 j 有 边 时

path 品 中 二 一 1;

// 顶 点 i 到 j 没有 边 时

else

】}

for (k 一0;k<g.n;k十十)

{

for (i=0;i<g.nii十十)

for (=0;j<g.n;j十十)

/依次考查所有顶点

计 (A国DJ>A加 [吴二 AID
人 A 回国=A回[ 国十AU 团; /修改最短路径长度

Path 四国 一path[g D ;

// 修 改最短路径

}

}

Dispath(g,A,path);

// 输 出 最短路径

}

输出 多 源 最短路径的 Dispath() 函数如下 :

void Dispath(MatGraph g,int A[] [MAXV] ,int pathCJ [MAXV])

人

intij,k,s;

int apathLMAXV] ,d;

for (i王0;i<g.n;i十十)

for (j王0;j<g.n;j十十)

// 存 放 一 条 最 短路径中 间 顶 点 ( 反 向 ) 及 其 顶点 个 数

// 若 顶点1和 j 之 间 存 在 路 径

{

这 (A四四 !=NF&& il一ji)
{

printf(" 从中d到 %%d 的 路 径 为 :"ij);
k一path[品D] ;
d一0; apath[dj 一j;
while (k! 一 一1 && kl=iD) // 路径上 添加中 间点

// 路径上 添加 终点

, d+十; apath[d 一k;

上 一 path[品[hb] ;

{

}

d 十十; apath[dj 一 i;

// 路径上添加起点

printf("%d" ,apath[d] ); //输出起点

2

for (s=一d 一1;s> 一 0;s 一 一)

// 输 出 路径上 的 中 间 顶 点

printf(", %%d" ,apath[s] );

printf("\t 路 径 长 度 为 :%dn" ,AD 中);

)}

不考虑路径输 出,Floyd 算法 的 时间 复 杂 度为O02) ,其中 ) 为图中顶点的个数。

300

DOOR

设 G=(V ,已)是 一 个具有 守 个顶点的有向 图,Y 中 的 顶点 序列 ww ,...w 称 为 一个拓

扑 序 列(topological sequence) 。 若< ww ,u > 是 图 中 的 一 条 边 或 者从顶点 w; 到 顶点 w 有路

径 , 则 在 该 序列 中 顶点 必须排在顶点w 之前。

在 一 个 有向 图 中找 一 个 拓扑 序列的过程 称为拓扑 排序 (topological sort)。

例如 ,计算 机 专业 的 学生 必 须 完成 一 系列 规定 的 基础课和 专业 课 才 能 毕业 ,假设这 些 课

程 的名称 与 相应代号有 如 表 8. 1 所 示 的关系。

表 8.1 课程名称 与相应代号的关系

课程 代号

课程 名称

先 修 课程

C'

C,

Cs
C,

Cs

Cs

Cr

高等数学

程序 设计

离散 数学
数据结构

编译原理

操作 系统

计算 机 组 成 原理

无

无

C
CC,
CC

C4C"
C2:

号 -下

视频讲解

课程 之 间 的 先 修 关系 可以用 一 个有向 图 表示 ,如 图 8. 43 所 示 。 这 种 用 顶点 表示 活动 ,

用 有 向 边 表示 活动 之 间 优先关系 的有向 图 称 为 顶点 表示 活动 的网(Cactivity on vertex

newtork,AOV 网) 。

图 8. 43 ”课程之间 的 先后关系有 向 图

对 课程AOV 网 进行 拓扑 排序 可 得 到 一 个 拓扑 序列: Ci一Cs一Cz 一 CC 一 Ce一 C5。

也 可 得 到 另 一 个 拓扑 序列: C:一C? 一 CI一Cs 一Ci 一 Cs 一 Cs, 还 可以 得 到 其 他 的 拓扑 序列 。
学生可以按照任何一 个 拓扑 序列 的 顺序 进行 课程学习 。

Ta

拓扑排序方法如下 :

(1)

从 有 向 图 中 选择一个没有 前 驱 (即人度为 0) 的 顶点 并 且 输出 它 。

《2) 从 图 中 删 去 该 顶点 ,并 且 删去从 该 顶点 发出的 全 部 有 向 边 。

(3) 重复上述 两 步,直到 剩余 的图中 不 再 存在 没有前 驱 的 项 点 为止。

这 样 操作 的 结果 有 两种: 一 种 是图中 全 部 顶点 都 被 输出 ,即 该 图中所 有顶点都在其拓

扑 序列 中 ,这 说 明 图 中 不 存在 回路 ;

另 一 种 就 是图中 顶点 未 被 全 部 输出 ,这 说 明 图 中 存在 回

301

数据 结构 教程 第人5人所

路 (以 课程 之间 的先修 关 系 为例, 存在回路 说 明 一 些

课程 以自己 为先修 关 系 )。所 以可 以通过

对 一 个 有向 图 进行 拓扑 排序 ,看 是 否产生 全 部 顶点 的 拓扑序列 来确定 该图中 是 否存在回路。

为了实现 拓扑 排序 的 算法 ,对了

F 给 定 的 有 向 图 ,采用 邻接 表 作 为存储结构 ,为 每个顶点

设立 一 个 链表 ,每 个链表 有 一 个 表 头结 点,这些 表 头结 点 构成一个 数组,表 头结 点 中 增加 一

个 存放 顶点入度 的域count。 即 将邻接 表 定义中 的 VNode 类 型修改如下 :

typedef struct

{

Vertex data;

int count;

//顶点信息
// 增 加数据域: 存放 顶点 人 度

ArcNode * firstarc;

) VNode;

// 指 向 第 一 个 邻接点
// 头 结 点 类 型

在 执行 拓扑 排序 的 过 程中, 当 某 个 顶点 的人度 为 零 ( 没 有 前 驱 顶 点 ) 时 ,

检测入度为零的顶点 ,设立 一 个栈 St, 以存放 和人度 为零的

顶点。这 里 采用顺

序栈, 并 且 直 接 用 St 数组存放 栈 中 的 元 素 ,top 作为栈项指针 。

对 应 拓扑 排序 的 算法 如 下 :

视频讲解

void TopSort(AdjGraph * G)

// 拓 扑 排序 算法

{

intij;

int StLMAXV] ,top王一 1;

//栈 St 的 指针 为 top

ArcNode * pi;

for (i=0;i<G 一>nii 十十)

G 一 adjlist[吕 .count一0;

for (i=0;i<G 一>nii 十十)

{

, p=G->adjlist[丫.firstarc

while (p!=NULL)

G->adjlist[p -> adjvex] .count十十;

p一p 一> nextarc;

{

}

}

// 人 度 置 初值 0

// 求所有顶点的人度

for (i王0;i<G一> nii 十十)

//将人度为 0 的顶点进栈

这 (G 一 >adjlist[ .count一

一0)

top 十十;

St[top] =一i;

{

】}

while (top >一1)

{

ii=St[top] ;top 一一 ;

printf("%d "iD;

p一G 一 adjlist[了 .firstarc

while (p!王NULL)

{ jp 一 adjvex;

G 一 adjlistD].count 一一;

// 栈 不 空循环

// 出 栈 一 个 顶点 ii

// 输 出 该 项点

// 找 第一个邻接 点

// 将 顶点 i 的 出边邻 接点 的人度减1

让 (G 一 adjlist中 .count一一0)

//将入度为 0 的邻接点进栈

{

top 十十;

302

DOOR

St[top] 一 j;

}

p 一 p 一> nextarc;

// 找 下 一 个邻接 点

)》

【例8.14】 给 出图 8. 44 所 示 的有向 图 G 的 全 部 可 能 的 拓扑 排序 序列 。
国 从 图 G 中 可 以 看 到 ,入 度为 0

有 两 个 顶点 , 即 人 个 人 人

0 和 4 , 先 考虑顶点 0, 删除 0 及相关边,和人度为 0

者 有

4; 删除 4 及 相关 边,入 度为0 者有 1 和 5; 考虑 项点 1,
删除 1 及 相关 边 , 入 度 为 0 者有 2 和 5; 如 此 得 到 拓扑 《4

G)

序列为 041253 ,041523 ,045123 。

再 考查顶点 4, 类似 地 得 到 拓扑序列450123,

图 8.44 一个有向图 G

401253,405123 ,401523。

因此 ,所 有 的 拓扑 序列为 041253 ,041523,045123,450123,401253 ,405123,401523 。

AOE 网 与 关键路径

洒

871 相关 概念

若 用 前面介绍 过 的有向 无环图 (directed acycline graph,DAG)描述工

程 的 预计 进度 ,以 顶点 表示 事件,有 向 边 表示 活动,边 e 的 权 c(e)表示完成

活动 。 所 需的时 间 ( 如 天 数 ) ,或 者说 活动 e 持续时间。图中人度为0 的顶

视频讲解

点 表示 工程的开始 事件 (如 开工 仪式) ,出 度为0 的 顶点 表示 工程结束 事件 ,称这 样 的有向 图

为 边 表示 活动 的 网(activity on edge network,AOE 网) 。

通常 每个工程 都只有 一 个开始事件和 一 个 结束事件,因此 表示 工程 的 AOE 网都只有

一个人度为0 的 顶点 , 称 为 源 点(source) ,和 一 个 出 度 为 0 的 顶点 , 称 为 汇 点(converge)。如

果 图 中 存在 多 个人度 为 0 的 顶点,只 要 加 一 个 虚拟 源 点 ,使这 个 虚拟 源 点 到 原来所有 人和人度 为

0 的点 都有一 条 长 度为 0 的 边,从 而 变 成只有 一 个 源 点 。对存在多个出度为0 的 顶点的情

况做 类 似 的 处 理 。所以只 需讨 论 单 源点和 单汇 点 的 情况 。

利用 这 样的AOE 网 能够计算 完成 整个 工程预计 需要 多 少时 间 , 并 找 出 影响 工程进度

的 “关键 活动 ",从 而 为 决策者 提供 修改各 活动 的 预计进度的依据 。

aa

在 AOE 网中 ,从 源 点 到汇 点 的所 有 路 径中 具有 最 大 路 径 长 度的 路径 称为关键 路径

Ccritical path)。完 成 整个 工程 的最短时间 就是AOE 网 中 关键 路 径 的 长度 ,或 者 说是AOE

网 中 一 条 关键 路径上 各 活动持续 时间 的总和 ,把 关键 路径上 的 活动 称为关键 活动(key

activity) 。关 键 活动 不存在 富余的时 间 , 而非 关 键 活动 可 能 存在 富余 的时间。通 常一个

AOE 网 可 能 存在 多 条 关键 路 径 ,但 它们 的 长 度 是相同的。

因此 ,只 要 找出AOE 网 中 的所有 关键 活动也就 找到 了 全 部 关键路径 。

303

数据 结构 教程

虹 第 5 人版

例如 ,图 8. 45 表示某工程的AOE 网 ,共有 9 个事件 和 11 项 活动 ,其中A 表示源点 、

I 表 示 汇 点 。

下 面 介绍如 何利用AOE 网 计算 出 完成 整个工程需要 的 最少时间 , 同 时找 出 影响工程

在 AOE 网 中 , 若 存在 两 条 首尾 相 接 的边w=< wz>和四 王 <zz>,则称活动w; 是 活动

oj 的 前 驱 活 动,w 是 活动 w 的 后继活动 。一 个 活动可能 有 多 个 前 驱 活动和 多 个 后 继 活动 。

显然,只有当活动w 的所有 前 驱 活 动都完成 后 事件 ww 才 发生 ( 这 里 ww 是边w 的 头),

且 活动w 才 可以 开始。如图 8. 46 所示 , 当 活动 1、 活动 2 和 活动 3 都 完成 时 ,事件凤 就发

生了,活动 w 就可以 开始 了 ,所以 事件 zw 称 为 活动 wj 的触发 事件 。

图 8.45 AOE网的示例

图 8.46 前 驱 活 动和后 继 活 动

假设事件 z 是 源点 事件 >

和

是 汇 点 ,并规定 事件 z 的 发 生时间 为 0。 定

义图中任一事件 w 的 最 早 (event early)开始时间 ve(u) 等 于 工到vw 所 有 路

|

径 长度的 最 大 值 ,即 :

ve() 二 MAX{cCpD)

起

式 中的MAX是对源 点 工 到 v 的所有路径 取 最 大 值,c( 思 ) 表 示 路 径

视频讲解

妃 的 长度( 路径上 的所有 活动 w 的 时 间 之和 ) , 即 :

cCp)

一 >){cCa)》

aE访

于 是 完成 整个 工程所 需 的 最 少时间 等于汇 点 > 的 最 早开始时间 ve(Cy)。

源 点工到 汇 点 y 的 最 长路径 就是关键路径 ,完成 工程所 需 最 少时间 就是关键 路 径 的

长度

例如 ,在图8.45 中 A 到 下 的 最 长 路 径是A-~B-~E,其长度等于6 十 1 一7, 所以事件 玖

的 最 早 可 发 生时 间 等于7。 图 8. 45 中 用 粗 线标 出 的一条 关键 路 径是 A一BE-~G-~I,其长

度 等于 6 十 1十7十4一18, 于 是 完成 整个 工程 至少需 18 天 (假设 这 里 的时间 单 位是天 ) 。

为 使 事件 v 尽 可 能 早 地 开始 ,处于 源点zx 到 事件 v 的 最 长 路径上 的 活动必须“ 刻 不 容

缓?地 进行 ,一 旦 触发 事件 发生 , 便立即 开始 ,而 且 应 当 在 规定 时间 内 完成,否则事件 v" 就不

能 按时 开始 ,影响 整个工程 的 进度。例 如 图 8. 45 中 的 活动 ai ,一旦事件 B 发生 ,活动 ci 必

须立即开始。

而 对那些并 不处在 最 长 路径上 的 活动 来 说 ,即使 稍微 推迟 一 些时间 完 成,也 对 工程 的 总

进度 无 得。例如,图 8. 45 中 活动 ws 不 处 在事件 下的最长路 径 上 ,只要它在第 7 天 中 完成,

就 不至于影响事件下 的 发生, 由 于 路径 A一C 一 E 的 长 度 等于4 十 1一5, 所以 活动 cs

可 有

304

DOOR

7 一 5 一2 天 的富余时间 。

定义 在 不 影响 整个 工程进度 的 前 提 下 ,事件 v 必须 开始的时间 称为w 的最迟 (Cevent

late)开始时间,记作 vl(z)。

那么 vl(z)应等于 ve(y) 与 到 汇 点 > 的 最 长 路 径 长度之 差 ,即 :

式 中的MAX 对 mv到 汇 点 y 的所有 路 径 户取最大值。显然 l(y) 王 veCy) ,vl(z) 一 ve(z) 一 0。

vl(Co) 一 ve(Cy) 一 MAX{c(OD

(8.1)

对任何ww 一 <vw>,有:

如 果 上 式 取 等 号 ,即 :

ve(Co)

十 c(ai) 近 vl(Co)

ve(Cu)

十 c(Cai) 一 vl(Cro)

(8.2)

(8.3)

则 称 活动ni 为 关键 活动 。反 之,上 式 取小 于 符号 , 则 w 是非 关键 活动 。

对 关键 活动 来说,不 存在 富余 时 间 ,显然关键 路径上 的 活动 都是关键 活动 。找出关键活

动的意义 在 于 可以 适当 地 增加 对 关键 活动的 投资 (人 力 、 物 力 等) ,相应 地 减少对非 关键 活动

的 投资,从 而 减少关键 活动的持续 时 间 ,缩短 整个 工程的工期 。

只 要计算 出 各 顶点 的 ve(w)和 vl(u)的值,根据 8. 3 等 式 就能找 出所有 的 关键 活动 。为

了 便于 计算 ,引入 下 面 两 个 递 推 式 , 其 中二和> 分 别 是 源点和 汇 点 。

ve(CZ) 一 0

ve(Cw) 一 届 LAX stveCv) 十 c(Kum>)) 世 天 工

(8.4)

上 式 中 的 MAX 对 za 的所有 和人 边<w,w > 的权 取 最 大 值 。

vl(Cy) 一 0

vl(Cu) 一

MIN
所 有存在 <wzw>边的 mw

{vl(ro)一cCCuz>)) 飞天yy

(8.5)

上 式 中 MIN 对 v 的所有 出 边<w,ze > 的权 取 最小 值 。

图 8.47(a) 给出了 8.4 式 的 解释,其 中事件.2、c 的 最 早开始 时间 分 别为 veCa) \ve(O)

和 ve(c),假设它们都已求 出。因 为只有 < a,zw><0zw> 和 <cyz > 活动 都 完成才 触 发事件

io 发生, 所以事件 zw 的 最 早开始时间 ve(zo)必等于 ve(a)十cC(<aym>) 、ve(D)十c(< 0 >)

和 ve(c)十cC<c,z>) 三者中 的 最 大 值

。 如 果 事件zw 有 更 多 个 前 驱事 件 ,求法类似 。

图 8.47 计算 veCze)和 vl(z)的递推式的含义

(D)

只 要 从 源 点 工 起 按照 顶点 的 拓扑 序列 次序反复 运用 递 推式8.4,

即 可 求出各 事件 凤 ( 顶

点)的veCw)之值。

类 似 的 ,图 8. 47(b)给出了 8.5 式 的 解释,其 中 事件ec.2 和 * 的 最迟开始时间 分 别 为

数据 结构 教程

虹 第人5 【版

vlCa) yl 和 vlCc),假设它们都已求 出 。那么事件 v 的 最 迟开始时间 vl(v) 必 等 于 vl(oa)一

co,a>)、vlO)一 c(<u2>)和 vlc)一c(<uc>) 三者中 的 最小 值 。

只 要 从 汇 点 > 起 按照顶点 的 拓扑 序列 的 道序反 复运用 递 推式8. 5, 即 可 求出各 个

顶点

的 最迟可 发 生时 间 vl(u) ,然后用 8. 3 式 判断各有 关 活 动是否为关键 活动 。

872 求 ACE网 的关键活动

综 上 所 述 ,得出下 面求AOE 网 的 关键 活动 的步骤 ;

(1) 对 于 源 点 ,置veCz)一0。

(2)

对 AOE 网 进行 拓扑 排序,如 发 现回路 ,工程 无法进行,退出; 否则 继续 下 一 步 。

(3) 按 顶 点 的 拓扑 序列 次序反 复用 8.4 式 依次 求其余 各 顶点 的 veCv)值(实际上 ,步

又 (2)和 步骤 (3) 可以 合 在一起 完成 ,即 一 边对 顶点 进行 拓扑 排序,一边 求出各 顶点的 veCv)

值) 。

(4) 对 于 汇点>,置v1(y)一ve(y)。

(5) 按 顶 点 拓扑 序列 次 序之逆序 反复 用 8. 5 式 依次 求 其余各 顶点 才 的 vl(Cu) 的值。

(6) 活动 w 的 最 早开始 时间 e(ai) 是 该 活动的起 点 的 最早开始时 间。如果 aw

一 <7

>,

则有 e(ai)一veC7) 。

(7) 活动 ai 的 最 迟开始 时间 (ai;) 是 该 活动的终点 的 最 迟开始时间 与该活动的所 需 时

间 之 差 。如果 wu

一 <7J >, 则 有 La)一vLIC)一cCai)。

(8) 一 个 活动 w 的 最 迟开始时间 !(ai) 和 最早开始时间 e(ai)的盖,即gdCa)一!(Cai)一

e(ai) , 称 为该活动 的时间 余 量。它 是 在 不 增加 整个 工程 完工所 需 总时间 的 情况 下 活动 w 可

以拖延的时间 。

(9) 当 一 个 活动的时 间 富 余 为零时 ,说 明 该 活动 必须如 期 完成,否则 就 会 拖延 完成整个

工程的进度 。所以,若dai)=0,即!(ai)=一e(a), 则 活动ui 是 关键 活动 。

【例8. 15〗 求图8. 45 所 示 的 AOE 网 的关键路径。

对 于该AOE 网,其 中 源点为 顶点 A, 汇 点 为 顶点 I。 先 进行一次 拓扑 排序,假设产

生 的拓扑 序列 为 ABCDEFGHI,

依此顺序计算各事件的veCv)如下:

ve(A)王0

王ve(A)十c(ai )一6
ve(B)

一ve(A)十c(Cas )一4
ve(C)

一ve(A)十c(as)一5
ve(D)

ve(E)王MAX{ve(B) 十c(Cas),ve(C) 十 c(as)) 一 MAX(47,5) 一 7

一ve(E)十c(a7z)一16
ve(E)

一ve(E)十c(as)一14
ve(G)

王ve(D)十cCas)一7
ve(H)

ve(TD 王 MAX{veCF) 十c(Caio),ve(G) 十c(Caal),ve(H) 十cCao))} 一 MAX{18,18,11)一18

按 拓 扑序列逆序IHGFEDCBA 计算各事件的vl(z)如下:

vl(D一ve(CD王18

王v1(D一c(Cas)一14
vlL(H)

一vl(D一cCaa )一14
v1(G)

306

ESAS 国 |

一vl(D一cCao)一16
vl(F)

vl(CE)王MIN{YICE) 一c(Caoy),vlCG) 一cCas)) 一 MIN17,7) 一 7

王vL(H)一cCas)一12
vlLCD)

王vL(E)一c(Cas)一6
vlCC)

王vl(E)一c(as)一6
vl1(B)

vl(CA)=王MIN{vICB) 一 cCa),vlCC) 一c(az),vlCD) 一c(Cas)) 王 MIN10,2.7) 一 0

计算各活动“的eCo)、.Ca)和 do)如下:

活动 al: e(al )一ve(A)一0

Z(ai) 一vl(B) 一6 一0

d(ai) 一0

活动 as: e(az )一ve(A)一0

Z(as) 一vl(CC)

一4一2

d(az) 一2

活动 ai: e(as ) 王 ve(A)=0

7(as) 一vI(D)

一5一7

d(as) 一7

活动 ui : e(ai)一ve(B)一6

Z(a) 一vL(E) 一1 一6

d(as) 一0

活动 ai: e(as )一ve(C)一4

7(ai) 一vL(E) 一1 一6

d(as) 一2

活动 ae: e(as)一ve(D)一5

Z(as) 一vl(H) 一2 王12

das) 一7

活动 ay: e(ay)一ve(E)一7

Z(a7) 一vLICF)

一9一7

d(ay) 一0

活动 us: e(as)一ve(E)一7

Z(as) 一v1(G) 一7 一7

ad(as) 一0

活动 we

: e(as)王ve(H)王7

Z(as) 一v1(G)

一4 一 10

das) 一3

活动 aio: e(aio)

一vI(F)一16 Z(aio)

一vl(D一2一16 dao)王0

活动 ua : e(an)一ve(G)一14 (aa)一vL(D一4一14 da)一0

由 此 可 知 ,关键 活动 有 aa ,aio as ay at ai, 因此 关键 路 径 有 两条 ,即 A一BE-~F-~I

和 A-~B-~E-~G-~I。

从 求解结果 看 出 以下几 点 :

(1) 缩短 某 一 活动 的 时间 ,整个 工期不一 定 会 缩短。例如,在 8. 45 所示的AOE 网中将

活动 we 由 4 天 缩短 为两天 ,整个 工期仍然需要 18 天 ,因为 关键 路 径 没有 改变 。

(2) 缩短 某一关键 活动 的时间,整个工期不一定会缩短。例如,在 8.45 所示 的 AOE 网

中 将关键活动w 由 9 天缩短为 5 天 ,整个工期仍然需要 18 天。因为A-~B-~E-~F-~I 变为

非 关键路径 ,而 关键 路径A-B-~E-~G->~I 的 长 度仍然为18。

(3)

只 有 缩短所有 关键 路 径 共 享的关键 活动 的 时间 , 整 个 工期才可 能 缩短。例如,

在 8.45 所 示 的 AOE 网 中 将 共享 关键 活动wy 由 6 天 缩短为 5 天 ,整个工期也缩短1 天。

(4) 缩短某 一 共享 关键 活动 时 间 为 dd二0)天,整个工期不一定会缩短d 天。例如,在

8.45 所 示 的 AOE 网 中 将 共享 关键 活动 w 由 6 天 缩短 为 两天( 共 缩短 4 天 ) ,整个工期也仅仅

缩短了两天。因 为关键路径变为A-~C-~E-~>F->I 和 A-~C-~E-~G->~I,其长度为16。

7

数据 结构 教程

虹 第人5 【版

本 章 的 基本 学 习 要 点 如 下 :

(1) 掌握 图 的相关概念,包括 图\有向图/无向图, 度/入 度 / 出 度 . 完 全 图、.子图.连通

强 连通 图 ,简单路径 /简单 环 和 网 等的定义 。

(2) 掌握 图的 各种存储结构 ,包括邻接 矩阵 和 邻接 表 等 ,理解 它们 的 特点 和 差异 。

(3) 掌握 图的 基本 运算 ,包括创建图.销毁 图 和 输出 图等。

(4) 掌握 图的深度优先 遍历 和 广度 优先 遍历 算法 ,以及这 两 个 算法 在

图搜索 算法设计

中 的应用 。

(5) 掌握 生成树 和 最 小 生成树 的概念 , 求带权 连通 图中 最 小生成树的Prim 和 Kruskal

算法。

(6) 掌握

求 单 源 最短路径的Dijkstra 算法和 求 多源 最短路径的Floyd 算法。

(7) 掌握 拓扑 排序的 过程 。

(8) 掌 握在AOE 网 中 求 关键路径 的 过程 。

(9) 灵活地运用 图这种 数据 结构 解决一些 综合应用问题。

一人 练习题 8 一 一

1. 图 G 是 一 个非连通 图 ,共有 28 条 边 , 则 该 图 最 少有多 少个顶点 ?

2. 有一个如图 8. 48 所 示的有 向 图 ,给 出 其所有 的 强 连 通 分 量 。

3. 对 于 稠密图和 稀 朴 图 ,采用 邻接 和 矩阵和 邻接 表 哪 个 更好一些?

4. 对于 宁 个 顶点 的 无 向图和 有 向 图 ( 均 为 不带权图), 当 采用 邻接 和 矩阵和 邻接 表 表 示 时

如 何 求解以下问题:

(1) 图中有 多 少 条 边 ?

(2) 任意两个 顶点 和 是否有 边 相连?

(3) 任意 一 个 顶点 的度是 多 少 ?

5. 对 于 如 图 8.49 所 示 的 一 个 无 向图 G, 给 出 以顶点 0 作为 初始 点 的所有 的 深度 优先

遍历 序列 和 广度 优先 遍历 序列 。

6. 对 于 如 图 8. 50 所 示 的 带 权 无 向图,给 出利用 Prim 算法 (从 顶点 0 开始 构造)和

Kruskal 算法 构造出的 最小 生成 树的结果 ,要求结果 按 构造边的顺序 列 出 。

图 8.48 一个有向图

图 8. 49 一 个 无 向图C

图 8.50 一 个 带 权 无向图

7. 对 于 一 个 顶点 个 数 超过 4 的 带 权 无 向图,回答以下问题:

(1) 该图的 最 小 生成 树一定 是 唯一 的 吗? 如 果 所 有 边的权 都 不相同 ,那么其最小生成

树 一 定 是 唯一的 吗 ?

(2) 如 果 该 图 的 最 小 生成 树 不 是唯一 的 ,那么调用 Prim 算法和 Kruskal 算法 构造出的

308

e@6e

最 小 生成 树 一 定相同吗?

(3) 如果图中有且 仅 有 两条权 最小 的 边 ,它们 一 定 出 现在 该 图 的所有 最 小 生成树中 吗 ?

简要说明理由。

(4) 如 果 图中有 且 仅 有 3 条 权 最小 的 边 ,它们 一 定 出 现在 该 图 的所有 最 小 生成树中 吗 ?

简要说明理由。

8. 对 于 如 图 8. 51 所 示 的带权 有 向 图,采用 Dijkstra 算法

求出从顶点 0 到 其他 各 顶点 的 最 短路 径 及 其 长 度,要 求 给 出

求解过程。

9. 对 于 一 个带权 连通 图,可以 采用 Prim 算法 构造 出 从

某 个 顶点 吕 出 发的最 小 生成树,问 该 最 小 生成 树是否一定 包

含 从 顶点 , 到 其他 所 有 顶点 的 最短路径吗? 如 果 回 答是,请
予以证明; 如 果 回答不是 ,请 给

出 反例 。

国引5 一 个党权 有 内 图 6

10. 若 只 求带权 有 向 图 G 中 从 顶点 ;到 顶点 7 的 最 短路 径 , 如 何 修改 Dijkstra 算法 来 实

现这一功能?

11, Dijkstra 算法 用 于 求 单源 最 短路 径 ,为了求 一 个图中 所 有 顶点 对 之间 的 最 短路 径 ,

可 以 以 每个顶点 作为源点调用 Dijkstra 算法 ,Floyd 算法和 这 种 算法 相比有 什么 优势?

思

Go

Ka

12. 回答 以下有 关 拓 扑 排序 的 问题 ,

GD) 给出如 图 8. 52 所示 有向 图 的所有 不 同的拓扑序列 。
2) 什么 样 的 有向 图 的 拓扑序列 是 唯一的 ?
(3) 现 要 对 一 个 有向 图 的所有 顶点 重新 编号,使所有 表示 边

的非 0 元 素集中 到 邻接矩阵 数组 的 上 三 角部分。根 据什么顺序

图 8. 52 一个有向图 ”对 顶点 进行编号 可以 实现 这 个 功能 ?

13. 已知有 6 个 顶点 (顶点编号为 0 一5) 的 带权有向图 G, 其 邻接 矩阵 数组 A 为 上 三角

和矩阵, 按行为主 序 (行优先 ) 保 存在以 下 的 一 维 数组中 ,

4|16|clclcl5lclclcl41l3lclccl3sls3

要 求 ,

(1) 写出图 G 的 邻接矩阵 数组4 。

(2) 画 出 带权有 向 图 G。

(3) 求图 G 的 关键路径 ,并计算 该 关键路径 的 长 度 。

14. 假设 不带权 有向 图 采用 邻接矩阵 g 存储 ,设计 实现以 下 功能 的 算法 :

(1) 求 出图中 每个顶点 的入度 。

(2) 求 出图中 每个顶点 的 出 度 。

(3) 求 出图中 出 度为 0 的 顶点 数 。

15. 假设 不带权 有 向 图 采用 邻接 表 G 存储 ,设计 实现以下 功能 的 算法 :

(1) 求 出图中 每个顶点 的入度 。

(2) 求 出图中 每个顶点 的 出 度 。

(3) 求 出图中 出 度为 0 的 顶点 数 。

16. 假设 一 个连通 图 采用 邻接表 作 为存储结构 , 试 设计 一 个 算法 ,判断其中 是 否 存在经

309

数据 结构教程

[第! 5 【版

过 顶点 v 的 回路 。

17. 假设图 G 采用 邻接 表 存 储 , 试 设计 一 个 算法 ,判断 无向图 G 是 否 为 一 棵 树。若为

树 ,返回真; 否则 返回 假 。

18.

设 5 地 (0 一4) 之间架设有 6 座 桥(A 一 F) ,如 图 8.53 所 示 , 设计 一 个 算法,从 某 地

出 发 ,经 过 每 座 桥 恰 巧一次,最后仍 回 到 原 地 。

19. 设 不 带 权 无向图 G 采用 邻接表 表 示 ,设计 一 个 算法 求源点 ;到

其 余 各 顶点 的 最 短

路径。

20. 对 于 一 个 带权有 向 图 ,设计 一 个 算法 输出 从 顶点 ;站 到 顶点 7 的所有 路 径 及 其 路 径 长

度。调 用 该算法求出图 8. 35 中 顶点 0 到 顶点 3 的所有 路 径 及 其长度 。

图 8.53 实地图

一 >- 上 机 实验题 8

一 和

愉 验 证性实验

实验题 1, 实现图的邻接 矩阵和 邻接 表 的 存储

目的: 领会图 的 两 种主要 存储 结构和 图 的 基本 运算 算法 设计 。

内 容 , 编写一个 程序 graph. cpp,设 计 带 权 图 的邻接 矩阵 与 邻接表 的 创建和输出运算 ,

并 在 此 基础上 设计 一个主 程序 exp8-1. cpp 完成以下 功能 。

(1) 建立如图 8. 54 所 示 的有向 图 G 的邻接 矩阵,并

输出之。

(2) 建立如图 8. 54 所 示 的有向 图 G 的邻接 表 ,并输

出之。

(3) 销毁 图 G 的邻接 表 。

实验题2: 实现图的遍历算法
目的: 领会 图 的 两种遍历 算法 。

8

内容: 编写一个程序 travsal, cpp实现图的两种遍历

运算 ,并 在 此 基础上 设计 一 个 程序exp8-2. cpp 完成以下功能。

图 8.54 一 个 带权有 向 图

(1) 输出 如 图 8. 54 的有向图 G 从 顶点 0 开始 的 深度 优先 遍历 序列 (递归 算法 ) 。

(2) 输出如 图 8. 54 的有向图 G 从 顶点 0 开始 的 深度 优先 遍历 序列 (非递归 算 法 ) 。

(3) 输出如图 8. 54 的有向图 G 从 顶点 0 开始 的 广度 优先 遍历 序列 。

310

DOOR

实验题3: 求 连通 图 的所有 深度 优先 遍历 序列

日 的: 领会图的 深度优先 遍历 算法 。

内 容: 编写一个程序exp8-3. cpp, 假 设 一个连通 图 采用 邻接 表 存储 ,输出 它 的所有 深度

优先遍历序列 ,并求图 8. 1(a)中从顶点 1 出 发 的所有 深度 优先 遍历 序列 。

实验题4: 求 连通 图 的 深度优先 生成树和 广度优先 生成 树

日 的: 领会图的 深度 优先 遍历 ,广度 优先遍历 算法和 生成树的 概念 。

才

容: 编写一个程序exp8-4. cpp, 输 出 一 个 连通 图 的 深度 优先 生成树和 广度 优先 生成

树 ,并对图 8. 24 求 从 顶点 3 出 发 的 一 棵 深度 优先 生成树和 一 棵 广度 优先生成树。

实验题5: 采用 普 里 姆 算法 求 最小 生成 树

日 的: 领会普 里姆算法 求带权 连 通图中 最 小 生成 树 的 过 程和相关 算法 设计 。

容: 编写一个程序exp8-5. cpp, 实 现 求 带权 连通 图

最小 生成 树的普里姆算法 。对 于 如 图 8. 55 所示的带权连

通图 G, 输出从 顶点 0 出发的一棵 最小 生成 树 。

实验题6: 采用 克 鲁 斯卡尔 算法 求 最 小 生成 树

目的: 领会克 鲁 斯卡尔 算法 求 带权 连 通 图 中 最小 和

直

成树的 过 程和相关 算法 设计 。

内容: 编写一个程序exp8-6. cpp, 实 现 求 带权 连 通 图

最 小 生成 树 的 克 鲁 斯 卡尔 算法 。对 于 如 图 8. 55 所 示 的 带

权 连 通图 G, 输 出从顶点 0 出 发 的 一 棵 最 小 生成 树 。

图 8.55 一 个 带 权连通图

实验题7: 采用 狄 克 斯 特 拉 算 法 求 带权 有 向 图 的 最短路径

日 的: 领会狄克 斯特拉 算 法 求 带 权 有 向 图 中 单 源 最 短路 径 的 过 程和相关 算法 设计 。

内容: 编写一个程序exp8-7. cpp, 实 现 求 带 权 有 向 图 中 单 源 最 短路 径 的狄克 斯 特 拉 算

法 ,并 输出如 图 8. 54 所 示 的 带权 有 向 图 G 中 从 顶点 0 到 达 其 他 各 项 点 的 最 短路 径 长度和

最 短路 径 。

实验题8: 采用 弗洛伊 德 算法 求 带权有 向 图 的 最短路 径

目的: 领会 弗洛 伊 德算法 求 带权有 向 图 中 多 源 最 短路 径 的 过 程和相关 算法 设计 。

内容: 编写一个程序exp8-8. cpp,实现求带权有向图中 多 源 最 短路 径 的 弗洛 伊德算

法 ,并 输出 如图 8. 54 所 示 的 带权有 向图 G 中 所 有 两 个 顶点 之间 的 最 短路 径 长 度和最 短

路径。

实验题9:

求 AOE 网 中 的 所 有关键活动

的: 领会拓扑排序和 AOE 网 中 关键 路 径 的 求解过 程 及 其 算法 设计 。

aa

内 容: 编写一个程序exp8-9. cpp, 求图 8. 45 中 AOE 网 的所有关键活动。

从 设 计 性 实验

实验题10: 求有向 图 的 简单 路 径

目的: 掌握 深度 优先 遍历和 广度 优先 遍历 算法 在 求解图路 径 搜索 问题 中 的 应 用 。

内 容: 编写一个程序exp8-10. cpp ,设计 相关 算法 完成以下 功能 。

(1) 输出 如 图 8. 56 的有向图 G 从 顶点 5 到 顶点 2 的所有简单路径。

311

数据 结构教程

[第! 5人版

(2) 输出如图 8. 56 的有向图 G 从 顶点 5 到 顶点 2 的所有 长 度为 3 的简单路径 。

(3) 输出如图 8. 56 的有向图 G 从 顶点 5 到 顶点 2 的 最短路径 。

实验题11: 求 无向图 中 满足约束 条件 的 路径

目的: 掌握 深度 优先遍历 算法 在 求解图路 径 搜索 问题中的应用 。

内容: 编写一个程序exp8-11. cppb, 设计 相 关 算 法 ,从 如 图 8. 57 所 示 的 无 向图中 找 出 满

足以下条件 的所有 路 径 。

图 8.56 一个有向图

图8. 57 ”一个无向图

(1) 给 定 起 点 wx 和终点。

(2) 给 定 一 组 必 有经 点 ,即输出 的 路 径 必 须 包含这 些 顶 点 。

(3) 给 定 一 组 必 避点 ,即输出 的 路 径不能 包含这 些 顶 点 。

实验题12: 求解 两 个 动物 之间 通 信 的 最 少 翻译问题

目的: 掌握广度 优先 遍历 算法 在 求解实际 问题中的应用 。

内容: 编写一个程序exp8-12. cpp,完成以下功能。

据 美国动物 分 类 学 家 欧 内 斯特。 迈 尔 推算 ,世界上有 超过 一 百 万 种 动物,各 种 动物有 自

己的语言 。假 设 动物A 可 以 与 动物忆 进行通信 (通信 和是双向 的) ,但 它 不 能 与 动物 C 通信,

动物 C 只 能 与 动物已 通信 ,所以 动物A、C 之间 通 信 需 要 动物忆 来当翻译。问 两 个 动物之

间 相 互通 信 最 少 需要 多 少 个 翻译?

测试文本 文件 test. txt 中 的 第 一行包 含 两 个 整数 (2 过 "和受200) .mm(1 志 mm和受300) ,其中

妹 代 表 动 物的数量 ,动物 编号从 0 开始,个动物的编号 为 0 一 "一1, 表示 可以互相 通信 的

动物对数 ,接下来 的 疡行中包含 两个数字 分 别代表 两 种 动物可以 互相通信 。 再 接 下 来 包含

一 个 整数 ACE 生 20) ,代表 查询 的 数量 ,每个查找 包含 两 个数字 ,表示 这 两 种 动物想要 与 对 方

通信。

设计 算法 ,对 于 每个查询 ,输出 这 两 种动物彼此 通信 最 少需要 多 少 个 翻译, 若 它们 之 间

无 法通过 翻译 来通信 ,输出一1。

输入样本

输出 结果

0

1

38

01

12

兄

00

02

312

ESASJ国 |

实验题13: 求 带权 有 向 图 中 的 最 小 环

目的: 掌握 Floyd 算法 在 求解实际 问题中的 应 用 。

内 容: 编写一个程序exp8-13. cpp, 输 出 带权有 向 图 G 中 的 一 个 最 小 环 。

驶综合性实验

实验题14:

用 图 搜索 方法 求解迷宫问题

目的: 深入 掌握图遍历 算法 在 求解 实际 问题中 的 应 用 。

内 容: 编写一个程序exp8-14. cpp,完成以下功能。

(1) 建立一个 迷宫 对 应 的邻接 表 表示 。

(2) 采用 深度 优先 遍历 算法 输出从人口(1,1) 到 出 口CM,N)的所有迷宫路径。

实验题15: 用 破 圈 法 求 一个带权 连通 图 的 最小 生成 树

目的: 深入 掌握 图 的 复杂 操作 、

图 遍历 算法和 最 小 生成 树的概念 ,以 及 最小 生成 树 的 构

造算法 。

内 容 : 编写一个程序exp8-15. cpp, 采 用 破 圈 法 求 一 个带权 连通 图 的 最 小生成树,并用

图 8. 27 进行 测试 。

“ 破 圈 法 ?是 带权 连通 图 求 最 小 生成 树 的 另外一种方法 ,其 思路 是任意 取 一 个 圈 , 去 掉 圈

上 图 中 权 最 大 的 边 ,反复 执行这 个 步

又,直到图中没有圈为止。

313

查找又称为检索, 是指 在 某种数据 结构 中找间

上满足给定条件的

元素。查 找 是 一 种 十 分有用 的 操作 , 例如 在 学 生成 绩 表 上

查找某个

学 生 的 成绩 元 素 , 在

书馆的书目文件P 查找某编号的

书元

素等。

本 章 介 绍线性 表 查 找 , 树 表 查 找 和哈 希 表 查找等相关 算法设计

查找 算法 。

ES 查找 |

查找的基本 概念

米

被查找对 象是由 一 组 元 素 (或记录 ) 组 成的表 或 文件 , 称 为查找 表 。 查 找 表 中 的 每 个 元

素 则 由 若干个数据 项 组 成 ,其 中 指定 一 个数据 项为关键 字(key) ,所 有 元 素在关键字上 的 取

值是唯一的。在 这 种 条件 下 ,查找(search) 的 定义是给 定一个值 ,在 含有宛 个 元 素 的 表 中

找出关键字等于A 的 元 素。若 找到 , 则 查找 成 功,返回 该 元 素的信息 或 该 元 素在表 中 的 位

置; 否则 查找 失败 ,返回 相关 的 指示 信息 。

因为 查找是对 已 存人到 计算 机 中 的 数据 进行的运算 ,因此 在 研究 各 种 查找 方法时,首先

必须 弄清 这 些 查找 方法 所 需要 的 数据 结构 (尤其是 存储结构 ) 是 什么 ,对 表 中 关键 字 的 次 序

有 何 要 求 ,例如 ,是 对 无序数 据 查 找 还 是 对 有 序数 据 查找?

为 了 提高查找 速度,常常用 某 些

特殊 的 数据 结构 来 组织表 ,或对表事先 进行 诸如 排序 这 样的运算 。

若 在 查找 的 同时对 表做 修改操作 (如 插入和 删除) , 则 相应 的 查找 表 称 为 动态查找 表

(Cdynamic search table)。若 在 查找 中 不 涉及 表 的 修改 操作 , 则 相应 的 查找 表 称为静态 查找

表 (static search table)。

查找也有 内 查找和 外 查找 之 分 。若整个 查找 过 程 都 在内存 中 进行 , 则

称 之为 内 查找 (internal search); 反之 , 若 查找 过 程 的需要 访问 外 存 , 则 称 之

为外查找 (external search) 。

在 查找 运算 中 时间 主 要 花费 在 关键 字 的比较上 ,把 平均需要 和 给 定 值

玉 进 行比较 的 关键 字 次 数 称 为平均 查找 长 度(Average Search Length,

视频讲解

ASL),其定义如下 :

ASL = 六 ice;

一1

其 中 心 是 查找 表 中 元 素 的 个 数。访 是查找第; 个 元 素的概率 ,通常假设 每 个元素 的 查找 概

率 相等,此 时 户 =1/z(G近;过2 ,c: 是找到第; 个 元 素 所 需 的 关键 字 比 较 次 数 。

ASL 分 为 查找 成 功 情况 下 的 ASLaa 和 查找 不 成 功(失败?情况下的 ASLFaa。

ASLaa 表 示 成 功 查找 到 查找 表 中 的 元 素 ,平均需要关键字比 较 次 数 户 为 查找到 第

个 元 素 的概率,有 >) 六-1 。

ASLF#ta 表 示 没有找到 查找 表 中 的 元 素 ,平 均需要 关键 字比较 次 数 假设共有 zm 种查

接 失 败情况,g 为第; 种情况的概率;有 > =1 。

显然,ASL 是衡量 查找 算法 性 能 好 坏 的 重要 指标。一 个 查找 算法的ASL 越 大 ,其时间

人性 能 越 差; 反之 ,一 个 查找 算法的ASL 越小 ,其 时 间 性能越好 。

数据 结构教程

[第! 5人版

线性 表 的 查找

演

线性 表 是 一 种 最 简单的查找 表 。 本节将介绍 3 种 在线性 表 上 进行查找 的 方法,它们 分

别 是 顺序 查找 、 折 半 查 找 和 分 块查找 。

查找 与 数据 的 存储 结构有关 ,线性表有 顺序和 链 式 两 种存储 结构。这 里 只介绍以顺序

表 作 为存储 结构 的相关 查找 算法 ,顺序 表 属 于 静态 查找 表。为 了 算法 通用 ,用 于 查找 运算 的

顺序 表 采 用 数组 表示 ,该 数组 元 素的类 型 声明如 下 :

typedef int KeyType;

typedef struct

{

KeyType key;

InfoType data;

} RecType;

// 定 义 关键 字 类 型 为 int

//关键字项

// 其 他 数据 项 ,类 型为InfoType

// 查 找 元 素的类 型

在 介绍 算法 时 ,为了突出 主题 ,主要考虑元素中的关键字项。

921 顺序 查找

顺序查找(sequential search) 是 一 种 最 简单的查找 方法。它 的 基本思路是从 表 的 一 端

向 另一端逐个 将 元 素的关键字和 给 定 值&比 较 , 若 相等 , 则 查找 成 功,给 出 该元素 在 查找 表

中 的位 置; 若 整个查找 表 扫 描 结束后 仍 未找到 关键 字 等于& 的 元 素 , 则 查找 失败 。

顺序 查找 的 算法如下 (在 顺序 表 RL0..”

一1]中查找关键字为& 的 元 素 , 成 功时 返回 找

到 的 元 素的逻辑 序号,失败时 返回 0) :

int SeqSearch(RecType R[I] ,int n,KeyType k)

{

inti一0;

while (i<n 本 & RD口.key!一k)

// 从 表 头 往 后 找

i十十;

让 (Ci>一n)

Teturn 0;

else

// 未 找到 返回0

return i十1;

// 找 到 返回 逻辑序号 i 十 1

)}

从 顺序 查找 过 程中可以 看 到 ,c;(查找第 ; 个 元 素 所 需要 的 关键 字比 较 次 数)取 决于该 元

素 在 表 中 的位 置

。 如查找表中的第 1 个 元 素 RLO] 时 仅 需比较 一 次; 而查找表中的第 ”个

元素RLz一1时 需比较半 次,即 c =一;。 因 此 ,成功时 的 顺序 查找 的平均 查找 长度为 :

ASLR 之 2c;

1S 1、vnzo+l)
克 2 X 二 2

2+1
3

也 就 是说 ,顺序 查找 方法 在 查找 成功时 的 平均 比较 次 数约为表 长的一 半 。

若 & 值 不在表 中 , 则 必须

进行二次 比较 之后才能 确定 查找 失败,所以ASLF帮a一 2。

因此 顺序 查找 算法 的平均时间 复 杂 度为O(") ,其中?为查找 表 中 的 元 素个数 。

316

ES查找|

在 上 述 顺序 查找 算法中 ,可 以在 尺 的 末尾 增加 一 个 关键 字 为& 的记录 , 称 之 为 哨兵 ,这

样 查找 过 程 不再需要 判断; 是否 超 界,从 而 提高 查找 速度 。 对 应 的算法如下 :

int SeqSearch1(RecType R[] ,int n,KeyType k)

{

inti

一 0;

有R[n] .key一ki;

while (R口.key!一k)

// 从 表 头 往后找

i十十;

让 (Ki 一一D)

Teturn 0;

else

// 未 找到 返回 0

return i十1;

// 找 到 返回 逻辑 序号 i 十 1

)}

归纳 起 来 ,顺序 查找 的 优点 是 算法 简单,且 对 表 的结构 无 特别 要 求 ,无 论是用 顺序 表 还

是 用链表 来存放 元 素,也 无论是元 素 之 间 是 否 按 关 键字有 序 , 它 都 同样 适用。顺 序查找的缺

点 是 查找 效率 低,因 此 当 ) 较大时 不 宜 采 用顺序 查找 方法 。

922 折 半 查找

折 半 查找(binary search) 又 称 二 分 查找 , 它 是 一种效率 较 高的查找 方法。但 是 , 折 半 查

找 要 求线性 表 是 有序 表 , 即 表 中 的 元 素 按 关键字有序。在 下 面 的 讨论中 ,假设 有 序 表 是递增

有 序 的 。

后-丰

折 半 查找 的 基本 思路 是 设 RLlow..high]

是当前的查找区 间 , 首 先确定

该区间 的 中点 位置mid= | (low十high)/2 |,然后将待查的& 值 与RCmid].

key 比较:

(1)

若 & 一 RLmid]. key, 则 查找 成功并 返回 该元 素 的逻辑 序号 。

视频讲解

(2)

若 &<RLmid]. key,则由表的有序 性 可知RLmid..high]. key 均 大 于 A, 因 此 若 表 中

存在 关键 字 等于& 的 元 素 , 则该元 素 必 定 是 在 位置mid 左边的子表 R[low..mid一1]中 , 故

新 的 查找 区间 是 左子表 RLlow..mid一1 。

(3)

若 >RLmid]. key,则关键字为& 的元 素 必 在 mid 的 右子表 RLmid十1..highj]中,

即 新 的 查找 区间 是 右子表 尺Cmid 十 1..high]。 下 一 次 查找 是 针对 新 的 查找 区间 进行 的 。

上 述 过 程如 图 9. 1 所 示 。 可 以 从 初始 的 查找 区间 R[0..”

一菇开始,每经过一次与 当前

查找 区间 的 中 点位 置 上 的 关键 字 比 较 , 就可 确定 查找 是 否 成功,不 成 功 则 当前 的 查找 区间 缩

小 一 半 。 重 复 这 一 过程直到找到 关键 字为 & 的元 素 ,或者直到 当前 的 查找 区间 为 空 (即 查找

失败 )时 为止。

as

RIlow]

...,RImid-1] RImid] RImid+l]

...,

Rhign]

K<R[mid].key

K>R[mid].key

j=R[mid].key

RIlow]

...

Rmid-1] | 查找 成功

RImid+l]

...

Rhigh]

图 9.1 折 半查找过程

317

数据 结构教程

[第! 5版

其 算法如 下 (在 有序 表 RL0.. 一 1 中 进行 折 半 查找 ,成 功时 返回 元 素 的 逻辑序号,失败

时 返回 0):

int BinSearch(RecType R[] ,int n,KeyType k)

// 折 半 查 找 算法

{

int low=0,high=n一1,mid;

while (low<一high)

{

mid 一(low 十 high)/2;

// 当 前 区 间 存 在 元素时 循环

这 (k 一一R[mid] .key)

// 查 找 成 功返回 其逻辑 序号 mid十1

return mid十1;
让 (k<RLmid] .key)

high一mid一1;

// 继 续 在 RLlow..mid一巧中 查找

else

}
return 0;

)》

low一mid十 1;

// 继 续在R[mid十1..high] 中 查找

/>RLmid] .key

// 未找到时返回 0( 查 找 失败?

折 半查找过 程可 用 二 又 树 来描述 ,把 当前 查找 区 间 的 中间 位 置 上 的元 素 作为根 ,由 左 子

表 和 右 子 表 构造的二 又 树 分 别 作为 根 的 左 子 树和 右 子 树 , 由 此 得 到 的 二 又 树 称 为描述 折 半

查找 过 程 的判定树 (decision tree) 或 比较 树(comparison tree)。 判定树 中 查找 成 功对 应 的

结 点 称为内 部结 点 ,而 查找 失败对 应 的结 点 称 为外 部结 点。构 造 外 部结 点 的 方法 是 ,对 于 内

部结 点 中 的 每 个 单 分 支 结 点 ,添加 一 个 作为它的 孩子 的 外 部 结 点 使其变成双 分 支 结点; 对

于 内 部 结 点 中 的 每 个叶子结 点 ,添加 两个作为 孩子 的外 部结 点 使 其 变 成双分 支 结 点

。 判定

树 刻画 了 在所有 查找情况 下 进行 折 半 查找 的比较 过 程 。

注意: 折 半 查找判定树 的形态 只与表 元 素 个数中 相关 ,而 与输入 实例 中 有 [0..2一1]. key

的取值无关。

例如 ,含有 11 个元 素CR[0..10])

的有序表可用图 9.

2 所示 的 判定树 来 表示 ,图 中 的 圆

形结 点 表示 内 部结 点 ,内 部 结点中 的 数字 表示 该元 素 在 有序 表 中 的 下标。长方形结点表示

外 部结 点 ,外部 结 点 中 的 两 个值表 示 查找 不 成功时 关键 字 等于给 定 值 的元素所 对 应 的 元 素

序号 范围 ,如 外 部结 点 中 “一 思 表示 被 查找 值&是 介 于 尺 [i. key 和 尽 L7. key 之间 的 , 即

及 [让 .key<A<RL门key, 而 "一ce 一一1 表示 A<RL0]. key 对 应 的 外部结 点 “10 一co? 表

示 A>RL10]. key 对 应 的 外 部结 点 。

图 9.2 RL0..10]

的二分查找的判定 树(z 一11)

318

ES查找|

显然 , 若 查找 的 元 素 是 表 中 的 元素RL5](处于第 1 层),只需进行 1 次 比较 ; 若 查找 的

元 素 是 表 中 的 元 素 RL2]或RL8] (均处于第 2 层) ,分 别 需 进行 两 次比较 ; 若查找的元素是

表 中 的 元素RL0]RL3]、R[6]或RL9] (均处于第 3 层),分别需进行 3 次比较; 若 查 找 的 元

素是表中的 元 素 RLI]、RI4]、RL7]或RL10] (均处于第 4 层),分别需进行4次 比较 。

说明: 上述 关键字比 较 次 数 并 不 是 算法 中 严格 的比较次数,在BinSearch 算法中首先将

和 与 尺 Lmid]. key 进行 1 次 比较 , 若 不相等 ,再进行上<RLmid]. key 的 比较 。也就 是说 , 若

& 一 R[Lmid]. key, 需 要 1 次比较 , 若 A<一RLmid]. key, 需 要 两 次比较 ,若人 ARLmid]. key,也

需要两次比较。这 里讨论的关键 字比 较 次 数 是 假设 和 及 Lmid]. key 比较 1 次 就 可以 知道 3

种 情况 ,即 关键 字比 较 的 个 数。实际上 ,这 样 简化 的计算 不 影响算法 的 时间 复 杂 度 ,后 面都

是 采用 这 种 假设 。

在 7 个 元 素 的 折 半 查找 判定树中 , 设 关键 字 序列 为 (AAA) ,并 有 所 二 忆 荆 天

A ,查找 司 的 概率为 b; ,显然有交 种 查找 成功的 情况 ,对 应 的 内 部 结点有 交 个。成功的折半

查找 过 程恰好 是 走 了 一 条 从 判定树 的 根 到 被 查结 点 (内 部 结 点 ) 的 路 径 ,经 历比较 的 关键 字

次 数 恰好 为 该元素 在 树 中 的 层 数 ,所 以 查找 成 功 的平均 查找 长 度 为 字 户 Xlevel(A) ,其中

level(Ai)

表示关键字 廊 对 应 内 部 结 点的层次 。

在 这 样 的判定树中 总 共有 2 十 1 种 查找 失败 的 情况,对 应 的 外 部结 点有 十1 个 ,用

尼 (0 过 ;过 思 ) 来表示。羽 包含的所有关键字A 满足条件 A<A ,局包含的所有关键字& 满足条

件 忆 <A<A+i ,已 包含的关键字A 满足 条件 全 已。 而 失败 的 查找 ,其比较过 程 是 经历了 一 条

从 判定树 根 到 某 个 外 部结 点 的 路 径 , 所 需 的 关键 字 比较 次 数 是 该 路径上 内 部 结 点 的 总 数。设

4 是 查找 属于 已 中 关键 字 的 概率 ,那么 不成功 的 平均 查找 长度为 站 4X(level(u)一1) ,其

中 level(xw)表示 已 对 应 外 部 结 点 的层次 。

为讨论 方便 ,不 妨 设判定树 中 内 部 结 点 的 总 数为 2 一 2 一 1, 将 该判定树近 似 看成是 高

度 为 =log:(z

十1)的满二又树(高 度疡不计 外 部结 点), 如 图 9. 3 所示。树 中 第 守 层 上 的 结

点 个 数为2 ,查找 该 层上的 每 个 结 点 恰好 需要 进行 ;次 比较。因 此 ,在 等概率 假设下折 半

查找 成 功时 的平均 查找 长 度 为 :

ASLw = > pic > 2 xi 一 半 上 Xlogs 二1 1、log n+1 -1

,

1

所

所

高 度 为

7的满二 又 树

Ta

QQR RAR RAR RAR

吕

本

病

辣 外部结点层

图 9.3 判定 树 近 似 看 成是一 棵高度为六的满二又树

319

数据 结构 教程

\ 上 GO

折 半 查找 在 查找 失败时所 需比 较 的 关键 字 个 数不超 过 判定树 的 高度, 在 最 坏情况 下 查

找 成 功 的 比较 次 数 也 不 超过 判定树 的 高 度 。

一 般 情 况 下 ,判定树中 度数小 于 2 的结 点 只 可 能 在最下 面 的 两 层上(不 计 外 部结 点), 所以

个 结 点 的判定树 高度和 ? 个结 点 的完全 二 又 树 高 度相 同 ,即 为 log: Cz十1)] 。 由 此 可 见 , 折

半 查 找 的 最 坏 性 能 和 平均 性能相当 接近 。 归 纳 起 来 , 折 半 查找 算法 的时 复杂 度 为 DClogsz) 。

也 可 以 这 样 简单地 推导 , 设 CCz) 为 个 元 素 进行折半 查找 的比较次 数,有以 下 递推式 :

CGD) =一 1

CO) = COV2)十1 当 )交二 1 时

则: CO) 王 CCOxV2) 十 1 一CGOz/22) 十 1 十 1

一 ...

一 COMV26十1十...十1

一 1 十 ... 十 1一|log:z|= OClog:7)

虽然 折 半 查找 的 效率高,但 要 求 查找 表 是 按 关键字有 序 的 。另 外 , 折 半 查找 需 确 定 查找

的 区 间 , 因 此 要 求查找 表 的 存储 结构具有 随机 存 取 特 性,所以 只 适用 于 顺序 表 , 不 适合于 链

式 存储 结构。需 要 注意 的是,不 能说 折 半 查找不能 用 于 链 式 存储 结构 ,只 是 说 采用 顺序 表 时

折 半 查找 算法设计 更方便 ,效率 更 高 。

【例 9.1】 给 定 11 个 数据 元 素 的有序 表 (2,3,10,15,20,25,28,29,30,35,40),采用折

半 查 找 ,试问 :

(1) 若查找给定值为20 的 元 素 , 将 依次 与 表 中 的哪些 元 素 比较?

(2) 若查找给定值为26 的 元 素 ,将 依次 与 哪些元素 比较?

(3) 假设 查找 表 中 每个元 素 的 概率 相同 , 求 查找 成功时 的 平均查找 长度和 查找 不成功

时 的 平均查找长度。

对 应 的 折 半 查找 判定 树如 图 9.4 所示。

(1) 若查找给定值为20 的 元 素 ,依次与表中的25、10、15、20 元 素比 较,共 比较4 次。

(2) 若查找给定值为26 的 元 素 , 依 次与 25 .30、28 元 素比较 , 共比较 3 次。

(3) 在 查找 成功时 会找到 图 中 某个内 部 结 点 , 则 成功时 的 平均 查找 长 度 :

ASLa功

1X1 十2X2 十4X3 十4X4

1]1

3

第1层: 共 1 个 结 点 ,每 个比较1次

第2层: 共 两 个结 点,每 个比较两次

一一 第3层: 共4 个结点,每 个比较3次

一 第4层: 共 4 个 结 点 ,每 个比较4次

图 9.4 折 半 查找判定树

在 查找 不 成功时 会 找到 图 中 某 个 外 部 结 点 , 则 不 成 功时 的 平均 查找 长度:

ASLAa坟一人 一 3.67

320

ES查找|

923 索引 存储 结构 和 分 块 查找

索引存储结构(index storage structure) 是 在 存储 数据 的 同时 还 建立 附加 的 索引 表 。 索

引 表 中 的 每一项 称 为 索引 项 ,索引 项 的 一 般 形式 为(关键字, 地 址 ) 。

扫--扫

其中 ,关键 字 唯 一标识一个 结 点 ,地 址 作为指向该关键 字 对 应结 点 的指

针 ,也 可以 是相对 地 址(如 数组的下标 ) 。

例如 ,对 于 例 1. 1 的逻辑结构 City, 将 区 号 看 成是关键 字 , 其 索引 存储

结构 如 图 9. 5

所 示 。 索引表由(区 号,地 址 ) 组 成 ,其中区 号 按 递增次 序

排序。

索引 表 :

主 数据表 :

地址 ”关键字

地址

地 址

区 号 城市名

300 | 010

310 | 021

320 “| 025

330 | 027

340 “| 029

100

130

220

160

190

100

130

160

190

220

010

021

027

029

025

图 9.5

”City 的 索引 存储 结构

Beijing

说明

首都

Shanghai

直辖市

Wuhan 湖北省省会

Xian 陕西省省会

Nanjing 江苏省省会

在 索引 存储结构中 进行 关键 字 查找时 先 在 索引 表 中 快速查找 (因为 索引 表 中 按 关键 字

有 序 排列 ,可以 采用 折 半 查找) 到 相应 的 关键 字 , 然 后通过 对 应 的 地 址找到 主 数据 表 中 的

元素。

索引 存储 结构 可以 提高 按 关 键 字 查找 元 素 的效率 ,其 缺点 是 需要 建立 索引 表 而 增加 时

间 和空间的开销。

分 块查找(block search) 是 一 种 性能介 于 顺序 查找和 折 半 查找 之间 的

查找 方法。它 要 求 按 如 下 的 索引 方式 来存储 线性 表 : 将表 RL0..”一1均分

为5块 , 前 0 一 1 块中的 元 素 个 数为:一 | z/2 | ,最后一 块 ( 即第2 块 ) 的 元 素
数小于等于 s; 每 一 块中 的 关键 字 不 一 定是有 序 的 ,但 前 一 块中的 最 大 关键

旺 :

认 而 和

字 必 须小 于 后 一 块中的 最小 关键 字 , 即 要 求 整个表 是“分 块有序”(block order)的。

抽取 各 块中的最大 关键 字 及 其 起 始 位 置构成 一 个 索引 表 IDX[0..2一1],即IDX[i(0所

is<0一1)中存放着第 ;十1 块 的最大 关键 字 及 该 块在表 尺 中 的 起 始 位 置 。由 于 表 RR 是分块

有 序 的,所以 索引 表 是 一个 递增有序表。
索引 表 的 数据 类 型声明如 下 :

|

# define MAXI < 索引 表 的 最 大 长 度 >

typedef struct

{

KeyType key;

//KeyType 为关键字的类型

int link;

// 指 向 对 应 块 的 起始下 标

} IdxType;

// 索 引 表 元 素 的 类 型

321

数据 结构教程

[第1 5 【版

例如 , 设 有 一 个 线性表 采 用顺序 表 存 储 ,其中 包含 25 个元 素 ,其 关键 字序列 为 (8,14,6,

9,10,22,34,18,19,31,40,38,54,66,46,71,78,68,80,85,100,94,88,96,87)。 假 设将 25

个元素分为 5 块(4 一5) ,每块中有 5 个元素(*=5) ,该 线性表 的 索引 存储结构 如 图 9. 6 所

示。第 一 块中的最大 关键 字 14 小 于第 2 块中的 最小 关键字 18,第 2 块中的最大 关键字 34

小 于 第 3 块中的 最 小关键字 38,依此类推。

14 | 34 | 66 | 85

|100| key

0|15|110115|120|2ok

索引表

]

国光 国国则

188 196187
8|1141619110122134118119131|1401381541661461711781681801851100|194

0 123 41456789 1011213 1415 16

.17

18

19

20 2 22

23

24

图 9.6 分 块查找 的 索引 存储 结构

例如 ,在 图 9. 6 所示 的 存储结构 中 查找 关键 字 等于给 定值 &= 80 的 元 素 ,因为索引表

小 ,不 妨 用 顺序 查找 方法 查找 索引 表。即 首先将& 依次和 索引 表 中 的 各 关键 字 比较, 直 到找

到第 1 个关键字大于等于& 的 元 素 , 由 于 A<85 ,所以 关键 字 为 80 的 元 素 若 存 在 , 则 必定 在

第 4 块中; 然后由 IDXL3].1link 找到第 4 块 的 起 始地址 15, 从 该 地址开始 在 RL15..19]中进

行顺序查找,直到 RL18]. key一上为止 。 共 有 8 次关键字比较。

若 给 定值 &一30, 先确定在第 2 块中,然后在该块中查找。因该块中查找 不 成 功,故 说

明 表 中 不 存在 关键 字 为 30 的元 素 。 共有 7 次关键字比较。

分 块 查找 的 基本 思路 是 首先 查找 索引 表 , 因 为 索引 表 是 有 序 表 , 故可 采用 折 半 查找或顺

序 查找 ,以 确定 待 查 的元 素 在 哪 一 块; 然后 在 已确定 的 块中进行 顺序 查找 ( 因 块 内 元 素 无

序 , 只 能 用 顺序 查找 ) 。

采用 折 半 查找 索 引 表 的 分块查找 算法如 下 (索引 表 工 的 长 度 为2) :

int IdxSearch(IdxType ID ,int b,RecType RD ,int n,KeyType k) 。 //分块查找
{

//s 为 每 块的元 素 个数,应为| nb |

int s 一(n十b 一1)/b;

一b一1,mid,i;
int low 王 0,high

while (low<一high)

// 在 索引 表 中 进行折 半 查找 , 找到 的 位 置为high十1

BE

人1

mid 一(low 十 high)/2;

这 (CI[Lmid] .key>一k)

high一mid一1;

else

low王mid十1;

}
// 应 先 在 索引 表 的 high十1 块中查找 ,再 在 主 数据 表 中 进行 顺序 查找

i 一 ILhigh十]] .link;

while (i<一I[high十]] .link十s一1 &&& RD加 .key!一k)

i十十;

这 (i< 一 I[high 十 ]] .link 十 s 一 1)

return i十1;

// 查 找 成功,返回 该元素的逻辑 序号

322

ES查找|

else

return 0;

}

// 查 找 失败 ,返回0

由 于 分 块查找 实际上 是 进行了两 次查找 过 程(所以 分 块查找最少 需要 2 次关键字比

较 ) , 故整个 查找 过 程 的平均 查找 长 度 是两次 查找 的 平均 查找 长 度之和 。

若有汪 个 元 素 , 每 块中有

个 元 素 (R 中总 块数2 = | 2z/s|]) ,分 析 分 块查找 在 成功情况

下 的 平均 查找 长 度如 下 :

若以 折 半 查找 来 确定 元 素 所 在 的 块 , 则 分 块查找 成 功时 的平均 查找 长度为 :

ASLm王ASLm 十 ASLs

一 log:(2十1)一1十 同

十1

一 logs(o/s 十D) 十 部 或 log:(C0 十 1) 十 总

显然,当 * 越 小 时,ASLe 的 值 越 小 ,即当 采用 折 半 查找确定 块时 每 块 的 长 度 越小越好 。

若以 顺序 查找 来 确定 元 素 所 在 的 块 , 则 分 块查找 成 功时 的平均 查找 长度为 :

ASLA= ASLw 十 ASL。 = 4上+ 汪 一二二 + 十1 或 地6 二 5) 十 1

显然,当 s=w时,ASLes

取极小值 十 1, 即 当 采 用 顺序查找确定块时各块中的 元 素数

选 定为,时 效果 最佳 。

分 块 查找 的 主要 缺点 是 增加 一 个 索引 表 的 存储 空间和 增加 建立 索引 表 的 时间 。

【例9. 2〗 对 于具有 10 000 个 元 素 的 文件。

(1) 若 采用 分块查找 法 查找 ,并 通过 顺序 查找 来确定 元 素 所 在 的 块 , 则 分成几 块 最 好 ?

每 块的最 佳长度为多 少? 此 时 的 平均 查找长度 为多少 ?

(2) 若 采用 分 块查找 法 查找 ,假定 每 块 长 度为 *=一20, 此 时 的 平均 查找 长 度是多 少 ?

(3) 若 直接 采用顺序 查找和 折 半 查找 ,其 平均 查找 长度各 是 多 少 ?

(1) 对 于 具有 10 000 个 元 素 的 文件 , 若 采用 分块查找 法 查找 ,并 通过顺序 查找 来 确

定 元 素 所 在 的块, 每 块中的 最佳 元 素个数 *= W10 000 = 100 ,总的块数50= [zs 1]=100。 此

时有:

ASLaa 一 去CS+1 = 100+1= 101

如 果 此 时 采用 折 半 查找 确定 块,平均 查找 长 度 为 :

ASLaa 一 log:(0十1) 十 立 一 log*101十50

57

(2):一20,则 0一[ms|三10 000/20=500。
在 进行 分 块查找时 , 若 用 顺序 查找 确定 块 ,则 有 ASLaa 一 于 CO 十9) 十 1 一260 十 1一261。

在 进行 分 块查找时 , 若 用 折 半 查找 确定 块 ,则 有 ASLaa 一 logs (0 十1D) 十 广一logz501 十

10s19。

323

数据 结构教程

[第! 5版

(3) 若 直接 采用 顺序 查找 ,则 有 ASLaam一(10 000 十1)/2一5000. 5。

若 直接 采用 折 半 查找 ,则 有 ASLaa一log:10 001一1>:13。

由 此 可 见 , 分 块查找 算法 的 效率 介 于 顺序 查找和 折 半 查找 之间 。

树 表 的 查找

米

从 9.2 节 的讨论可知,当 用 线性 表 作为 表 的 组织形 式时可 以 有 3 种查

找法,其 中以 折 半 查找 的效率 最 高

。但 由 于 折 半 查找 要 求表中 的 元 素 按 关

键字有 序 , 且 不 适合 采用 链表 存储 结构,因此 当 表 的搬入 或 删除操作 频繁

时 ,为 维护表 的有序 性 ,需要 移动表 中 的 很 多 元 素。这 种 由 移动 元 素 引 起 的

额外时间 开 销 会 抵消 折 半 查找 的 优点。若 要 对 动态查找 表 进行 高效率 的 查

视 所讲解

找 ,可 采用 本 节 介绍 的 几 种特殊的二 叉树/ 树 作为 表 的 组 织 形 式 ,在 这 里 将

它们统称为树表(tree table) 。下 面 分 别 讨论 在 这 些 树 表 上 进行 查找和 修改 操作 的 方法 。

931 二义排序树

又称二又搜索树,其定义为二又
二 叉 排 序 树(binary search tree,BST)

排序 树 或 者 是 空树 ,或者是 满足以 下 性 质 的 二 又 树 。

(1) 若 根结点 的 左 子 树非 空 , 则 左 子树上 的所有 结 点 关键 字 均 小 于 根

结点关键字;

(2) 若 根结点 的右子 树非 空 , 则 右 子树上 的所有 结 点 关键 字 均 大 于 根 结 点 关键 字 ;

(3) 根 结 点 的 左 、 右 子树本 身又各 是 一 棵 二 又 排序树 。

上 述性质 简称 二 又 排序 树 性 质(BST 性质) ,故二 又 排序树 实际上 是 满足BST 性 质 的 二

又树。也 就 是说 ,二 又 排序树 是 在 二 又 树 基 础上增加 了 结 点 值 的约束 。

由 BST性质可知, 二 又 排序树中 的任 一 结点 zx, 其 左 子树中 的任 一结点 y( 若存在)的关

键字必小于 z 的 关键 字 , 其 右子树 中 的 任 一 结 点 *( 若 存在 ) 的 关键 字 必 大 于 z 的 关键字。

如 此 定义 的 二 又排序树中,各 结 点 关键 字 是 唯一 的。但 在实际应用中 ,不 能 保证 被查找 的 数

据集中 各 元 素的关键 字 互 不相同 ,所以 可 将 二 又 排序树 定义中 BST 性 质(1) 里 的“小 于 ? 改

为 “小 于 等 于”, 或将BST 性 质(2) 里 的“大 于 ? 改 为"大 于 等 于”, 甚 至修改 为 左 子树关 键 字

大 , 右 子树关 键 字小。本 章讨论 的 均 为 满足前面BST 性 质 的 二 又 排序 树 。

从 BST 性 质 可 推出二 又 排序树 的 另 一 个 重要 性质:

按 中 序遍 历 该树所 得 到 的 中 序 序

列 是 一 个 递增有 序 序列 。

在讨论 二 又 排序树上 的 运算 算法 之 前声明 其结点 的 类 型如 下 :

typede fstruct node

{

KeyType key;

JInfoType data;

//元素类型

// 关 键 字 项

// 其 他数据域

struct node * lchild, * rchild;

// 左 \ 右孩子指针

}BSTNode;

和 二 又 链 一样 ,我 们 也 是 通过 根 结 点 指针 bt 来 唯一标识 一 棵 二 又 排序树 。

324

OOOLAEERREEI

在 二 叉 排序 树 中插入 一 个 关键 字为& 的 结 点 要 保证插入 后 仍 满足BST

性质。其 搬入过程是: 若 二 又 排序树 bt 为 空 , 则 创建一个 key 域 为上的结 点 ,

将 它 作 为 根结 点 ; 否则将 & 和 根结 点 的 关键 字 比较 , 若 两 者 相等 , 则 说 明 树 中

已 有 此关键字 ,无 须插入 ,直接返回假; 若 A<bt一> key, 则 将 & 插 和人根结点

号 讲

的左子树中,否则将它插入右子树 中。对 应 的递归算法 InsertBST()如下 :

视频讲解

bool InsertBST(BSTNode * &bt,KeyType k)

// 在 二 叉排序树 bt 中 插入 一 个 关键 字 为 上 的 结 点 , 若 插 人 成 功返回 真,否则 返回 假

{

这 (bt==NULL)

// 原 树 为 空 ,新插入 的 结点 为 根 结点

bt=(BSTNode * )malloc(sizeof(BSTNode)) ;

bt 一> key一 k;bt

一 > lchild一bt -> rchild一NULL;

Teturn truei

{

}

else 计 (k 一一bt 一> key)

// 树 中 存在相同 关键 字 的 结 点 ,返回假

Teturn false;

else 让 (k< bt 一 > key)

return InsertBSTCbt 一 lchild,k);

//插入 到 左 子树中

else

return InsertBSTCbt 一 rchild,k) ;

// 插 入 到 右 子树中

上 述 算法 是 在 根 结 点指针 为 bt(bt 可 能 为 空)的 二 又 排序 树 中 插入 一 个 关键 字 值为人

的结 点 ,bt 可 能 发生变 化 ,所以 一 定 要 用 引用 类 型 ,即将 bt 改变 后 的值回 传给实 参 ,和 否则 可

能出现错误。

创建一棵 二 又 排序 树是从 一 个 空树开 始 的 ,每插入 一 个 关键 字 ,就 调用 一 次 插入 算法 将

它 搬入 到 当前 已 生成的二 又 排序 树 中。从 关键 字数组 c[0..2 一 菇 生成二又 排序 树 的 算法

CreateBST(C)如下 :

BSTNode * CreateBST(KeyType AT] ,int n)

// 创 建二又 排序树

// 返回BST 树 根 结 点 指针

{

, BSTNode * bt=NULL;

int i一0;

while (i<p)

// 初始时 bt 为 空树

InsertBSTCbt,a[);

//将关键字 a品插入 二 叉 排序树 bt 中

i十十;

{

}》

return bt;

)}

// 返 回 建立 的 二 叉 排 序树的 根 指针

,3)构造二又排序树的过程如下,
假设 c[]={3,1,2} ,调用 CreateBST(a

@ 执行 CreateBST(a,3) bt=NULL,第 1 次 循环 调用 InsertBSTCbt,3)。

@ 调用 InsertBST(bt,3)

的执行过程如图 9.7 所 示 ,返回只有 一 个结 点 (关键 字 为 3)的

二又排序树 bt。

数据 结构 教程

眶 第人5 【版

InsertBST(bt,3) [一一一一一一

创建关键 字 为
3 的 结 点 bt

1

上

1

1

上

的执行过程
图 9.7 InsertBST(bt,3)

@ 第 2 次 循环 调用 InsertBST(bt,1)

,其执行过程如图 9. 8 所 示 , 返回有 两 个 结 点 ( 关

键字分别为 3

和 1) 的 二 又 排序树 bt。

1<bt>keyG)

InsertBST(bt,D| InsertBSTbt,1)LU
[nsertBsTCOL 小]
btr>lchld=-bt
人

bt

|

四

bti=bt->lchild

bt

1

图 9.8 ”InsertBST(bt,1)
的执行过程

1

上
1 bt
1
1
1
|
|
一 一 一-
创建 关键 字 为

1 的 结点 bt

团 第 3 次 循环 调用 InsertBST(bt,2)

,其执行过程如图 9.9 所 示 , 返 回有 3 个 结 点 ( 关

键字分别为3.1、.2)

的二又排序树 bt。

InsertBST(bt,2)

下

bt

|
|
上

2<bt>keyG)|

1

|be>ichild=bt 一~ ,
1
1
1

1

|
最
1
的
折
1
册 (全 关
序
树
bt

j六 ”1
1
上

JInsertBST(bt,2) rr

下

| bt

bbu=bt_>lchild
2>btb->key(D)

1

bt->rchild=bb 一一 |
|
|

了

1
上

bb 1

1

TnsertBST(bb,2)

bb=bt->rchild
=NULL

|

的执行过程
图 9.9 InsertBST(bt,2)

@@ 返回 最 终 构造好 的 二 又 排序树 bt。

从 中 可以 看 到 ,每个结 点 插入 时 都需要 从 根 结 点 开始比较 , 若 比根结 点 的 key 值小,当

前 指针 移 到 左 子树,否则 当前 指针 移 到 右 子树, 如 此 这 样,直到 当前 指针 为 空 , 再 创建一个 结

点 ,由 当前 指针 指向 它 ,这 样 便 将 这 个 结 点插入 到 二 又 排序 树中了 。 因 此 可 知 ,任何结点插

326

ES查找|

入 到 二 又 排序树时 都是作为 叶子 结 点 插入 的 。

对 于 一 组 关键 字 集 合 , 若 关键 字 序 列 不 同,上 述 算 法 生成的二 又 排序 树 可 能 不 同。例

如 ,关键 字 序 列 为 (5,2,1,6,7,4,8,3,9),

生成的二又排序树如图 9. 10(a)所示; 关键字序列

为(1,2,3,4,5,6,7,8,9),

上述算法生成的二又排序树如图 9. 10(b)所示。显 然图 9. 10(Ca)

所 示 的 二 又 排序树 的 查找 效率 比图 9. 10(b) 的 好 ,因此 构造一棵 高 度 越小的二 又 排序树 查

找 效 率 越 高,下 一 小 节 就 来 讨论如 何 构造 这 种 查找 效率 高的二 叉 排序树 。

(a)

(b)

图 9. 10 两棵二 又 排序树

因为 二 又 排序 树的中 序 序列 是 一 个有序 序列,所以 对 于 一 个任意 的 关键 字 序 列 构造 一

棵 二 又 排序树 ,其 实质是对 此 关键 字 序 列 进行 排序,使 其 变 为有序 序列。“ 排 序 树” 的名称 也

由此而来。

另外 ,二 又 排序树 销毁 算法 DestroyBST 的 设计 思路 与二又 树 销 毁 算 法 完全 相同 。

因为 二 又 排序 树 可 看 成 是有序 的,所 以 在 二 又 排序树上 进行 查找和 折

8

半 查 找 类 似,也 是 一 个逐步 缩小 查找 范围 的 过 程 。递归 查 找 算 法

SearchBST()

如下(在二又排序树 bt 上 查找 关键 字 为 & 的 元 素 ,成 功时 返回

该 结 点 指针 ,否则返回NULL):

BSTNode * SearchBST(CBSTNode * bt,KeyType k)
{

诈 (bt==NULL |‖ bt 一 key 一一k)

// 二 叉 排 序树查找
// 递归结束条件

Teturn bt;

这 (k<bt 一 key)

Teturn SearchBSTCbt -> lchild,k);

// 在 左 子树中 递归 查找

return SearchBSTCbt 一 > rchild,k);

// 在 右 子树中 递归 查找

Pa

else

)}

如 果 不 仅 要 找到 关键 字 为上的 结 点 ,还 要 找到 其 双亲 结 点 ,采用 的 递归 查找 算法如 下 :

BSTNode * SearchBST1(BSTNode * bt,KeyType k,BSTNode * 全 ,BSTNode * &D

/* 在 二 叉 排 序树bt 中 查找 关键 字 为 k 的 结 点 , 若 查找 成功,该函数 返回 该结点 的 指针 ,f 返 回其双亲
结 点 ;否则 ,该 函数 返回NULL,其调用方法如下 :

327

数据 结构教程

[第! 5人版

SearchBST1Cbt,x,NULL,f);

这 里 的第 3 个 参数 纪 仅 作 中 间 参 数,用 于 求 f, 初始 设 为NULL* /

{

, 计 Cbt一一NULL)

ff=NULL;

returmnCNULL) ;

{

}

else 让 (kk一一bt 一> key)

{ 全旨;

return(bt) ;

}

else 让 (k< bt 一 key)

return SearchBST1(bt 一 > lchild,k,bt,f);

// 在 左 子树中 递归 查找

return SearchBST1(bt 一 > rchild,k,bt,f);

// 在 右 子树中 递归 查找

else

}》

和 折 半 查找 的判定树 类似 , 二 又 排序树中 的结 点 作为 内 部结 点 ,可 以 添加 相应 的 外 部结

点 。具有 交 个 内 部结 点 的 二 又 排序 树 , 其 外 部结 点 的 个 数为 z十1。

显然,在二又排序树上 进行 查找 , 若 查找 成 功 , 则 是 从 根结 点 出 发走了 一 条 从 根结 点 到

某 个 内 部结 点 的 路 径 ; 若 查找 不 成 功 , 则 是 从 根结 点出 发走了 一 条 从 根 结 点 到 某 个 外 部 结

点的路径。因 此 与 折 半 查找 类似 , 其 关键 字 比 较 的 次数不 超 过 树 的 高 度 。

然而 ,用 折 半 查找 法 查找 长 度 为 羡 的 有序 表 ,其 判定 树 是 唯一的 ,而 含有 ?7 个元 素 的 二

叉 排 序 树却 不 唯一 。对 于 含有 同样一组元 素 的 表 , 由 于 元 素 插 和人的 先后 次 序 不同, 所 构成 的

二 又 排序 树 的 形态和 高 度 可 能 不 同 ,如 图 9. 10Ca)和图 9. 10(b) 所示 的 两 棵 二 又 排序 树 的 高

度 分别是 5

和 9。 因此 在 查找 失败 的情况 下 ,在 这 两 棵树上 所 进行的关键 字 比 较 次 数 最 多

分 别 为5 和 9; 在 查找 成功的情况 下 ,它们 的 平均 查找 长度也 不 相同 。

对 于 图 9. 10(a) 所 示 的 二 又 排序 树 ,在 等 概率 假设下 ,查找 成功的平均 查找 长 度如 下 :

ASL。 二 3 二4 3

类 似 地 ,图 9. 10(b) 所 示 的 二 又 排序 树 在 查找 成功时 的 平均 查找 长 度 为 :

ASILv

1X1 十1X2 十1X3十1X4十1X5十1X6十1X7 十1X8 十1X9

9

5

由 此 可 见 , 在 二 又 排序树上 进行 查找 时 的 平均 查找 长 度和 二 叉 排序 树 的 形态 有 关 。

在 最 坏情况 下 ,二 又 排序 树 是 通过 把 一 个 有序 表 的 个 元 素 依 次插入 而 生成 的,此 时 所得

ee

的 二 又 排序树旷 化 为一棵 高 度为”的 单 支树 , 它 的平均 查找 长度和 单 链 表 上 的 顺序 查找
相同 ,也 是(2 十1)/2。 在 最好情况下 ,二 又 排序 树在生成 的 过程中 树 的 形态 比较匀称 ,最
终 得 到 的 是 一 棵 形态 与 折 半 查找 的判定 树相似 的 二 又 排序 树 , 此时 它 的 平均 查找 长度大

约是 logsm。

就 平均时间 性 能 而 言(考虑 一 组 关键 字所有 排列 构成 的所有 二 又 排序 树 的 平均情况 ),

二又排序树上 的 查找和 折 半 查找 差不多 。但 就维护 表 的 有 序 性 而 言,二 又 排序 树 更 有 效 , 因

为 无须移动 元 素,只 需 修 改指针 即 可 完成结 点 的 插入和 删除 操作 , 且 其平均 的 执行时间 均 为

O(Clog27z)。

328

ES查找|

,按表中的关键
【 例 9.3〗 已知一 组 关键 字 为 (25,18,46,2,53,39,32,4,74,67,60,11)

字 顺 序 依次插入 到 一 棵 初始 为 空的二 叉 排序 树 中 , 画 出该二 又 排序 树 ,并 求 在 等 概率 的 情况

下 查找 成功和 查找 不 成功的平均 查找 长 度 。

生成的二又排序树如图 9. 11(a)所示 。

所以 有 :

ASL Ra

1X久1 十 2义2 十 3 义 3 十 3 义 4 十 2 义 5 十 1义6
2

3.5

加 上 外 部 结 点 的 二 叉 排序 树如 图 9. 11(b)所示 ,所以有:

ASLaaa

1X2 十3X3 十4X4 十3X5 十2X6

1415

13

(a)

一 棵 二 又 排序树

(b) 加 上 外 部结 点 的 二 又 排序 树

图 9.11 一 棵 二 又 排序 树 及加上 外 部 结 点 以 后

【例9.4】 设计 一 个 算法 ,对 于 给 定 的 二 又 排序 树 中 的 结 点 户,找出其 左 子树中 的 最 大

结点和 右 子树中 的 最小 结 点 。

根据 二 又 排序树 的 定义 可 知 , 一 棵 二 又 排序树中的 最 大 结点 为根结 点 的 最右下 结

对 应 的算法如下 :

void maxminnode(BSTNode * p)

{

ii(CpI=NULL)

这 (p 一 lchild!==NULL)

printf(" 左 子 树 的最大 结 点

为 :dvn",maxnode(p -> lchild)) ;

这 (p 一> rchild!

王 NULL)

printf(" 右 子 树 的 最 小 结 点 为 :%dN\n" ,minnodeCp 一> rchild) ) ;

{

}

Rssssa

}》
KeyType maxnode(BSTNode * p)
while (p 一 rchild!王NULL)

{

p王p 一> rchild;

Teturn(pP 一> data) ;

)}
KeyType minnode(BSTNode * p)

{

while (plchildl=NULL)

// 返 回 一 棵 二 又 排序树 中 的最大 结 点 关键 字

// 返 回一棵 二 叉 排 序树中 的 最 小 结 点 关键 字

329

数据 结构教程

[第5 【版

p一p 一 lchild;

Teturn(p 一> data) ;

)}

了又排序本 逢休

在 从 二 又 排序 树 中 删除 一 个 结 点时 不 能 直接 把 以 该 结 点 为 根 的子树 都

删去,只 能 删除 该 结 点 本 身,并 且 还 要 保证 删除后所 得的二 又 树 仍 然满足

BST 性质。也 就 是 说 ,在 二 又 排序树中 删 去一个结 点

相当 于 删 去 有 序序列

〈 即 该 树的中 序 序列)中 的 一 个 元 素 。

删除操作 必须 首先 进行 查找 ,假设 在 查找 结束时 训 指 向 要 删除 的结 点 。

以 下 几 种情况:

(1) 若 刀 结 点是叶子 结 点 ,直接 删去该 结 点 。如图 9. 12(a)所示 ,直接删除结点 9。 这

是 最 简单 的 删除结 点 的情况 。

(2) 若 妃 结 点只有 左 子 树 而 无 右 子 树。根据二 又 排序树的 特点 ,可以直接将其左孩子

替代结 点 总 (结 点 替换)。如图 9. 12(b)所示 ,尹 指向结 点 4, 要 删除 训结 点 ,只 需 将 其 左孩子

结点 3 蔡 代它。

(3) 若 尹 结 点只有 右 子 树 而 无 左 子 树。根据二 又 排序 树

的特点 ,可 以直接将其右孩子

替代结 点 训 (结 点 替换) 。如图 9. 12(c)所示, 尹指 向结点 7, 要 删除 记结 点 ,只 需 将 其 右 孩 子

结点 8 蔡 代它。

(4) 若 尹 结 点 同时 存在 左右 子 树。根 据 二 又 排序 树 的特点,可以从其 左子树 中 选择 关

键 字 最 大 的结 点 ~, 用 结 点 -的

值 蔡 代 结 点 户 的 值 (结 点 值蔡换) ,并 删除结点(由于 结点

一 定 是 没有 右 子 树 的 ,删除 它 属于情况(2)) ,其 原理 是用中序前驱 蔡 代 被 删 结 点 。

也 可 以 从 其 右 子树中 选择关键 字 最小 的结 点 ,用结 点 -的 值 蔡 代 结 点 这 的 值 (结 点 值

蔡换) ,而 且 将 它 删 除(由 于 结 点 一 定 是 没有 左 子 树 的 ,删除它属于情况(3)) ,其原理 是 用

中序后继 替 代 被 删结 点 。

通常 采用 前 一 种 删除 方式 ,如 图 9. 12(d)所示 ,指向结 点 5, 它 的 左 子树中 关键 字 最 大

的结 点 是 结点 4, 将 结点 尹 的关键字改为4, 并删除结点 4。

那么如 何 实现 二 又 排序 树 删除结 点 的 算法 呢? 下 面以删除只有 右 子 树 的结 点 为例

进行 说明。 首先要 查找 关键 字为& 的 被 删 结 点之,其 算法 如 下 :

ET

bool deletek(BSTNode * &bt,KeyType k)

{

让 (btI=NULL)
{

证 (k==bt-> key)
deletep(btb)
{
return true;

】》

else 计 (k<bt 一> key)

// 查 找到 了 被删 结 点 bt
//调用 deletep 删除结点 bt
// 成 功 删除,返回真

deletek(bt 一> lchild,k);

// 在 左 子树中 查找

else

deletek(bt 一 > rchild,k);

// 在 右 子树中 查找

}
else return false;

//未查找到 ,返回假

医J

ES查找|

仆人

肌 除结上9 (站

《0

Ca

GO 加
Gj

(a)

删除 叶子结 点

NG

出 除 结 & (DG)

四

C9)

人 被胡 结点右子 树为空

《9)

ca ,

中 和

(G) 被 删结点 左 子 树 为空

删除结 点 5 人 G)

(7)

(5

9)

(d) 被 删结点 左

、 右 子 树 均 不 为 空

图 9.12 二 又 排序 树的结点 删除

aa

删除 结 点 2 这 里 的 结点 如 仅仅有右 子树) 的 算法如下 :

void deletep(BSTNode * &p)

{

BSTNode *q;
q 一 pi;
p 一 p 一> rchild;

// 让 q 指 向 结 点 p
// 让 p 指 向 它 的 右 孩子

331

数据 结构教程

[第! 5版

free(q) ;

//释放结点 q 的空间

}

对 于 图 9. 9 所 示 的 最 终 的 二 又 排序 树 bt, 调 用 deletek(bt,1)

函数删除关键字为 1 的结

点 的 过 程如 图 9. 13 所 示 。 从 中 可以 看出,由于 deletep 函数中的形 参 户 是 引用型参数,当执

行 deletep 函数让 户 指 向 其 右 孩 子后,通过 函数返回将 训 回 传 给实参 达到 删除 原来 2 所指

结 点

的 目的 。其 中 引用型参数 起 到关键作用,使得删除结点 户 不 必 查 找 其 双亲 结 点。后

面 的 删除算法都 是 利用 这 种 方法实现 的 。

全 下

deletek(bt,1)

上

上
|

LI------------

<bt>keyG) 1 jehid-bhp 一 1

deletek(bti,1)

-ptrbezlenild | bb-oaitbtb指

bu->key0) 二 向结 点 2)

上

上

上

上

最终的结果, 删除了结点1

deletep(D)

| 六bb( 让 指向结点 1

让 bu 指向结点 1
让 bt指向 结

Tb1 让p指 上

1 让 PP指向

bt

1 删除并释
1 放结 点 1

上

上

上

图 9.13 在 二 又 排序树 bt 中 删除关键 字 为 1 的 结点

删除二叉排序树 bt 中关键字为& 的 结 点 的 算法 DeleteBST(bt,A)如下:

bool DeleteBST(CBSTNode * &&bt,KeyType k)

//在 bt 中 删除 关键 字 为k 的 结 点

{ (bt==王NULL)

Teturn false;

else

{

迁 (k<bt 一 key)

// 空 树 删除失败 ,返回假

return DeleteBST(bt -> lchild,k) ;

// 递 归 在 左 子树中 删除为k 的 结点

else 计 (k> bt 一> key)

return DeleteBSTCbt -> rchild,k) ;

// 递 归 在 右 子树中 删除为上 的 结点

else

{

}

DeleteCbb;

Teturn true;

// 找到 了 要 删除的结 点 bt

// 调 用 Delete(bt)

函数删除结点 bt

// 删 除 成功,返回真

ee

}

}

注意: 上 述 算法 是 在根 结 点指针 为 bt 的 二 又排序树中 删除 一 个 结 点,bt 的值可 能 发 生

变化,所以一定要用引用 类 型,即将 bt 的 值改变 后 的结果 回 传给实 参 ,否则 可 能 会出现

错误。

332

ES查找|

void Delete(BSTNode * &p)

// 从 二 叉 排 序树中 删除 结点P

{

BSTNode *q;

这 (p 一 rchild 一王NULL)

// 结点 p 没有右 子 树 ( 含为叶子 结 点 ) 的 情况

人 q一pi;

p一p 一 lchild;

free(q) ;

}

// 用 结 点 p 的 左 孩子蔡 代 它

else 让 (p 一 lchild王=NULL)

// 结点 p 没有左 子 树 的 情况

人 q一pi;

p王p 一> rchild;

free(q) ;

}

// 用 结 点 p 的 右 孩子蔡 代 它

else Deletel(p,p -> lchild) ;

// 结点 p 既有左 子 树又有 右 子 树 的 情况

)》
void Deletel(BSTNode * p,BSTNode * &r)

{

BSTNode * qi;

这 Cr-

一 > rchild!王NULL)

Deletel(p,r 一> rchild) ;

else

{ p一key一r一> key;

p 一> data一T一> data;

q一Ti;

TI一 [一 lchild;

free(q) ;

//被删结点 p 有 左 ` 右 子 树,r 指 向其左 孩子

// 递 归 找 结 点 z 的 最 右 下 结点

// 找到 了 最右下 结 点 r( 它 没有右 子树)
// 将 结点r 的 值存放到结点p 中 ( 结 点 值蔡代 )

//删除结点
//即用结点 r 的 左 孩子蔡代它
//释放结点q 的 空间

932 平衡二叉树

在 含有 ?7 个 结 点 的 二 又 排序树中 查找 操作 的执行时间与 树 形 有 关 , 在

最 坏情况下 执行时间为O0z) 。 为了避免这

种情况 发 4E ,人 们 研究了许多 种

动态 平衡的 方法,使 得 往树中 插 和人或 删除结 ,

视频 讲解

树的“

FF衔”, 使之既 保持 BST 性 质不变 又 保证 树 的 高 度 在任何情况 下 均为OClog:z) ,从而

确保树上 的 查找 操作 在 最 坏情况 下 的时 间 也 是DClog:z) 。

平衡的二 又 排序 树 有很 多 种 ,较为 著名 的有 AVL 树 ,它是由两 位 前 苏联 数学 家 Adel'

sonVel'sii 和 Landis 村

F 1962 年 给 出 的 , 故 用 他 们 的 名 字 命名。下 面讨论 的 平衡二又 树都 指

AVL 树。

若 一 棵 二 又 树 中 每 个结 点 的左右子树

的 高 度 最多相差 1, 则 称 此 二 又 树 为 平衡二又 树

(balanced binary tree)。在 算法 中,通过平衡因子(balance factor,bf)

来具体实现 上 述 了

衡

二 又 树 的 定义。一 个 结 点 的 了

衡 因 子 是 该结 点 左 子 树 的 高 度减去 右 子 树 的高度 (或 者 该结

点 右 子 树 的 高 度 减 去 左子树 的 高 度 ) 。从平

衡因子的角度 说 , 若 一棵 二 又 树 中 某 个 结 点 的平

衡 因子 的绝对 值小 于 或 等于 1, 即 其

F 衔因子的取值为1.0 或一1, 该结 点 是 平衡 的,否则 是

不 平衡 的。若 一棵 二 又树的所有 结 点 都 是 了

衡的 , 称 之 为平衡二 又 树 。

一 般情况下 ,一 棵 平衡二又 树 总是二 又

排序树 ,因为 脱离二又 排序 树 来讨论 平衡二 又 树

是 没有意义 的 。所 以 平衡二 叉 树 是在二 又 排序 树 的 基础上 增加 了 树 形约束 ,即每个结点

平衡的。

333

数据 结构 教程

虹 第 5 【版

图 9. 14 是 平衡二叉树和 不平衡二 又 树 的 例子,图 中 结 点 汶标注的 数字 为 该 结 点 的平衡

因子 。其中,图 9. 14(a) 是 一 棵 平衡二 又 树 , 图中所 有 结 点 的 平衡因子 的绝对 值 都 小于 1,

图 9. 14(b) 是 一 棵非平衡二 又 树,图 中 结 点 3.4、5 的平衡因子 的 值 分 别 为 一2、 一3 和 一 2 , 它

们 是 不 平衡的。

(a) 一 棵 平衡 二 又 树

(b) 一 棵非 平衡 二 又 树

图 9.14 一 棵 平衡二 又树和 一 棵非 平 衡二又 树

那么如 何 使 构造的二 又 排序树 是一棵 平衔二 又 树呢? 关键 是每次 向 二 又 排序树中插入

新 结 点 时 要 保持所有 结 点满足 平衡二 又 树 的 要 求 。这 就 要 求 一旦某 些 结 点 的 平衡因子 在 插
入 新 结 点 后 不 满足要 求就要 进行 调整。

扫-归

二 网 本 证 天 结 二 的 于 程

若 向 平衡二 又 树 中 插入 一 个 新 结 点 (总是作为 叶子 结 点插入 的)后 破坏

了 平衡性,首先从该 新 插入 结 点向根 结 点 方向 查找 第一个 失去 平衡的结 点 ,
然后以 该失衡 结点和 它 相 邻的刚 查找 过 的 两个结 点 构成 调整子树 , 使 之成 各和本

为 新 的 平衡 子 树。当 失衡 的 最 小子树 被调整 为 平衡 子 树 后 ,整个树 就又成 为一棵 平衡二

又树

失衡 的 最小 子 树 是指以 离插入 结 点 最 近 , 且 平衡因子 绝对 值大于 1 的结 点作为 根的子 树 。

假设用 A 表示 失衡 的 最小子树 的 根 结 点 , 则 调整 该 子树的 操作 可 归纳 为 下列 4 种 情况 :

1) LL 型调整

这 是 因 在 A 结点的 左 孩子( 设 为已结 点 ) 的 左 子树上 插入 结 点 ,使得 A 结点的 平衡因子

由 1 变为2 而引起的不平衡。

LL 型 调整的一 般 情 况 如 图 9. 15 所 示 。 在图中 ,用 长 方框表示 子 树 ,用 长 方框的 高 度

(并 在 长 方 框 劳标有 高 度 值六或 六十1) 表 示 子 树 的 高度, 用 带 阴 影 的 小 方框表示 被插入 的 结

点。调 整 的方法是将 也 结 点 向 上 升 蔡 代 A 结 点 成为根结 点,A结点作为 也 结点的 右孩子 ,

而 了 的 原 右 子树 8 作为 A 结 点 的 左 子 树 。因 调整 前 后对应 的 中 序 序列相同,所以调整后仍

保持了 二 又 排序 树 的 性 质 不变,但 变 为 平衡二 又树了 。

2) RR 型 调整

这 是 因 在 A 结点的 右 孩子( 设 为也结 点 ) 的 右 子树上 插入 结 点 ,使得 A 结点的 平衡因子

由一1 变 为 一2 而引起的不平衡。

RR 型调整 的一般 情 况 如 图 9. 16 所 示 。 调 整 的 方法是将也 结 点向上 升 蔡 代 A 结 点 成

为 根 结点,A结点作为 也 结 点 的 左 孩子,而了B的原左子树 8 作为 A 结 点 的 右 子 树。实际上,

RR 型 调整和 LL 型调整是对称的。

334

|

插入 后

调整后

图 9.15 LL 型调整的过程

中 。

0

全 书

| B

| 7

年 入 前

插入 后

调整后

图 9.16 RR 型 调整的过程

3) LR 型 调整

这 是 因 在 A 结 点 的 左 孩子( 设为也 结 点 ) 的 右 子树上 插入 结 点 ,使得 A 结 点 的 平衡因子

由 工 变为2 而引起的不平衡。

LR 型 调整的一般 情 况如图 9. 17 所示 。调 整 的方法是将 C 结点上 升 作 为根结 点,B 结

点 作为 C 结 点 的 左 孩子,A 结点作为 C 结 点 的 右 孩子,C 结 点 的 原 左 子树 8 作为 也 结 点 的

右 子 树 ,C 结 点 的 原 右 子树 y 作为 A 结 点 的 左子树 。

插入后

图 9.17 LR 型调整的过程

数据 结构教程

[第! 5版

4) RL 型调整

这 是 因 在 A 结 点 的 右 孩子(设 为也结 点 ) 的 左 子树上 插入 结 点 ,使得 A 结 点 的 平衡 因子

由一1 变 为 一2 而引起的不平衡。

RL 型调整 的 一 般 情 况 如 图 9. 18 所 示 。 调 整 的方法是将 C 结点上 升 作为 根 结 点 ,A 结

点 作为 C 结 点 的 左 孩子,B结点作为 C 结 点 的 右 孩 子,C 结 点 的原左 子树 B 作为A 结 点 的

右 子树,C 结 点 的 原右子 树 y 作为 B 结 点 的 左 子 树。同样,RL 型 调整和 LR 型 调整是对

称的。

7+11|

Oo

0

B

HP+1

加

己>

| 1

B | | YI 区

插入 前

笑 入 后

调整后

图 9.18 RL 型调整的过程

,给出构造一棵平衡二又树的
【例 9.5】 输入关键 字 序列 (16,3,7,11,9,26,18,14,15)

过程。

建立 平衡 二 又 树的过 程如 图 9. 19 所示 ,图 9. 19Cn)是最终结果。

(a) 插入16

(Cb) 插入3

(co) 插入7

(d) LR 调 整

(插入9

(g) LL 调 整

(h) 插入26

(iD RR 调整

图 9. 19 建立 平衡二又 树的过 程

336

图 9. 19 建立 平衡二又 树的过 程

2 有 二 文本 下 央 了 作 络 吉 的 过程

在 平衡二 又树中 删除一个 结 点 与 二 又 排序树 中 删除 结 点 类 似,只 是 增加 了 调整这一 步

了又。 其 过 程如 下 :

扫-扫

(1) 查找。先 在平衡二又 树 中 查找 到 关键 字 为&的 结 点 户 。 |

(2) 删除 。 删除 户 结 点 分 以下几 种 情况 。

@ 叶子结点: 直接 删除该结点 。

和

O@ 单 分 支 结 点: 用 刀 结 点 的 左 或 右 孩 子 结 点 蔡代 结 点 ( 结 点 蔡 换 ) 。 视关讲角

@ 双 分 支 结 点 : 用 了 结 点的中 序 前 驱 ( 或 中 序 后继) 结 点 dg 的 值 蔡 换 户 结点的值。再

删除结 点 9。

(3) 调 整 。若 被删除的是 结 点 g%, 则 从 结 点 4

向 根 结 点 方向 查找 第 一个失去 平衡的 结 点 :

O

若所有 结 点 都 是平衡的, 则 不 需要 调整 。

@

假设 找到 某 个 结 点 的 平衡因子 为 一2: 其 右 孩子 的平衡因子 是一1, 则 作 RR 型 调整; 其 右

孩子的了

F 衡因子是 1 , 则 作 RL 型 调整;, 其 右 孩子的 平衡因子是0,则作 RR或RL 型调整均可。

aa

@

假设 找到 某 个 结 点 的 平衡因子为2:

其 左 孩子的 平衡因子 是 一1, 则 作 LR 型 调整; 其右

孩子的了衡因子是 1 , 则 作 LL 型 调整;

其 右 孩子的 平衡因子是0,则作 LR或LL 型 调整均可。

【例9.6】 对例 9. 5 生成的AVL 树 给 出 依次删除 结点11.9 和 15 的步骤 。

删除结点的过程如图 9. 20 所 示 。 图 9. 20(a)为初始AVL 树 ,删除结点 11 (为根结

点 ) 时 先 从 其 左 子树中 找到 最 大 结 点 9, 用 其 值 蔡 代 被 删 结 点 的 值 ,删除 原 结点9。 修改原结

点 9 的 双亲结点 7 的平衡因子为 1, 再向上 找到 根 结点,都 是平衡 的 。 删 除后的结果如

337

数据 结构教程

[第1 5 【版

图 9. 20(b)所示 。

图 9.20 删除 AVL 中 结 点 的 过 程

(e) 删除结点15

删除结 点 9( 为 根 结 点 )时 先从其 左 子树中 找到 最 大 结点 7, 用 其 值 蔡代 被删结 点 的值,

删除 结 点 7。 修改原结点 7 的 双亲 结 点 的 平衡因子 为 一2 ,不平衡,找到 其 右 孩子 结 点 18 , 它

的 平衡因子为1, 进行RL 调整 。 删 除后的结果 如 图 9. 20(d)所示 。

删除 结 点 15 (为 根 结 点 ) 时 先从其 左 子树中 找到 最 大 结 点 14, 用 其 值 蔡代 被删 结 点 的

值 , 删 除 结 点 14。 修改原结点 14 的双亲结点 7 的平衡因子 为1, 再向上 找到 根 结 点 ,都 是 平

衡的 。 删 除后的结果 如 图 9. 20(e)所示。

和到本的查找
平衡二 又 树 查 找 过 程和二 又 排序树 查找 过 程完全 相同 ,因此 ,在 平衡二

扫--扫

又树上 查找 的 关键 字 比 较 次 数 不 会超过 其 高 度 。

在 最 坏 情况 下 ,普通 二 又 排序 树 的 查找 性能为OC0z) 。 那么,平衡二又树 证

的 情况又是 怎样 的呢? 下 面 分 析 平衔二 又 树 的 高度 /和 结 点 个数” 之间 的

视频讲解

首先 构造 一 系列 的 平衡二 又树Th ,Ts ,Ts ,其中思 (=1,2,3,...)是高度 为彤且结

点 数 尽 可 能 少 的 平衡二 又 树 ,如 图 9. 21 中 所示的人 .T Ts 和 7T:。 为了构造 厂 , 先分别构

eee

刀

刀

思

好

办

图 9.21 高 度 为疡结点个数”最 少 的平衡二叉树

338

ES查找|

造 厂 -和 五 -使 五以人 友 - 和 五- 作为 其 根结 点 的

左右 子 树 。对 于 每 一个 厂 , 只 要 从

中 删 去一个结 点 ,就 会失去 平衡 或 高 度 不 再是 (显然,这 样构造 的 平衡二叉 树 在结 点 个 数

相同 的 平衡二 又 树 中 具有 最 大 高度) 。

然后通过 计算 上 述 平衡二又树中的结 点 个 数 来 建立 高度与结 点 个 数 之间 的 关系。设

NGC) (高度刀 是正整数)为 厂 的结 点 数,从 图 9. 21 中 可 以 看 出 有 下 列 关 系 成立 ,

NGD)

=1,NC2) 一2,NCOD) 王NOA 一1 十 NG 一2) 十 1

当 />1 时 ,此 关系 类似于 定义 Fibonacci数的关系:

下 (1) 一1,FC2) 王 1,FOD) 一下 (一

1) 十 下 (一2)

通过 检查 两 个 序列 的 前 几 项 就可 以 发 现 两 者 之间 的对 应 关系 :

由 于 Fibonacci 数 满足渐近公式:

NGCn) 一下 (十2)一1

Fn) 一 二 办, 其中p一

史

1
及?

1 十
2

人
故 由 此 可得 近似 公

、

似公式 :

NO 三 一 同 一 1一22 一 1

1
启Y

即 :

/logs(CNCD)十1)

所以,含有 个结 点

,对应查找算法的时间
的平衡二叉 树 的 平均 查找 长 度 为O(logz)

复杂 度为O(log:z)。实际上 , 折 半 查找 对 应 的判断树 就 是 一 棵平衡 的二又 排序树(平衡二

又 树) ,所 以 折 半 查找 算法 的时 间 复 杂 度 也 为Odlogsm)。

933 B 树

日

回上

二 又排序树和 平衡二 又 树都是用 作 内 查找 的 数据结构 , 即 被 查找 的 数

据 集不大 ,可 以 放 在 内 存 中。本 小节 和 后 面小节 介绍的 B_ 树和 B十树是用 “一 和
作 外 查找 的 数据结构 ,其 中 的 数据存放 在 外 存 中 。

B_树(B tree) 中 所 有 结 点 的 孩子结 点 的 最大值 称为B_ 树 的 阶 , 通常用 羡 表示 ,从 查找

效率 考虑 ,要求wm>>3。 一棵必 阶 B_ 树 或 者 是一棵 空树 ,或者是 满足 下 列 要 求的六 又树:

(1) 树 中 每 个结 点 最多有 六 棵 子 树 ( 即最多 含有 六 一1 个关键字,设Max一mm 一1D);

(2) 若 根结 点 不是叶子结 点 , 则 根结 点 最 少 有 两 棵 子 树

(3) 除根结 点以 外 ,所 有 非叶 子结 点 最 少 有 [zx/2] 棵 子 树 ( 即 最 少 含有 [mm/21]一1个关

键字,设Min= |/21]一1);

玫

妨

已

轧

az

力

人

刀

其中,为

该结点中 的 关键 字 个 数 ,除根结 点 以外 ,其他所有 结 点 的 关键 字 个 数 半 满足

[zy/21一 1 和甩2 入mm 一 1; 已(1 过 ;i委 7 为 该结 点 的 关键 字 且 满足访二Al; (00 入 ij委 7) 为 该结

点 的 孩子结 点指针 ,满足 六 (0 和 ;i委 2 一1) 所 指 子树上 结 点 的关键字均大于 已 且 小于Arals

包 所指 子树上 结 点 的 关键 字 均 大 于 A。

(5)

所 有 的 外 部结 点 在 同一层, 并 且 不 带信息。

在 B- 树 中 外 部结 点 (可 以 看 作 是 查找 失败 的结 点 ,实际上 这 些结 点 不 存在 ,指向 这 些 结

339

数据 结构教程

[第5 【版

点 的 指针 为 空 )不带信息 ,为了 方便 ,在 后 面的B- 树图中 都 没有画 出 外 部结 点 层 。通 常在计

算一棵 B-树 的 高 度 时 外部结 点 层 也 要 计 和人一 层 。显 然 ,如 果 一 棵 B- 树 中 总共有 ) 个 关键

字,则 外部结点 的个数 为2十 1。

例如 ,图 9. 22 是一棵 3

阶 B- 树 ,2 一 3。

它满足 ,

(1) 每 个结 点 的 孩子个数小 于 等于 3;

(2) 除根结点以外 ,其他 结 点 最 少有[mV/2|一2 个孩子 ;

(3) 根 结点 有 两 个 孩子结点,

(4) 除根结 点以外 的所有结点的 关键 字 个

数 大 于 等于| mw/2|一1三 1,小 于 等 于

7 一 1 一 2;

(5)

所 有 外 部 结 点 都 在 同一 层上 , 树 中 总共有 17 个 关键 字 ,外 部 结点有 18 个。

也

了

7

36

“

“旧

S

13 18

”Ar
和

A\

、

、、

112

4

11 12 || 14

二请

1920, 叶子结点屋 、、

图 9.22 一 棵 3 阶 B- 树

在 B- 树 的存储结构中 ,结点 的 类 型 声明如 下 :

井 define MAXM 10

typedef int KeyType;

typedef struct node

{

int keynumy;

// 定义B- 树 的最大 阶 数

//KeyType 为关键字类型

// 结 点 当前拥有 的 关键 字 的 个 数

KeyType keyLMAXMJ ;

//key[1..keynum]

存放关键字 ,key[0]不用

Struct node #* parent;

// 双 亲 结 点 指针

struct node x* ptrLMAXMDJ ;

//和孩子 结 点 指针 数组 ptr[0..keynum]

) BTNode;

int mi;

变量

int Max;

int Min;

//B-树结点类型

//m 阶 B- 树,这 里的m\Max 和 Min 几 个 变量 均 定 义 为 全 局

//m 阶 B- 树 中 每个结 点 的 最 多 关键 字 个 数, Max一m 一 1

//m 阶 B- 树 中 每 个 结 点 的 最少关键字个 数,Min一|m/2|一1

在 B- 树 中 查找 给 定 关键 字 的 方法类似 于 二 又 排序树上 的 查找 ,不 同 的

是 在 每 个 结点上 确定 向 下 查找 的 路 径 不 一定是 二 路 的 ,而是2 十1 路的。

为结 点 内 的 关键 字 序列 key[1.. 中 是有序 的 , 故既可以 用 顺序 查找 也 可以用

折 半 查找。在 一棵 B- 树 上 查找 关键 字 为 & 的 方法为: 将 & 与根结 点 中 的

340

ES查找|

key[ 让 (1 所 ;i委 思 进行比较:

(1)

若 <key[1],则沿着指针 ptr[0] 所 指 的子树继续 查找 ,

(2) 若 & 一 key[让 , 则 查找成功 ;

(3) 若 key[ 相<A<key[Li

十1,则沿着指针 ptr[ 详 所 指 的 子树继续 查找 ;

(4) 若 &>key[

门,则沿着指针 ptr[z] 所 指的子 树 继续 查找 。

重复上述 过 程,直 到 找到 含有关键 字 & 的某个 结 点; 如 果 一 直 比 较到了 某 个 外 部 结 点 ,

表示 查找 失败 。

在 B- 树 中 进行查找时 ,其查找时间 主 要 花费 在 搜索结 点上, 即 主要 取决于B- 树 的 高

度 。 那 么 总 共 含有守 个关键字的2 阶 B- 树 可 能 达到 的 最 大 高 度 为多少呢? 或者说 ,高度

为 由 十 1(第大十1 层 为 外 部结 点层)的 B- 树 中 最 少 含有多 少 个结 点 ?

第 1 层 最 少结 点 数为 1 个;

第 2 层最少结 点 数 为两个 ;

第 3 层 最 少结 点 数为 2|/2|个;

第 4 层 最 少结 点 数 为2|mV/2|?个;

第 由 十 1 层 最少结 点 数为 2[zz/2|一个。

假设疡阶 B- 树 的 高 度 为凡十1,由 于 第 央 十 1 层 为 外 部结 点 ,而当前树中含有 ”个 关键

字 , 则 外 部结 点为zw十1个 ,由此可推 得 下 列结果 :

7 十 1 全 2122/21]

和, 即 天 一1过 lo时wo 十 1)/2)

所以ASlogrwzqCz

十1)/2十1,因此 在含” 个关键字的 B- 树 上 进行查找 需 访 问 的 结 点 个 数

不 超过 logrwiq(C2z

十1)/2十1个,即 B- 树 查找 算法的时间 复 杂 度为O(logwz) 。

将 关键字& 插入到 B- 树的过 程 分 两步完成 :

(1) 利用前述的 B- 树 的 查找 算法 找 出 关键字& 的插入 结 点 (注意,

B- 树 的 插入 结 点 一 定 是某个 叶子结 点 ) 。

(2) 在插入 结 点 中 插入 关键 字 人 ,判断插入结 点 是 否还有 空位 置 ,即判 各得

断 该结 点 的 关键 字 个 数是否小于 Max 一 六 一 1, 分 两种情况 :

g@ 若插入结 点 的 关键 字 个 数< Max, 说 明 该结 点还有 空位 置,直接 把 关键字A 插入 到 该

结 点 的 合适 位 置上( 即 满足插入 后 结点上 的 关键 字 仍 保持有 序 ) 。

@ 若 插入 结 点 的 关键 字 个数=Max, 说 明 该结 点 已 没有空位 置,需要 把结 点 分 裂 成两

个。分 裂的做 法 是 创建一个 新结 点 ,把 原结点上 的 关键字和 A& 按 升 序排序 后从中 间 位 置 ( 即

[zz/21之 处)把 关键 字 ( 不 包括 中间 位 置的关键 字 ) 分 成两部 分 , 左 部 分 所 含 关键 字 放 在旧 结

点中 , 右 部 分 所 含 关键 字 放 在 新 结 点中,中间 位 置的关键 字 连 同 新 结 点 的 存储 位 置 插入到 双

亲 结 点 中。如 果 双 亲 结点 的 关键 字 个 数 也 超过 Max, 则 要 再 分 裂,再往上 插 , 直 到 这 个 过 程

传递到根结点为止。如 果 根 结 点 需要 分 裂,树 的 高 度 增 加 一 层 。

一棵B- 树 的 创建 过 程 就是从 一 棵 空 树开始 ,逐个 插入关键 字 而得 到 的 。

【 例 9.7】〗 关键 字 序 列 为 (1,2,6,7,11,4,8,13,10,5,17,9,16,20,3,12,14,18,19,

15) ,创建一哥5 阶 B-树。

341

aa

数据 结构 教程

\ 上 OOQ

创建 一棵5 阶 B- 树的过 程如 图 9. 23 所示 。

1267

Ga
到 AN

2
到 NAN

6 10
1 汪]

1

2

7

11

124

78113|

|124||78|0 13

(a) 插入1,2. 6, 7

(b) 插入11

(c) 插入4. 8, 13

(d) 插入10

610

AAA |

愉

61016

| 愉

1245 | |789||111131617

1245

||789|1113||1720

(e) 插入5 17, 9, 16

(GD) 搬入20

3.6 .10 16

ep

AAA NAN

12 人 11121314 |17181920

ll0。

36
人

愉

13 16

1

12

45|1|1789|1112|111415 1117 18 19 20

(g) 插入3, 12, 14. 18, 19

(Ch插入15

图 9.23 创建一棵 5 阶 B-树的过程

由于和交 王 5, 所以

Max 一 思 一1二 4。 以 在 图 9. 23(e)中搬入 关键 字 20 为 例 说 明 搬 入 过

程 。在图 9. 23(e)中搬和人关键字 20 时 ,查找 其插入 结 点 是 最 右边的叶子 结 点 ,将其有 序 搬

入 ,该 结 点 变 成 (11,13,16,17,20), 这 时 结 点 的 关键 字 个 数 超界, 需 进行 分 裂 ,即 由 该 结 点 变

成 两个结 点 ,分别 包含 关键 字 11,13 和 17,20,

并将中间关键字 16 移 至 双亲 结 点中,双亲结

点 变 为 (6,10,16)。

结点,将其有序
再 看 在 图 9. 23(g)中插入关键字 15 ,查找 其 插入结 点 是 (11,12,13,14)

插入 ,该 结 点 变 成 (11,12,13,14,15), 这 时 该 结 点 的 关键 字 个 数 超界, 需 进行 分 裂,对 应 两 个

结 点 (11,12) 和 (14,15) ,并 将 中间 关 键 字 13 移至双亲 结 点 中 ,双亲 结 点 变 为 (3,6,10,13,16)。

这 时 该 结 点 的 关键 字 个 数 超 界,需 进行 分 裂,对 应 两 个 结 点 (3,6)和 (13,16) ,并 将 中 间 关 键

字 10 移 至双亲结点中,由

于 分裂前 的 结 点 就 是根结点,所 以 新 建 一 个根结 点 , 树 的 高 度增加

一层。最 终 创建的5

阶 B- 树如图 9.23Ch)所示 。

扫-扫

3

桂 的 删陈

B_树 的 删除过 程 与插入 过 程 类 似 ,只是稍微 复杂 一 些。在 B_树 上 删

除 关键字A 的 过 程 分 两步完 成 :

(1) 利用 前 述的 B_树 的 查找 算法 找 出 该 关键 字 所 在 的 结 点,称 为 删除 更 查

(2) 删除 结点分 两 种情况 : 一种是属于 叶子 结 点 层的结 点; 另 一 种 是属于非 叶子 结 点

342

ES查找|

(3) 当 删 除结 点 是非 叶 子结 点 层 的结 点时 ,假设 要 删除某个 非叶子结 点 的 关键 字 A一

key[ 计 ,其删除过程 是 用 该结 点 ptr[Li 一 匡 所 指 子 树 中 的最大 关键 字 key[max]来蔡代被删

一定是在某个叶子结点
关键字 key[计(注意 ptr[i 一 1 所 指 子树中 的最大 关键字 key[Lmax]

上) ,然后再删除 key[max]j。 这 样 也 就 把 在非 叶子结点上 删除关键字& 的问题转化成了 在

叶子结点上 删除关键 字 keyLmaxj]的问题。

例如 ,图 9.24(a)是一棵5 阶 B- 树,Min王2。现在要 删除关键字 13 ,找到它所在的结

点(13,16) 是 一 个非 叶 子结 点 ,在 其 左边 的子树 中找到 该 子树的 最大关键 字为12,它在(10,

11,12)

的叶子结点中,用 12 替代 13,然后再删除关键字 12, 如 图 9. 24(b)所示 。

9

?|

3.6

pa

| 36

pa2l6

删除 关键 字 13

1211451|

78 | 1on12101516||

1920

1211451[

78 ou加 1s16l 20

(a) 一 棵 3 阶B-树

(b) 转换 为 删除 关键 字 12

图 9.24 将非 叶 子 结 点 层 的删除 转换 为叶子 结 点层的删除

也 可以 用 删除结 点 ptr[ 计 所 指 子树中 的 最小 关键 字 key[min]

来蔡代被删关键字 key[

(同样,ptr[ 详 所 指 子树中 的 最 小 关键 字 key[min]

一定是在某个叶子结 点 上 ) ,然后再删除

keyLmin]。

(4) 在 某个叶子结 点 中 删除 关键字 &, 共 有以下 3 种情况 ,

@ 若删除结 点 的 关键 字 个 数定Min(| /2|一1) ,说 明 删去该 关键 字 后 该 结 点 仍满足

B- 树 的 定义,则可 直接 删 去该关键 字 。

@ 假如 删除结 点 的 关键 字 个数=Min, 先 删除这 个 关键 字 &, 该结 点 不 再 满足B- 树的

要 求,此 时 若 该结 点 的 左 ( 或 右)兄 弟结 点 中 关键 字 个 数 大于 Min, 则 把 该结 点 的 左 ( 或 右 ) 兄

弟结 点 中 最 大 (或 最小 ) 的 关键字上 移 到 双亲 结 点 中 ,同时 把 双亲结 点中大 于 (或 小 于)上移

关键 字 的那个关键 字 下 移 到 要 删除关键 字 的结 点 中 。

例如 ,图 9.25(a)是一棵 5

阶 B_ 树,Min王2。现在要 删除关键字 15 ,找到它所在的结

点(14,15) 是 一个叶子结 点 , 先删除关键 字 15 ,再向 右 兄 弟 借 一 个 关键 字 , 其 过 程 是 把 右 兄

弟 (18,19,20)

中的最小关键字 18 上 移 到 双亲 结 点 中 ,同时 把 双亲 结 点 中 的 关键字 17 下移

到该结点中,如图 9. 25(b)所示 。

13 1则

319

[/ 人

1 和 一一一

删除 关键 字 15

ws

10 12

14 15

18 19 20

10 12

14 17

19 20

Ca) 一棵 3阶B-树

(b) 删除后的结果

图 9.25 删除 关键 字 15 的 过 程 (右兄弟 可 借 )

@) 假如 删除结 点 的 关键 字 个 数 =Min, 先 删除这 个 关键字 &, 该结 点 不 再 满足B- 树的

要求,并 且 该结 点 的左和 右 兄弟结 点 (如 果 存 在 ) 中 的 关键 字 个 数 均为 Min, 这 时 需要结 点 合

343

数据 结构教程

[第! 5版

并 ,把 要 删除 关键 字 的结 点 与其左 (或 右 ) 兄 弟结 点 以及双亲 结 点 中 分 割二者 的 关键 字 合并

成一个结点。如 果 因 此 使 双亲 结点中 的 关键 字 个 数< Min, 则 对 此 双亲 结 点 做 同样 处理, 以

至 于 可 能 直到 对 根结 点 做 这 样 的处理 而 使 整个树 减 少 一层。

例如 ,图 9. 26(a)是一棵 5

阶 B- 树,Min王2。现 在 要 删除关键字 15 ,找到它所在的结

点(14,15) 是 一个叶子结点, 先 删除关键字 15 , 左 、 右 兄弟都 不能借 , 需 要 合并 ,其 过 程是把

右 兄 弟(18,19)、 双 亲 结 点 中 分 割的关键 字 17 和 该 结 点 合并 为一个结 点,如 图 9. 26(b)

所示。

赐 《17 \、

LA
1/
/
| 1415

1012

、、

删除 关键 字 15

~- ”一

1
1819 | 7/

13

10 12

14171819

Ca) 一 棵 3 阶 B-树

(Cb)删除后的结果

图 9.26 删除关键 字 15 的 过 程(左右兄弟不能借?

【例9.8〗 对 于 例 9.7 生成的B- 树 ,给出删除 8.16.15 和 4 共 4 个关键字的过程。

图 9. 27 说明了 删除 的 过 程,这 里 Min=2。 以 在 图 9. 27(c)中删除关键字 4 的 过 程

进行说明。

册 吗

10

36

13416

站

3 必
131

12||145|1|7891112|11415 17181920

12|451791

人 302141518 1920

(a) 初始5阶 B_ 树

(b) 删除8, 16 后的结果

36

|

13 18
上

12

||45

|79

01211417|111920

1235 || 7911012|111417

111920

(e) 删除15 后的结果

(d) 删除4后的结果

图 9.27 一棵5 阶 B- 树删除 8`16.15 和 4 关键 字 的 过 程

在图 9. 27(c)中删除关键字 4 时 ,找到 它 所 在 的结 点 (4,5) 是 一个叶子 结 点,从 中 删

除 关 键 字 4 ,而 左 . 右兄弟都只有 两个关键 字 , 不 能 借 , 将 左 兄 弟(1,2)、 双 亲 结 点 中 分 制 的

关键字 3

和 该 结 点 合并 为一个 结 点 (1,2,3,5) ,这 样 双 亲 结 点 变 为 (6) ,不 满足 5

阶B-树

而 双亲 结 点(6) 又 没有 兄弟 可以借 , 继 续 合 并 ,将 右 兄 弟(13,18)、 双 亲 结 点 中 分 制的关

键字 10 和 该 结 点 合并 为 一 个 结 点 (6,10,13,18)

,这样导致 B_ 树 的 高 度 减 少了一 层 。

3

ES查找|

934 B+ 树

是一种应用广泛
在 索引 文件组织中 经 常 使 用 B_ 树 的 一些变形 ,其 中 B 十 树(B+ tree)

的 变形。一 棵 冯 阶 B 十 树 满足 下 列 条 件 :

(1) 每 个分支结 点 最多有

棵 子 树 。

(2) 根结 点 或 者 没有 子 树 ,或 者 最 少 有 两 棵 子 树 。

(3) 除根 结 点以外 ,其 他 每 个分支 结 点 最 少 有 | /2 | 棵 子 树 。

(4) 有 守 棵 子 树 的 结 点 有 7 个关键字。

要-要

视大计角

(5)

所 有 叶子结 点 包含 全 部 关键 字 及指向相应记录的指针,而且 叶 子结点 按 关键 字 大

小 顺序 链接 (可以 把 每个叶子结 点 看 成 是 一个基本 索引 块 , 它 的指针 不 再 指向 另一级 索引

块 , 而是直接指向 数据 文件中 的记录 ) 。

(6)

所 有 分 支结 点 (可 看 成 是 索引 的 索引 ) 中 仅 包 含 它的各 个 子结 点 (即 下 级 索引 的 索

引 块)中 的 最 大 关键 字 及 指向 子结 点 的 指针 。

例如 ,图 9. 28 所 示 为 一棵4 阶的 B 十 树 , 其中叶子结 点 的 每个关键 字 下 面的指针 表示

指向 对 应记录 的 存储 位 置 。通 常在 B十树上 有 两 个头指针 ,一 个 指向 根 结 点 ,这 里 为 root,

另 一 个 指向 关键 字 最 小的叶子结 点,这 里为sqt。

一 人人 、

了

、、

一

Toot

下、

了

7

、、

31 52 | 根 结 点 、

、、

索引

了

了

了

“

15 22 31

、、

、、

仆 、

4752 | 、、

Sdt也-| 10 12 15 |一| 18 19 20 22| 一~|23 30 31 上~|33 45 47 || 48 50 52 |叶子结点层

计 二 二 二 二 二

图 9.28 一棵 4 阶的 B十树

注意: mm2 阶的B十树和六阶的B- 树 的主要 差异如下 。

(1) 在 B 十 树 中,具有 个 关键 字 的 结 点 含有 7 棵 子 树,即 每个关键字对 应 一 棵 子 树 ,

而在B- 树中,具有姑个 关键 字 的 结 点 含有(z 十 1) 棵 子 树 。

(2) 在 B 十树中 ,除根 结点 以外 ,每 个 结 点 中 的 关键字个 数 的 取 值 范围是| 72/2 | 所

ms,根结点寻 的 取 值 范围是 2 入 si 而在B_-树 中 ,除根 结 点 以外 ,其 他所 有非 叶子 结

aa

点 的 关键字个 数姥有 [mV/21]一1和 ?z过im 一1, 根 结 点 到 的 取 值 范围是 1 过 7z祥一1。

(3) B 十树中 的所 有 叶子 结 点 包含了全 部 关键字,即其他非 叶子 结 点 中 的 关键字包 含 在

叶子结点中,而在B- 树 中 关键 字 是 不重复 的 。

(4) B十 树 中 的所 有非 叶子 结 点 仅 起 到 索引 的 作用 ,即 结 点 中 的 每 个 索引 项 只 含有对 应

子 树 的 最 大 关键字和 指向 该 子 树 的指针 ,不 含有该 关键字对 应记录 的 存储 地 址。而在B-树

中 ,每个关键 字 对 应 一 个记录 的 存储 地址 。

数据 结构教程

[第! 5版

(5) 通常在 B 十树上 有 两 个 头指针 ,一 个指向 根 结 点 , 另 一 个指向 关键字最 小的叶子 结

点 ,所 有 叶子 结 点 链接 成 一 个不定 长 的 线性 链表。所以,B- 树 只 能 进行随机 查找 ,而 B 十 树

可以 进行随机 查找 和 顺序 查找 。

在 BT 树 中 可 以 采用 两种春 找 方式 ,一 种是直接 从最小 关键字 开始 进行顺序查 找 (通过

sat 指针 查找) , 另一种 是从 B 十 树 的根结 点 开始 进行随机 查找 (通过 root 指针 查找 )。这 种

查找 方式与B_树的查找 方法相似 ,只 是在分 支 结点上 的 关键 字 与 查找值 相等时 查找并 不 结

来 ,要 继续 查 到 叶子 结 点 为 止,此 时 若 查找 成 功 ,则按 所 给 指针 取出 对 应 元 素 即 可 。 因 此,在

B 十 树 中 不管查 找 成 功 与否,每次 查找都是 经过了 一 条 从 根 结 点 到 叶子 结点的 路 径 。

2 大

与 B- 树 的插入 操作 相似,B 十 树 的插入 也 是 在叶子 结 点 中 进行的, 当 搬 人 后 结 点 中 的 关键

字 个 数 大 于 痉 时 要 分裂成 两个结 点 ,它们 所 含 的 键 值个数 分 别为|(mm十1)/2 |和 [L(Cmz十1)/2 | ,

同时 要 使得它们 的 双亲 结 点 中 包含有这 两 个 结 点 的 最 大 关键字和 指向 它们 的 指针 。 若 双亲

结点的关键字个数大于痛 , 应 继续 分 裂,依 此 类 推 。

EL

B 十 树 的 删除也 是 在 叶子 结 点 中 进行 的,当 叶 子 结点中 的最大 关键 字 被删除时 ,分 支 结

点中的值 可以 作为“分 界 关键 字 ” 存 在。若 因 删除操作 而 使 结点中 的 关键 字 个 数 少于|/2| ,

则 从兄弟结点中 调剂 关键 字或和 兄弟 结 点 合并 ,其 过 程和B- 树 相似 。

哈 希 表 的 查找

米

941 哈 希 表 的基本概念

在 介绍 哈 希 表 之 前 先看一个示例。假 设有一 个 班 的 学 生 表 , 包 含 20 个学

生 元 素(* 一 20) ,每 个学生 元 素 包 含 学号和 姓名数据 项 ,其中 学 号 是 关键 字 ,

视频讲解

全 部 元 素 是 按 学 号 无 序 排列 的 。由 于 是 同班 的 学 生 , 学 号 的 前 几 位 是 相同

的 ,如 都 以”201001?开头,后 3 位 是 序号,但 序号 并 非 是连续 的 (可能有 学 生 转 学 等 造成) 。

现在 要 设计 其存储 结构 ,以便 按 学 号 查找 。

PE

存储 学 生 表 的 最 简单 方法是 采用 一 个 数组 存储 ,也 就 是 顺序 存储 结构 ,如 图 9. 29 所 示 。
在 这 种存储 方式下查找 学 号为201001025 的 学 生 的 姓名只 能 顺序 查找 ,一边查找 一 边 进行

学号的比较。若 采用 从 前 向后的 顺序 查找 ,需要比较 20 次 ,对 应 的时间 复 杂 度为OC0z) 。 即

便 数据是按 学 号有序 的 ,采用 折 半 查找 对 应 的时间 复 杂 度 也为O(log:z)。

现在 根据 数据 的 特点 设计 另外 一 种存储结构,同样用 一 个 数组 存放 所 有 学 生 元 素 ,采用

一 个 函数 (学号) 一 学 号 一201001001 ,对 于 某 个 学 生 元 素 ,计 算出 其学号 的 函数 值,将 该 元

素 存 放 在 数组中对 应 的 下标(地 址 ) 处 ,如 图 9. 30 所 示 。 从 中 可 以 看 出 ,数组中有 些 元 素 是

空闲的(如由于没有 201001002 学 号 的 元 素 ,数组下标 1 的 元 素 空闲) ,所 以 数组大 小 m 一

346

2 查找 |
EX9AsP

学 号

姓名

201001001 | 张三

201001004 | 地四

学 生 表

201001003 | 于五

201001005 | 刘 六

201001025 | 许七

岂

地址

0

1

2

3

学号 | 201001001 | 201001004 | 201001003 | 201001005

姓名

张 三

李 四

王 五

刘 六

朵

本

4

19

201001025

许七

图 9. 29

学 生 表 的 顺序存储 结构

定 要 大 于 )。 这 里 假设靖=25,数组下标 为 0 一24。 在 这 种 存储 方式下查找 学 号 为

201001025 的 学 生 的 姓名,首先计算 地 址

&=201001025

一 201001001 王24, 然 后 与 数组下 标

24 处 的学号比较,相等 ,返回 其姓名 *许 七”, 对 应 的时间 复 杂 度为O(1)。 这 种 存储 结构 就

是哈希表。

学 号

姓名

201001001 | 张三

201001004 | 地四

学 生 表

201001003 王五

201001005 刘六

201001025 | 许七

履 学 号六 学号-201001001

0

学号 | 201001001

姓名

张 三

1

空闲

空闲

2

3

201001003 | 201001004

王 五

李 四

本

本

本

图 9. 30

学 生 表 的 哈 希存储 结构

本

站

24

201001025 | | 表

许七

哈 希 表 (hash table) 又称散列 表 , 其 基本思路 是 , 设 要 存储 的 元 素 个 数为 ... 设 置一个 长
度为2(m 三 轨 的连续 内 存单元,以 每 个元素 的 关键 字 已(0 所 ;和 2 一 1) 为 自 变量 ,通过一个

Ce

称为哈 希 函数(hash function)的函数 靖 Ai)把 睛 映射为内 存单 元的地 址 (或 下标 )j( 久 ) ,并

把 该元素 存储 在 这 个 内 存单元中 ,j(A) 也 称 为 哈希地 址(hash address)。 把 如 此构造的线

性 表 存 储 结构 称 为哈希 表 。

在 构建 哈希表 时 可 能 存在 这 样 的问题 ,两个关键 字 访

和 局 (天)门有访 夫 局,但 会出现

CD)一 AD) 的 情况 ,把 这 种 现象 叫哈希 冲突(hash collisions)。通 常 把 这 种具有 不 同 关键

347

数据 结构 教程

虹 第人5 【版

字 而具有 相同 哈 希 地 址 的 元 素 称 为同义词 (synonym) ,这 种 冲突 也 称 为同义词 冲突。在哈

和希 表 存储结构中 ,同义词冲突 是 很难避 免的,除非 关键 字 的 变化区间小 于 等于哈 希 地 址 的 变

化 区 间 ,而 这 种 情况 当 关键 字 取 值不连续 时 是 非常 浪费 存储 空间 的 。通 常 的实际情况是关

键 字 的 取 值 区间 远 大 于 哈 希 地 址 的 变化区间 。

归纳 起来, 当 一 组 数据的关键 字 与存储 地 址 存在某种 映射关系 时 ,如 图 9. 31 所 示 , 这 组

数据 适合 于 采用 哈 硕 表 存储 。

哈 希地 址

哈 希 国 数 A

址

7 个 元 素

丸 个连续的 存储单元

图 9.31 一 组与存储 地 址存在 映射关系 的 数据

在 哈 希 表 中 ,虽然冲突 很难避 免 ,但 发生冲 突 的 可 能 性 却有大 有小 ,这 会 影响哈 希 查找

的 性 能。哈 希 查 找 性 能 主要 与 3

个因素有关:

(1) 与 装填因子有关。所 谓 装填 因子(load factor) 是 指 哈 希 表 中 已存人 的 元 素数 ”与 哈

硕 地 址 空间大小疡 的 比值 ,即 %=z/zm。a 越小,冲突 的 可 能 性 就 越 小 ; 越大(最大可取 1) , 冲

突 的 可 能 性 就 越 大。这很容易 理解 ,因为 越小 , 哈 希 表 中空闲单元的 比例就越大,所以 待

搬入 元素和 已插入 的 元 素发生冲 突 的可能 性 就 越 小; 反之,a 越大, 哈 希 表 中空闲单元 的 比

例 就 越小,所以 待插入 元素和 已插入 的 元 素冲突 的可能 性 就 越 大。另一方面,a 越小,存储

空间 的利用 率 就 越 低 ; 反之 ,存储 空间 的利用 率 也 就 越 高 。 为了既 兼 顾 减少冲突 的 发生 , 又

兼顾 提高存储 空间的利用 率 这 两个方面,通常 使最终 的 控制在0. 6一0. 9 的 范围内。

《2)

与 所 采用 的 哈 希 函数有关 。 若 哈 希 函数 选择 得 当 , 就 可以 使 哈希地 址尽可 能 均匀

地 分 布在哈 希 地 址 空间上 ,从 而 减少 冲突 的 发生; 否则 , 若 哈 希 函数 选择不当 , 就 可 能使哈

希 地 址 集中 于 某些区 域,从 而 加 大 冲突 的 发 生 。

(3) 当 出 现 哈 希 冲突时需要 采取 解决哈 希 冲突 的 方法,所以 哈 希 查找 性能 也与 解决冲

突 的方法有关。

从图 9. 30 所 示 的 哈 希 表 看 出,对 于 预先 知道且 规 模 不 大 的 关键 字 集 合 ,通常 可以 找到

不 发生 冲 突 的 哈 希 函数 ,从 而 避免出现 冲突 ,使查找时间 复 杂 度为 O(1) ,提高了查找效率,

因此 对 频繁 进行查找 的 关键 字 集 应 尽力设计 一 个 完美的哈 希 函数 。

942 哈 希函数的构造 方法

构造 哈 希 函数 的 目标 是 使所有 元 素 的 哈希地 址尽可 能 均匀 地 分 布在立 个连续内存单

元 上 ,同时 使 计算 过 程尽可 能 简单以 达到 尽 可 能 高 的时间 效率。根 据 关 键 字 的结构和 分 布

的 不同可 构造 出许多 不 同 的 哈 希 函数。这 里 主要讨论 几 种 常用 的整数 类 型 关键 字 的 哈 希 天

ES查找|

数 构造方法 。

直接 定 址 法是以 关键字&A 本 身或关键字加 上 某 个 常量c 作为哈希 地 址 的 方法 。直 接 定

址 法 的 哈 希 函数 六 (&) 为 ,

扫-- 扫

户 (R) 一 太 十<

例如 ,图 9. 30 所 示 的 哈 希 表 就是采用 了 这 种 方法。

这 种 方法的特点 是 哈 希 函数 计算 简单 。当 关键 字 的 分 布 基本 连续 时 ,

可 用 直接 定 址 法 的 哈 希 函数 ; 否则 , 若 关键 字 的 分 布 不连续 将 造成内 存单 视顺讲解

元 的 大 量 浪 费 。

除 留 余数 法 是 用 关键 字 & 除以某个 不大于 哈 希 表 长度mm 的 整数 所 得 的 余数作为哈

希 地 址。除留余 数 法 的 哈 希 函数 (E) 通 常为:

j(R) 一Amod 记

(mod 为 求 余运算,产近 2)

除 留 余数 法 的 计算 比较 简单 ,适用 范围广,是 最 经 常 使用 的 一 种 哈 希 函数 。这 种 方法 的

关键是选好 户 , 使 得 元 素集合 中 的 每 一个关键 字 通 过 该函数转换 后 映射 到 哈 希 表 范围内 的

任意 地址上 的 概率 相等,从 而尽可 能 减少发生 冲 突 的 可 能 性 。例如, 取 奇 数 就比取 偶数

好。理 论 研 究 表明 , 取 不 大 于

的素数时效果最好。

例如 ,对 于 例 1. 1 的 届 辑结构 City,假设以区 号 作为 关键 字 , 哈 希 表 长度六 一 7, 选用哈

希函数,其中一7:

其 中 ,区 号 为 数字 串,VAL( 区 号 ) 用 于 将 区 号 转换成对 应 的 数值,计算结果 如 下 :

几(区 号) = VAL(C区号) mod 7

区 号

VAL( 区 号 )
岂(key)

010

10
3

021

21
0

027

27
6

029

29
1

025

25
4

设哈希表为haL0..6],

可以得到如图 9. 32 所 示 的 City的哈希表。

地址

区 号

城市 名

说明

0

1

2

3

4

5

6

021

029

010

025

027

Shanghai “| 上海,直辖 市

Xian

西安 ,陕 西省省 会

Beijing

Nanjing

北京 ,首都

南京 ,江苏省省会

Wuhan

武汉 ,湖北省省会

图 9.32

City 对 应 的 哈 希 表

Rs

3 数字分析状

该 方法是提取 关键 字 中 取 值较均匀 的 数字位 作为 哈 希 地 址 。它 适合 于所有 关键 字 值都

数据 结构 教程

\BOG

已 知 的 情况 ,并 需要 对 关键 字 中 每一位的取 值 分 布 情况进 fr六 ,

行分析 。

例如 有 一 组 关键 字 如 图 9. 33 所 示 。 通 过 分 析 可 知 ,每
个 关键字从 左 到 右 的第1.2、3 位和第 6 位 取 值 较 集 中 ,不

宜 作 为 哈 希 地 址 ,剩余的第4.5.7 和 8 位 取 值较分 散 ,可 根

据 实 际 需 要 取 其 中 的 若干位作为 哈希地 址。若 取 最 后两位

作为 哈 希 地 址 , 则 哈希地 址 集合 为 (2,75,28,34,16,38,62,

20)。这 样 设计 的 哈 希 函数 将一个 大 的 数据 取 值 范围映射

到 一 个 小 的 数据 取 值 范围。

其他 构造 整数关键 字 的 哈 希 函数 的 方法还有 平方取中

9

?
2

阿网四网西blblelelelelelele

EREIEIEIEEIEOOEECESIEOESERS

2
3

6

4

1

4

bljbln=lalj=l=lzlj=l=

blj=lwl=-jwlel>l=|>

|o

=|5lzl=||zlw

图 9. 33 ”一组关键字

法 、 折 和法等。平方取 中 法 是 取 关 键 字 平 方 后 分 布均匀 的 几 位 作为 哈 希 地 址 的 方法; 折和至

法 是 先把关键 字 中 的 若干段作 为 一小组,然后把各小 组 折 和至相 加 后 分 布均匀 的 几 位 作为 哈

希 地 址 的 方法。

943 哈 希 冲突 的解决方法

解决 哈希冲突 方法 有许多 ,主要 有 开放 定 址法和 拉链 法两大 类 。

全 开放定址半

开放定址法(open addressing) 就 是 在 出现哈 希 冲突时 在 哈 希 表 中 找一个 新 的 空闲位 置

存放 元 素。例 如 要 存放 关键 字 为 已

的 元 素,& 一六 ( 久 ) ,而 地 址 为 d 的 单元 已经 被其他 元 素

占用了 ,那么就在 & 地 址 的 前 后 找 空 闲 位 置 。就 像 某 个 人 买了一 张电影 票,他 晚到 了 电影

院 , 他 的 位 置 被 其他人 占 了 ,他 就 在 周围 找 一个空座位 坐 下 来 。那 么 怎么找 空闲单元呢? 根

据 开 放 定 址 法 找 空闲单元 的 方式又 分 为线性 探测法和 平方 探测 法等。

1) 线性 探测 法

线性探测法(linear probing)

是从发生冲突的 地 址 ( 设为 mm ) 开 始 ,依次探测必 的 下 一 个 地

址 ( 当 到 达 下 标为六 一 1 的 哈 希 表 表 尾 时 ,下 一 个 探测 地 址 是 表 首 地 址 0),直到找到一个空闲

单元为止(当 mm人 z 时 一 定 能 够找到 一 个 空闲 单元) 。 线 性 探测 法 的 数学 递 推 描述 公式 为 ,

co 一 CR)

妨 一 (Cd 十1) modm (0 去;过六一1])

其中,模六 是 为了保证 找到 的 位 置在 0一六一1 的有效 空间中。以 前 面 的看电影 为例,假设

电影 院 座位只有 一 排 ( 共 20 个 座位 ) ,他的座位是 8( 被 其他人 占 了 ),线性探测法就是依次

查看 9,10,...,20 的 座位 是 否 为 空 的,有 空 就 坐下 ,和 否则 再 查看 1,2,...:,7 的座位是否为空

的 ,如 此 这 样,他 总 可以 找到 一 个 空 座位 坐下 。

线性 探测 法 的 优点 是 解决冲突 简单 ,一 个 重大 的 缺点 是 容易 产生 堆积问题 。这 是 由 于

当 连 续出现 若 干 个同义词时( 设 第 一 个 同义词占用 单元 d ,这 连续 的 若干 个同义词将占用

哈 希 表 的 do .do十1 .do 十2 等 单元) ,随后任何 do 十1、do 十2 等 单元上 的 哈 希 映射 都 会由于 前

面的同义词 堆积 而 产生 冲突 ,尽管随后 的 这 些 关 键 字 并 没有同义词 。这 称 为非同义词冲突,就

是 哈 希 函数 值不相同 的 两 个元素 争 夺 同 一 个后继 哈 希 地 址 导致出现 堆 积 (或 聚集 现象。

【例9.9】 假设哈希 表 的 长 度 =13, 采 用 除 留余数 法 加 线性 探测 法 建立关键 字 集 合

350

ES查找|

(16,74,60,43,54,90,46,31,29,88,77)
的哈希表。

这 里 ”=王11,z 王 13, 采 用 除 留余数 法 设计 的 哈 希 函数为C)一 Amod 记 , 思 应 为小

于 等于zz 的 素数 ,假设 放 取值 13 ,并 采用 线性 探测 法 解决 冲突。则有:

jh(16)一3,

(74) 一 9,
j(60)一8,

刀 (43) 一 4
j(54)一2,
(90)一12,
站 (46)一7,
jh(31)一5,

(29) 一 3

没有冲突 ,将 16 放在ha[3]处,探测 1 次

没有冲突 ,将 74 放 在 ha[9] 处 ,探测 1 次
没有冲突 ,将 60 放在ha[8]处,探测 1 次

没有冲突 ,将 43 放在 ha[缮 处 ,探测1 次
没有冲突 ,将 54 放 在 ha[2]处,探测 1 次
没有冲突 ,将 90 放在ha[12]处,探测 1 次
没有冲突 ,将 46 放在ha[7]处,探测 1 次
没有冲突 ,将 31 放 在 ha[5] 处 ,探测 1 次

有 冲突

必 =3,d一(3十1) mod 13 一 4 仍有冲突
心一(4十1) mod 13一5 仍有冲突

心一(5十1) mod 13一6 冲突已解决,将 29 放 在 ha[6] 处 ,探测4 次

j(88)一10,
(77) 一12,

没有冲突 ,将 88 放在ha[10]处,探测 1 次
有 冲突

好 =12,d=(12十1) mod 13=0 ”冲突已解决,将 77 放在ha[0]处,探测两次

建立的哈希表 hna[0..12]如表 9. 1 所 示 。

表 9.1 哈 希 表 jna[0..12]

下 标

关键 字

探测 次 数

0

77

2

1

2

54

1

3

16

1

人4

43

1

5

3

1

6

2

4

7

4

1

8

60

1

9

74

1

10

88

1

11

12

90

1

2) 平方 探测 法

设发生冲突的 地 址为 du ,平方探测法(square probing) 的 探测 序列为do 十 1 ,do 一 1: ,

如 十于,do 一 2

。 平 方 探测 法 的 数学 描述 公式 为 :

do 一 九 (A)

太一 (do 十站)modm (1 受 i 近 罗 一 1)

仍以 前 面 的 看 电影 为 例 ,平方 探测 法 就 是在他 被 占用 的 座位 前 后 来 回 找 空座位 。

平方 探测 法 是 一种较 好 地 处 理冲突 的 方法,可以 避免 出现堆积 问题 。其 缺点是不一定

能 探测 到 哈希表 上 的所有 单元 ,但 最 少 能 探测 到 一 半 单 元 。

此 外 ,开放 定址法 的 探测 方法还有 伪 随 机 序列 法 、 双 哈 希 函数 法 等 。

从 中 可以 看出,开放 定 址 法 中 哈 希 表 空闲单元既 向 同义词 关键 字 开 放 ,也 向 发生 冲 突 的

非 同义词 关键字开放 ,这 就 是 它 的名称 的 由 来 。至 于 哈 希 表 的 一 个地址 中 存放 的 是 同义词

关键 字 还 是 非同义词关键字, 要 看 谁先占 用 它,这 和 构造哈 希 表 的 元 素 排列 次 序有关 。

拉链 法 (chaining) 是 把所有 的 同义词用单 链 表 链 接 起 来 的 方法 。如图

9.34 所示 , 所 有 哈 希 地 址 为守元 素 对 应 的结 点 构成一个 单 链表 , 哈 希 表 地 址

空间为 0 一 交 一1,地址 为宗的 单元 是 一 个 指向 对 应 单 链 表 的 首 结 点 。

351

数据 结构 教程

\B@OG

在 这 种 方法中 , 哈 希 表 的 每 个 单元中 存放 的 不再是元素 本 身 ,而是相应 同义词 单链表 的

首结点指针。由 于 在单链表 中 可 搬入 任意 多 个 结 点,所以 此 时 装填 因子 v 根据 同义词的多

少 既 可以 设 定 为大于 1 ,也 可以 设 定 为小 于 或 等于1 ,通常取 一 1。

0

JOB-ACG)=...于

哈
希 一直一一| 点 的元素 | ”一 一 | 态的 元素 |一-一一
表
地 《
址

MGJFNMCG)=...林
(一 可

:
;

:

宣
间

了了 一 一 | 大 的 元 素 | 一 一| 占的 元 素 | 一 |一...

二

=

图 9.34 拉链法的示意图

与开放 定 址法相 比 ,拉链 法 有以下几 个 优点 :

(1) 拉链 法 处理冲 突 简单 ,上且无 堆积 现象 ,即 非同义词 绝 不 会 发生冲 突 ,因此 平均 查找

长度较短;

(2) 由 于 拉链 法 中 各 单链表 上 的 结 点空间 是 动态申请的, 故它更 适合于 造 表 前 无法确

定 表 长 的情况;

(3) 开放 定 址 法 为 减少冲突 要 求装填 因 子 较 小 ,故当 数据 规模较大 时 会浪费 很 多 空

间 ,而拉链法中可取 w1, 且 元 素 较大时 拉链 法 中 增加 的 指针 域可忽略 不计 , 因 此 节省

空间,

(4) 在 用 拉链 法 构造的哈 希 表 中 ,删除结 点 的 操作 更加 易于 实现 。

拉链法也有缺点: 指针 需要 额外 的 空间 , 故 当 元 素 规模 较小 时 开放 定 址 法 较为 节省 空

间 , 若 将 节省 的 指针 空间 用 来 扩大 哈 希 表 的 规模 ,可 使装填 因子 变小,这 又 减少了 开放 定 址

法 中 的 冲突 ,从 而 提高了平均 查找 速度 。

【例9.10】〗 假设哈希表的长度 六 一 13 ,采用 除 留余数 法加 拉链 法 建立关键 字 集合(16,

74,60,43,54,90,46,31,29,88,77)的哈希表。

这 里 "一 11 ,一13, 采 用 除 留余数法设计 的 哈 希 函数为&Ce)一 Amod 13,当出现同

义词 问题时 采用 拉链 法 解决 冲突 。 则有:

7](54) 一2,几(16) 一3,(29) 一3,j(43) 一4,j(31) 一5

]几(46) 一7,几(60) 一8,j(74) 一 9,j(88) 一 10,)(90) = 12,j(77) 一 12

建立的哈希表如图 9. 35 所 示 ,其中哈 希 表 地 址空间为 0 一12 ,每 个地址单元 指向 一 个

单 链 表 , 如 果 没 有 对 应 的 单链表 结 点 ,该 地 址单元 为 空指针 。

944 哈 希 表 的运算算法

哈 希 表 的 常见运算有 插入 及 建 表 \ 删除和 查找 等 。一 个 哈 希 表 由 哈 希 函数和 解决冲突

方法 构成,而 不 同 的 解决冲突 方法其运算 算法 实现有 较 大 的 差异,下 面 分 别讨论。为了简

便 , 算 法 中 假设 每 个元素 仅 含有关键 字 。

352

ES查找|

一| 29

一| 16 | 八

十 -| 43T[ 和

31

盖

74 盖|>站>

|1

琳f 88

下 标

ownocownmwwn

10

中

11 | 从

12

和| 77 一| 90 | 人

图 9.35 采用 拉链 法 解决冲突 建立的哈 希 表

全 用 开放 十 法档知 的附和布表 的运算 算 半

本 节 仅 介绍 在开放 定 址法中 采用 线性 探测 法 解决 冲突时 实现 哈 希 表 运 算 算 法。设 计 哈

和希 表 的 类 型如 下 :

# define NULLKEY 一1

# define DELKEY 一2

typedef int KeyType;

typedef struct

{

KeyType key;

int count;

} HashTable;

// 定 义空关 键 字 值

// 定 义 被删 关键字 值
/关键字类型

// 关 键 字 域

// 探 测次数 域

// 哈 希 表单元类型

关键 字 类 型 为 整数,将 哈 希 表 中 空闲 单元的关键 字 设 置 为 特殊 值一1 ,被 删 元 素的关键

字 设 置 为 特殊 值 一2,以 示 区 别 。

1) 插入及建表算法

在建表 时 首先 要 将 表 中 各 元 素 的 关键 字 清 空 , 使 其地址 为开放 的 ; 然后调用 插入 算法

将 给 定的关键 字 序 列依次插入 表 中 。 在插和人算法中, 求出关键字& 的 哈 希 函数值 adr, 若 该
位置可以 直接 放置 (即 adr 位 置 的关键字 为NULLKEY 或 DELKEY) ,将其放人#; 否则 出现

aa

冲突 ,采用 线性 探测 法 在 表 中 找到 一 个开放 地 址 ,将 & 插入。对 应 的算法如下 :

void InsertHTCHashTable ha[] ,int &n,int m,int p,KeyType k) //将关键字k 插 和人到 哈 希 表 中

{

int iadr;

adr一k % p;

// 计 算 哈 希 函 数值

让 (ha[adr] .key一 =NULLKEY | ha[adr] .key一一DELKEY)

{

ha[adr] .key 一 k;

/全 可 以 直接 放 在 哈 希 表 中

353

数据 结构教程

[第! 5版

ha[adr] . count一1;

}

else

{ 这 1;

do

// 发生冲突 时 采用 线性探测 法 解决冲突

/Wi 记录 发生冲 突 的 次 数

{ adr一(adr十1) %% mi

//线性探测

i十十;

} while (ha[adr] .key!
ha[adr] .key一k;
ha[adr] .count 一 i

王NULLKEY了 人术ha[adr] .key!一DELKEY);

//在 adr 处放置
// 设 置 探测次数

// 哈 希 表 中总 元 素个数 增 1

}
n 十十 ;

}》

void CreateHT(HashTable ha[] ,int &n,int m,int p,KeyType keys[] ,int nl)

// 由关键字序列keys[0. .nl 一巧创建哈 希 表

{

for (int i一0;i<mi;i++)
{

ha[癌.key王NULLKEY;

ha器 .count一0;

}

n 一 0;

for (i一0;i<nlii++)

// 哈 希 表 置 空 的初什

// 哈 希 表 中总 元 素 个 数从 0 开始递增

InsertHT(Cha,n,m,p,keys[癌 );

// 揪入mn 个 关键 字

2) 删除 算法

在 采用 开放 地 址 法处理 冲 突 的 哈 硕 表 上 执行删除操作 时 不 能 简单 地 将 被 删元 素 的空间

置 为 空,否则 将截断 在 它 之 后填人 哈 希 表 的 同义词元 素 的 查找 路径, 这 是 因为在各 种开放 地

址 法 中 ,空地 址 单元 都 是 查找 失败 的 条 件 。因 此 只 能 在 被 删 元素上 做删除标记DELKEY,

而 不 能 真正 地 删除元 素。对 应 的算法如下 :

bool DeleteHT(HashTable ha[] ,int &n,int m,int p,KeyType k)

// 删除哈 希 表 中 的 关键字k

{

int adr;

adr 一 k %% p;

while (ha[adr]

.key!王NULLKEY 了&& ha[adr] .key!一k)

adr一(adr十1) %% mi

.key一一k)
迁 (ha[adr]

王DELKEY;
{ ha[adq.key

Teturn true;

}

else

}

Teturn false;

3) 查找 算法

// 计 算 哈 希 函数值

//线性探测

//查找成功

// 删除关键字 上

//查找失败

// 返 回 假

哈 希 表 的 查找 过 程和 建 表 过 程 相似。假 设 查找 关键 字 &, 根 据建表时 采用 的 哈 希 函数 刀

计算出哈希地址 (&) , 若 表 中 该地址 单元 不 为 空 ( 即 关键 字 值 不为NULKEY)且该地址的

关键字不等于A, 则 按 建表时 采用 的处理 冲 突 的 方法找 下 一个地 址 (这 里 采用 线性 探测 法 ),

354

ES查找|

如 此反复下去,直到 某 个 地 址 单元 为 空(查找 失败 ) 或者关键 字 比较相 等(查找 成功) 为 止,显

示 相 应 的结果。对 应 的算法如下 :

void SearchHT(HashTable ha[] ,int m,int p,KeyType k)

// 在 哈 希 表 中 查找 关键 字

{

inti 一1,adr;

adr一k % p;

// 计 算 哈 希 函数值

while (ha[adr] .key!王NULLKEY && ha[adr] .key!一k)

ii十十;
adr一(adr十1) %% mi

{

}

迁 (ha[adr] .key一一k)

printf("成功:关键字%d, 比较%d 次\n",k,D;

printf("失败:关键字%d,比较%d次\n",k,D;

else

)》

// 累 计 关 键 字 的 比较 次 数
//线性探测

//查找成功

//查找失败

4) 查找性能分析

插入和 删除 的 时间 均 取决于查找 , 故 这 里 只 分 析 查找 运算 的时 间 人 性能。

查找 成功的 平均 查找 长 度是指 查找 到 哈 希 表 中 已 有 关键 字 的 平均 探测 次数,实际上 , 查

找到 一 个 关键 字 所 需要 的 比较 次 数 恰好 等于对 应 的 探测 次 数

。 对 于 例 9. 9, 在查找等概率

的情况 下 ,其 查找 成功的 平均 查找 长 度如 下 :

ASLaa

1X9十2X1十4X1

1. 364

]1

式中1X9.2X1l1 和 4X1l 分 别 表示 探测 1.2 和 4 次 的关键字各有 9、1 和 1 个。

而 查找 不 成功的 平均 查找 长 度 是指 在 哈 希 表 中 查找 不 到 待查的 元 素 , 最 后找到 空位置

的 探测 次 数 的平均 值 。

对 于 例 9. 9 的 哈 希 表 , 采 用 的 是 线性 探测 法 ,假设 待查关键字& 不 在 该表中 ,如果计算

出 大 Ce) 一0, 则 必须将haL0]中的关键字 和 进行,不相等 ,再与haL1] 进行 比较 ,发 现

ha[1l] 为空 ,表示 查找 不 成功,一 共 比 较 两 次; 如果j()一1,将haLl]中的关键字和 A 进行

比较 ,发现 haLl] 为空 ,表示 查找 不 成功,一共 比 较 一 次;如果 jh&)一2,将 haL2..10]中的关

为空 ,表示查找不成
键字依次和 进行 比较 ,都不相等 ,再与ha[11] 进行比较,发现ha[11l]

功 ,一共比较 10 次; 如果/&)一3 ,将ha[3..10]

中的关键字依次和A进行比较,都不相等,

再与haL11]

进行比较,发现 haLl1] 为 空,表 示 查找 不 成功, 一 共 比 较 9 次。依 此 类 推 ,得 出

查找 不 成功的平均 查找 长 度 为 :

人ASL丰虹功

2 十 1 十 10 十 9 十 8 十 7 十 6 十 5十4 十 3 十 2十1 十 3
13

4. 692

Rss

由 此 得 出 采用 线性 探测 法 时 计算 成功和 不 成 功 平均 查找 长 度 的 算法如下 :

void ASLCHashTable ha[] ,int n,int m,int p)

// 求 平均查找 长 度

{

intij;

int succ 一0,unsucc一0,s;

for (i王0;i< mj;i 十十)

这 (ha[].key!=NULLKEY)

数据 结构教程

[第! 5版

succ十一ha[癌.count;

// 累 计 成功时 的 总 关键 字 比较 次 数

printf(" 成 功 情况下 ASL(C%d)一邓 gN\n",n,succx1.0/n);

for (i=0;i<pii十十)

人

s 一 1; j 一 让

while (ha[j] .key!王NULLKEY)

s十十;
j=G十1) %% mi;

{

】}

unsucc 十 一 s;

// 累 计 不 成功时 的 总 关键 字 比较次 数

}

printf(" 不 成 功情况下 ASL(C%d) 一 %gN\n",n,unsuccx1.0/p);

}》

【 例

构造一个哈希表,哈希表的存储空间
9. 11〗 用 关键 字 序列{7,8,30,11,18,9,14}

是 一 个 下标 从 0 开始 的 一 维数组 , 哈 希 函数为 瓦(key)= (keyX3) mod 7, 处理冲 突 采 用 线

性 探测 法 ,要 求 装填 ( 载)因 子为 0.7。

(1) 画出所 构造 的哈希 表 。

(2) 分别计算 等 概率 情况 下 查找 成功和 查找 不 成 功 的平均 查找 长 度 。

(1) 这 里

一 7,o= 一0.7 王2/和 ,则关 一2/0.7 一10。

计算 各 关键 字 存 储 地 址 的过程如下 :

(7)=7X3 mod 7=0

五 (8)=8X3 mod 7一3

五 (30)=30X3 mod 7=6

瑞(11)=11X3 mod7=5

五 (18)=18X3 mod 7=5

冲突

由一(5十1) mod 10王6 。 仍 冲突

吃一(6十1) mod 10 一 7

五(9)一9X3 mod 7 一 6

冲突

四 =(6十1) mod 10=7 。 仍 冲 突

心一(7十1) mod 10 一 8

五(14)=14X3 mod7=0

冲突

由一(0十1) mod 10=一1

构造的哈希表如表 9. 2 所 示 。

下 标

关键 字

探测 次 数

0

7

1

1

14

2

2

3

8

1

(2) 在等概率 情况 下 :

表 9.2 哈 希 表

4

5

11

1

6

30

1

7

18

3

8

9

3

9

ASLaa 十 2 十 1 十) 二 1 二 3 十 3

1.71

由 于任 一关键字&, 互(&) 的 值 只 能是 0一6 ,在 不 成功的 情况下 , 互(&) 为 0 时 需要比较

3 次 ,五(4) 为 1 时 需要 比较 两 次 ,五(&) 为 2 时 需要比较一次,瑟(A)为 3 时 需要 比较 两次,

356

ES查找|

瑟(A)为4 时 需要 比较 一 次 , 互 () 为 5 时 需要 比较 5

次 , 互(A)为6 时 需要 比较4 次,共 7 种

情况 ,如 表 9. 3 所 示 。

表 9.3 不 成功查找 的 探测 次 数

下 标

关键 字

探测 次 数

0

7

3

1

14

2

2

1

3

8

2

4

1

5

11

5

6

30

4

7

18

3

8

9

2

9

1

所以 有 :

ASLAaa

3 十 2 十 1 十 2 十 1 十 5 十4 _ 57

7

2 用拉链法梅造的内 布表的运算

用 拉链 法 构建的哈 希 表 是 一种顺序和 链 式 相 结合 的 存储 结构, 哈 希 表 地 址 空间为0一

2 一 1。设计 哈 希 表 的 类 型如下 :

typedef int KeyType;

typedef struct node

{

KeyType key;

/关键字类型

// 关 键 字 域

Struct node x nexti

// 下 一 个 结 点 指针

) NodeType;

typedef struct

{

// 单链表结点类型

NodeType * firstp;

// 首 结 点 指针

} 了HashTable;

// 险 希 表单元类型

1) 插入及建表算法

建 表 过 程 是 首先将ha[i(0

和过;i委mm一1)的firstp 指针 设置 为 空,然后调用搬入算法插入

个 关键字。 算法如下 :

void InsertHTCHashTable ha[] ,int &n,int p,KeyType k) // 将关键字上 插 和人到 哈 希 表 中

{

int adr;
adr 一 k % p;

NodeType * q;

// 计 算 哈 希 函数值

q 一 (NodeType * )malloc(sizeof(NodeType));

qd 一 key一k;

q 一 next 一NULL;

// 创 建一个 结 点 q, 存放 关键 字 下

计 (ha[adr] .firstp==NULL)

//若单链表 adr 为空

ha[adr] .firstp一qi;

,q 一 next一ha[adr] .firstp;

ha[adr] .firstp一qi;

else

{

}

D十十 ;

}

//若单链表 adr 不空

// 采 用 头 插 法插入 到 ha[adz]的单链表中

// 哈 希 表 中 结 点 的 总 个 数 增 1

void CreateHT(CHashTable ha[] ,int &n,int m,int p,KeyType keys[D] ,int nl)

// 由关键字序列keys[0. .nl 一可创建哈希表

357

数据 结构教程

[第! 5人版

{

for (int i 一0ii<miit+)

// 哈 希 表 置初值

到加 .fei二NOTL5

Dn 一 0;

for (i=0;i<nl;i++)

InsertHTCha,n,p,keys[D);

// 插入mn 个 关键 字

)》

2) 删除 算法

中找到对应的结点
如 果 要 在 哈 希 表 中 删除关键 字 为 & 的结 点 ,首先在单链表 haLA(CR)]

4,通过前驱结点 preq 来 删除 它。不 同 于 用 开放 地 址 法 构建 的 哈 希 表 , 在 这 里 可以 直接删
除。算法如下 :

bool DeleteHT(HashTable ha[] ,int &n,int m,int p,KeyType k)

// 删除哈 希 表 中 的 关键字k

{

int adr;

adr一k % p;

NodeType * q, * preq;
q 一 ha[adr] .firstp;

这 (q= 一一NULL)

return false;

让 (q 一>key一一k)

{

ha[adr] .firstp一q一> next;

free(q);
n 一一;
Teturn truei

}
preq一qi q 一9一 > nexti

while (q!=NULL)

这 (q 一 key一一k)

break;

Qq王qd一> next;

{

}

i (qdl=NULL)

preq -> next一qd 一> nexti

free(q);
n 一一;
Teturn true;

{

}

else return false;

}》

3) 查找 算法

// 计 算 哈 希 函数值

//aq 指 向 对 应单链表 的 首 结 点

// 对 应 单链表 为空

// 首 结 点为上

//删除结点q

// 结 点 的 总个数减1

// 返 回 真

// 首 结 点 不为上 时

//查找成功
//退出循环

//查找成功

//删除结点q

// 结 点 的 总个数减1
// 返 回 真

// 未 找到 kk, 返回 假

在 哈 希 表 中 查找 关键 字为A 的 结 点 ,只 需要 在 单 链 表 haLh()]

中找到对应的结点g,并

累计 关键 字 的比较 次 数。当 4 为 空时表示 查找 不 成 功 。算法如下 :

void SearchHT(HashTable ha[] ,int p,KeyType k)

// 在 哈 希 表 中 查找 关键字 上

{

inti

一 0,adr;

adr一k % p;

// 计 算 哈 希 函 数值

358

ES查找|

NodeType * q;
q王ha[adr] .firstp;

while (qdl=NULL)

{

ii十十;

这 (q-> key=一k)

break;

q一q 一 next;

}

让 (Cdql=NULL)

//q 指 向 对 应 单 链表 的 首 结 点

// 扫 描 单 链表 adr 的所有 结 点

//查找成功
//退出循环

//查找成功

printf("成功: 关键字%d, 比较%d 次\n",k,D;

else

// 查 找 失败

printf("失败: 关键字%d, 比较%d 次\n",k,D;

4) 查找性能分析

以例 9. 10 进行 讨论 。对 于哈 希 表 中 存在 的某个 关键字 ,对 应 的 结 点 在 单 链表 ALA]

中 , 它 属 于 该单链表 的 第 几 个 结 点 ,成 功找到 它 恰 好 需要 几 次 关键 字 比 较,所 以 有

:

ASLaa 一]芝 呈2 一 1.182

式中,1X9 表示有 9 个结 点 成 功找到 各 需要 一 次比较 ,2X2 表示 有 两 个结 点 成 功找到 各 需

要两次比较。

若 待查关键字丰 的 哈希地 址 为&一CA)(C0受 d过mm一1) ,且 第 d 个 单链表 中 有 : 个 结 点 ,

则 当 不 在 该 单链表 中 出 现时 需 做 ; 次 关键 字 的 比较 (不 包括 空指针判定) 才 能 确定 查找 失

败 , 因 此 有 :

ASL 不成功

0 十 0 十 1 十 2 十 1 十 1 十 0 十 1 十 1 十 1 十 1 十0十 2
本

0. 846

由 此得 出 采用 拉链 法时计算 成功和 不 成功的 平均 查找 长度的 算法如下 :

void ASLCHashTable ha[] ,int n,int m) 。 // 求 平均 查找 长 度

{

int succ一 0,unsucc一 0,s;

NodeType * qi;

for (int i一0;i<mi;i十十)

// 扫 描所有 哈 希 表 地 址空间

{

ss 一 0;

q一ha[i .firstp;

//q 指 向 单链表 i的首结点

while (q!==NULL)

// 扫 描 单链表 i 的所有 结 点

{ ,q王qd一next;
s 二 十:
succ 十一s;

】}

unsucc 十 一 s;

}

/人s 记录 当前 结 点是对 应单链表 的第几 个 结 点
// 累计 成功的 总 比较 次 数

aa

7/ 累计 不 成 功 的 总 比较次数

printf(" 成 功 情况下 ASL(%d)一%gN\n",n,succx1.0/n);

printf(" 不成功情况下 ASL(C%d) 一 %gNn",n,unsuccx1.0/m);

359

数据 结构教程

(第1 5 【版

从 上 述 讨论可以 看出,由 同一个哈 希 函数,不同的 解决冲突 方法 构造的 哈 希 表 ,其平均

查找长度可能不同。

在一般情况下 ,假设哈 希 函 数 是 均匀 的 , 则 可 以证明 不 同 的 解决冲突 方法得到 的 哈 希 表

的 平均查找长度不同。表 9.4 列出了 用 几 种 不 同 的 方法 解决冲突时 哈 希 表 的平均 查找 长

度 。从 中 可以 看 到 , 哈 希 表 的平均查找 长度不 是 元 素 个 数 的 函数 ,而 是装填 因子 的天

数。因 此 ,在 设计 哈 希 表 时 可选择 合适 的

以 控制 哈 希 表 的平均 查找 长 度 。

表 9.4 用 几 种 不 同 的 方法 解决冲突 时 哈 希 表 的 平均 查找 长 度

解决冲突 的 方法

线性 探测法

平方探测 法

拉链 法

平均 查找 长 度

成 功的查找

1

去 1+志:

1

一 二log.G 一 a

1 十 冯

不 成 功 的 查找

去 1+

1
(一 o)

-_

二 erexea

本 章 的 基本 学 习 要点如 下 :

(1) 理解 查找 的 基本概念,包括 静态 查找 表 和 动态 查找 表 、 内 查找 和 外

查找 之间 的 差异以 及 平均 查找 长 度 等 。

(2) 掌握线性表上 的 各 种 查找 算法 ,包括顺序 查找 、 折 半 查 找 和 分块 查

找 的 基本思路 、 算 法 实现 和 查找效率 分析 等 。

(3) 掌握各种树表 的 查找 算法 ,包括 二 叉 排序树\.AVL 树`B-树和 B+ 树 的 基本 思路 、

算法实现 和 查找效率等 。

(4) 掌握 哈 希 表 查找技 术以 及 哈 希 表与 其他 存储 方法的 区别。

(5) 灵活地运用 各 种 查找 算法 解决 一 些综合应用 问题。

el

1. 设有 5 个 数据 do ,for\if\repeat whbile, 它们 排 在 一 个有序 表 中 ,其 查找 概率 分 别 是
万 一0.2,思一0.15,p3 一0.1,因一0.03,55 一0.01 ,而 查找 它们 之 间 不 存在 数据 的 概率 分 别

为wm王0.2,qi 一0.15,dq 一0. 1,q: 一0.03,q 一0.02,qs 一0.01,该有序表如下 :

do

for

证

Tepeat

while

90

证

9 疡

9 PP3

9 Pa

44 忆

95

(1) 试 画出对 该有序 表 分 别 采用 顺序 查找和 折 半 查找时 的 判定 树 。

(2) 分别计算顺序 查找 的 查找 成功和 不 成功的 平均 查找 长度。

360

ES查找|

(3) 分 别计算 折 半 查找 的 查找 成功和 不 成功的 平均 查找 长 度 。

2. 对于 A[0..10] 有 序 表 , 在 等 概率 的 情况 下求采 用 折 半 查找 法 时 , 求 成功和 不 成功时

当用折半查找法
的 平均 查找 长 度 。对 于 有 序 表 (12,18,24,35,47,50,62,83,90,115,134),

查找 90 时 需要 进行多少次查找 可 确定 成 功? 查找 47 时 需要 进行 多 少 次 查找 可 确定 成功?

查找 100 时 需要 进行多少 次 查找 才能 确定 不 成功?

3. 有 以 下查找算法 :

int fun(int a[] ,int n,int k)

{

inti;

for (i王0;i<nj;i十一2)

让 (a加二一k)

Teturn i;

for (i王1;i<nj;i十一2)

让 (a加二一k)

Teturn i;

return 一 1;

)》

(1) 指出 fun(Ca,z,&)
算法的功能。

(2) 当 a[]={2.6,3,8,1,7,4,9}

时,执行fun(a,z,1)

后的返回结果是什么?一 共 进行

了 几 次 比较?

(3) 当 a[]={2.6,3,8,1,7,4,9}

时,执行fun(a,z,5)

后的返回结果是什么?一 共 进行

了 几 次 比较?

4. 假设 一 棵 二 又 排序 树 的 关键 字 为 单个字母 ,其后序 遍 历 序列为ACDBFIJRGE,回

答以下问题,

(1) 画 出该二 又 排序树 。

(2) 求在等 概率 下 的 查找 成功的 平均 查找 长 度 。

(3) 求 在等概率 下 的 查找 不 成功的 平均查找 长 度 。

5. 证 明 如 果 一 棵非空二 又 树(所 有 结 点 值 均 不相同 ) 的 中 序 遍 历 序列 是 从 小 到 大 有 序

的 , 则 该 二又树 是 一棵二 又 排序树 。

6. 由 23、12、45 关键 字 构成的二 又 排序 树有多 少 棵? 其 中 属于 平衡二又 树 的有多

少棵?

7. 将整数 序列 (4,5,7,2,1,3,6) 中 的 元 素 依 次 插入到 一 棵 空的二 又 排序树中 , 试 构造

相应 的 二 又 排序树 ,要 求 用 图 形 给 出 构造 过 程 。

8. 将整数 序列(4,5,7,2,1,3,6) 中 的 元 素 依 次 插入到 一 棵 空 的 平衡二 又 树 中 , 试构造

相应 的 平衡二 又 树 ,要 求用 图 形 给出构造过程 。

Sn

9. 已 知一棵 5

阶 B- 树中有 53 个 关键 字 , 则 树 的 最 大 高 度是多 少 ?

10. 设有一 组 关键字(19,1,23,14,55,20,84,27,68,11,10,77)

,其哈希函数为 几 (key)一

key % 13。 采 用 开放 地 址 法 的 线性 探测 法 解决冲突 , 试在0 一 18 的 哈 希 表 中 对 该 关键 字 序

列 构造哈希 表 , 并 求 在 成功和 不 成 功情况 下 的 平均查找 长 度 。

11. 设计 一 个 折 半 查找 算法 , 求 查找 到 关键 字 为&的 记录 所 需 关键 字 的比较 次 数。假

设& 与 Ri. key 比较得 到 3 种情况,即 & 王一R[让 .key一RCIi. key 或者人 >RLi.key,计

361

数据 结构教程

[第! 5版

为 一 次 比较 (在 教材中讨论 关键 字 比 较 次 数时 都是这 样 假设 的 ) 。

12. 设计 一 个 算法 ,判断 给定的 二 叉 树 是 否 为二又 排序 树。假设二 又 树 中 结 点 的 关键

字 均 为 正 整数且 均不相同 。

13. 设计 一 个 算法 ,在 一 棵非空二 又 排序 树 bt 中 求出指定 关键 字为& 结 点 的 层次。

14. 设计一个哈希表 ha[0..m一1I存 放 个 元 素 , 哈 希 函 数 采用 除 留余数 法 媚 (key)一

key%%pCp 生 2) ,解决冲突 的 方法采用 开放 定 址 法 中 的 平方 探测 法 。

(1) 设计 哈 希 表 的 类 型 。

(2) 设计 在 哈 希 表 中 查找 指定 关键 字 的 算法 。

一>一 上 机 实验题 9) 一

实验题1: 实现 顺序 查找 的 算法

目的: 领会顺序 查找 的 过 程和算法 设计 。

中采用顺序
内 容: 编写一个程序 exp9-1. cpp ,输出 在 顺序 表 (3,6,2,10,1,8,5,7,4,9)

查找方法查找关键字 5 的 过 程 。

实验题2: 实现折 半 查找 的 算法

目的: 领会折 半 查找 的 过 程和算法 设计 。

中采用折半
内 容: 编写一个程序 exp9-2. cpp ,输出 在 顺序 表 (1,2,3,4,5,6,7,8,9,10)

查找方法查找关键字 9 的 过 程 。

实验题3: 实现 分块查找 的 算法

目的: 领会 分 块查找 的 过 程和算法 设计 。

内 容: 编写一个程序exp9-3. cpp, 输 出 在 顺序 表 (8,14,6,9,10,22,34,18,19,31,40,

中采用分块查找法查找(每块的块长为
38,54,66,46,71,78,68,80,85,100,94,88,96,87)

5, 共 有 5 块)关键字 46 的 过 程 。

实验题4: 实现 二 叉 排序树 的 基本 运算 算法

目的: 领会二又 排序 树 的定义,二 又 排序 树 的 创建.查找和 删除过 程 及 其 算法 设计 。

内容: 编写一个程序 bst, cpp, 包 含 二 叉 排序 树 的 创建 查找和 删除 算法 ,在 此 基础上 编

写 exp9-4. cpp 程序完成以下功能。

(1) 由 关键 字 序列 (4,9,0,1,8,6,3,5,2,7)

创建一棵二又排序 bt 并以 括号 表示 法

BE

输出。

(2) 判断 bt 是 否 为一棵 二 又 排序 。

(3) 采用 递归和 非递归 两 种 方法查找 关键 字 为 6 的 结 点 ,并 输出 其 查找 路 径 。

(4) 分别删除 bt 中 关键 字 为4和 5 的 结 点 ,并 输出 删除后的 二 又 排序 。

实验题5: 实现 哈 希 表 的 相关 运算 算法

目的: 领会 哈希表 的 构造和查找 过 程 及 其 相关 算法 设计 。

内 容 : 编写一个程序exp9-5. cpp 实现 哈 希 表 的相关 运算 ,并 完成 以下功能 。

362

ES查找|

(1) 建立 关键 字 序列(16,74,60,43,54,90,46,31,29,88,77)

对应的哈希表 A[0..12],

哈希函数为 媚(&) 一&蜗 已,并 采用 开放 址 法 中 的 线性 探测 法 解决冲突 。

(2) 在上述 哈 希 表 中 查找 关键 字 为 29 的 记录 。

(3) 在上述 哈 希 表 中 删除关键 字 为 77 的 记录 ,再 将 其 插入 。

慌设计性实验

实验题6: 在有序 序列 中 查找 某 关 键 字 的 区 间

目的: 掌握 折 半 查找 的 过 程 及 其 算法 设计 。

内 容: 编写一个程序exp9-6. cpp, 在 有 序 序列 中 查找 某 关 键 字 的 区 间 。 例 如序列为(1,

2,2,3)

,对于关键字 2, 其 位 置 区间 是 [1,3) 。

实验题7: 求 两 个 等 长有序 序列的中 位 数

目的: 掌握折 半 查找 的 过 程 及 其 算法 设计 。

内 容: 编写一个程序exp9-7. cpp, 求 两 个 等 长有序 序列的中 位 数,有 关中 位 数的定义 参

见第 2 章 的例 2. 17, 这 里 要 求 采 用 折 半 查找 方法 求解。

实验题8:

由 有 序 序列 创建一棵 高 度 最 小的二 又 排序 树

目的: 掌握二 又 排序树 的 构造过程及 其 算法 设计 。

内 容: 编写一个程序exp9-8. cpp, 对 于 给 定 的 一 个有序 的 关键 字 序 列 , 创 建一棵高度 最

小 的 二 又 排序树。

实验题9: 统计一个字符串中 出现 的 字符 及 其 次 数

目的: 掌握二 又 排序树 的 构造过程及 其 算法 设计 。

内 容: 编写一个程序exp9-9. cpp, 读 人 一 个 字符 串 , 统计 该 字符 串 中 出 现 的 字符 及 其 次

数 ,然后输出结果。要 求 用 一 个 二 又 树 来 保存处理结果 ,字符串中 每 个不同的字符 用 树 描

述 , 每个结 点 包含 4 个 域,格 式 为 :

字符
该 字符 的 出 现 次 数
指向 ASCII 码小 于 该字符 的 左子树 指 针
指向 ASCII 码 大 于 该字符 的 左子树 指 针

实验题10: 求 一棵二 叉 排序树 查找 成 功 和 失败 情况 下 的 平均 查找 长 度

目的: 掌握二 又 排序树 的 查找 过 程 及 其 算法 设计 。

内 容: 编写一个程序exp9-10. cpp, 对 于 给 定 的 关键 字 序 列,构造一棵二又排序树 bt ,并

求 ht 在 查找 成功和 失败 情况 下 的 平均 查找 长度。

实验题11: 判断 一 个 序列 是 否为二 叉 排序树中 的 一 个 合法 的 查找 序列

目的: 掌握 二 又 排序 树的查找 过 程 及 其 算法设计 。

内 容: 编写一个程序exp9-11. cpp, 利 用 本 章 实验题 4 的 bst. cpp 程序 构造一棵 二 又 排

序树 bt, 判 断 一 个 序列

是 否为二 又 排序树 bt 中 的 一 个 合法 的 查找 序列 。

实验题12:

求 二 又 排序树 中 两个结 点 的 最 近 公共 祖先

目的: 掌握二 又 排序树 的递归 查找 过 程 及 其 算法 设计 。

363

数据 结构教程

[第! 5人版

内容: 编写一个程序exp9-12. cpp, 利 用 本 章 实验题 4

的 bst. cpp 程序 构造一棵 二 又 排

序树 bt, 输 出 bt 中关键字分别为zy 的 结 点 的 最 近 公 共 祖 先(LCA) 。

从综 合 性 实验

实验题13: 改进折 半 查找 算法 设计 和 分 析

目的: 深入 掌握折 半 查找 过 程.折 半 查 找 算法 设计 和 分 析 。

内容: 已知一 个 递增有 序 表 RL1..4 站 ,并 且 表 中 没有关键字相 同 的 元 素。按以下方法

查找一个关键字为& 的 元素: 先 在编号为4,8,12,...,47 的 元素中 进行 顺序 查找 ,或者查找

成 功 ,或 者由此 确定 一 个 继续 进行 顺序 查找 的 范围 。 编 写 程序exp9-13. cpp,完成以下

功能,

(1) 设计 满足上述 过 程 的 查找 算法 ,并 用 相关 数据 进行 测试,分 析 该 算法 在 成 功情况 下

的 平均 查找长度 。

(2) 采用 上 述 算 法和采用 折 半 查找 算法相比哪个较好 ? 为了提高 效率,可以 对 本 算法

做何改进? 给 出 改进 后 的 算法 ,并说 明 改 进 后 的 算法 的 时间 复 杂 度 。

实验题14: 求折 半 查找 成功时 的 平均 查找 长 度

目的: 深入 掌握 折 半 查找 过 程和折 半 查找 算法 分 析 。

内容: 编写一个程序exp9-14. cpp,建立由有序序列 RL0..x 一 菇 进行二分 查找 产生 的 判

定 树 ,在 此 基础 上 完成 以下功能 。

(1) 输出 2 一 11 时 的判定树 ,并 求 成 功 情况 下 的 平均 查找 长度ASL。

(2) 通过 构造判定树可以 求 得 的 成功情况 下 的平均 查找 长度ASLi;, 当 含有 个 结 点

的 判定树 看 成 是一棵 满二又 树 时 ,其 成功情况 下 的 平均 查找 长 度的理论值ASL: 约为

log: (7 十 1) 一1, 对 于 "一 10.100、1000、10 000.100 000 和 1 .000 000,求出其ASLI、ASL 和

两者的差值。

364

在第9 章 介绍 过折 半 查找比顺序 查找的 时间 性 能 好得 多 , 但折

半 查 找 要 求 被 查找的 数据 有 序。因 此 , 为 了提高数据的 查找 速度,

需要 对 数据 进行 排序。

本 章 介绍 各 种常用 的 内 排序 方法 , 包括插入 排序、 交换 排序、 选

择 排 序` 归并 排序和 基数 排序。

数据 结构教程

[第! 5版

排序 的 基本 概念

漆

假设 被排序 的 数据是由 一组 元 素 组 成的表 , 而 元 素 由 若干个数据 项 组 成 ,其中 指定 一 个

数据项为关键字,关键字用作排序运算的 依据。不 同于上 一 章 的 查找 ,这 里 的 关键 字 是 可 以

重复的,也 就是说 ,在 排序表 中 可 能 存在 关键 字 相同 的 两 个 或者多 个 元 素 。

全 什 交 是排序

所 谓 排序(sort) ,就是要 整理表 中 的 元 素 ,使之按 关键 字 递增或 递减有

序 排列 ,本 章 仅讨论 递增排序的情况 。其 确切 定义如 下 :

输入: 7个元素,Ro ,Ri ,...,R,-: ,其相应 的关键字分别为 如 ,请 ,...,

k并

输出:R。,R,,...R,, ,使得 谨 二 名 福 ...<如 ,。

记

和 一 1

因此 ,排序 算法 就是要 确定0,1,...,2一1的一种排列 im

,Pa-i,* 使表中 的 元 素依此

排列整理 后 按 关键字有 序 。

2 排序的种定作

当 待排序元 素 的 关键 字 均 不相同时 ,显然 排序结果 是 唯一的,否则 排序的结果 不 一 定 唯

一。如 果 待排序的表 中 存在有多 个 关键字相 同 的 元 素 , 经 过 排序后这 些具有 相同 关键 字 的

元 素 之 间 的相对 次序保持 不 变 , 则 称 这 种 排序 方法是 稳定 的 (stable); 反之 , 若具有 相同关

键 字 的 元 素 之 间 的 相对 次 序发生变 化 , 则 称 这 种 排序 方法是 不 稳定 的(unstable)。 注意,排

序 算法 的 稳定 性 是针对 所 有 输入 实例 而 言 的 。也 就 是 说 ,在所有 可 能 的 输入实例中,只 要 有

一 个 实例 使 得 算法 不满足 稳定 性 要 求 , 则 该 排序算法 就 是不稳定 的 。

于 内排序和外振序

在 排序过 程中 , 若 整个表 都 放 在 内 存 中 处 理 , 排序时 不 涉及 数据 的内、 外 存 交换 , 则 称 之

为 内 排序 (internal sort); 反之 , 若 在 排序过程中 要 进行数据 的内、 外 存 交 换 , 则 称 之 为 外

排序(external sort) 。内 排序 适用 于 元 素 个 数 不 是 很 多 的小 表 , 外 排序 则 适用 于 元 素个数

很多 ,不 能 一 次 将 其 全 部 元素放 人 内 存 的大表 。 内 排序 是 外 排序的 基础,本 章 只讨论 内

排序。

按 所 用 的 策略 不同, 内 排序 方法 可以 分 为需要 关键 字比较和 不 需要 关键 字 比较两类 。

需要 关键 字 比 较 的 排序 方法有插 人 排序、 选择 排序、 交 换 排序和 归并 排序 等; 不需要 关键 字

| 比较 的 排序 方法有基数 排序 等 。

天 基于 比 术 的排序算半的作人能

在 基于 比较 的 排序 算法 中 主要 进行 以 下 两种基本 操作 。

。 比较(compare) : 关键字之间的比较。

。 移动 (move) : 元 素 从 一 个位 置 移动到另 一个位 置 。

排序 算法 的 性 能 由 算法 的时间 和 空间 确定 ,而时 间 是 由 比较和 移动的次 数 确定 的 ,如 两

个 元 素 的一次 交换 需要 3 次 移动 。

366

MO 内排序 |

若 待 排序 元 素 的 关键 字 顺 序正好 和 排序顺序 相同 , 称 此 表 中 元 素 为 正序; 反之,若待排

序 元 素 的 关键 字 顺 序正好 和 排序 顺序 相反 , 称 此 表 中 元 素为反 序 。

下 面分析 基 于 比较 的 排序 算法 最 快有多 快 。假 设有 3 个记录 (CR ,R: ,Rs ) ,对 应 的 关键

字 为(Ai bz , 避 ) ,基于 比较 的 排序 方法 是,若 启 所 心 ,序列不变; 否则 交换 R 和 R;: , 变 为 序

列CR。,Ri ,Rs)。 如 此 这 样,所 有 情况 的排序过 程 构成 一 棵如 图 10. 1 所示的判定树 ,排序的

结果有 6(31) 种 情况 ,每 个 分支对 应 一 次 关键 字 比较 ,从 根 结 点 到 某 个 叶子 结 点 是 一种序列

的 排序 情况 ,所 需 比 较 次 数 为该叶子 结 点 的层次 一1, 如 情况 @ 需 要 两次比较 (最 好 情况 ) , 情

况 回 需要 3 次 比较 (最 坏 情况 ) ,最 坏 情况 也 不 超过 树 的 高 度。平均比 较 次 数 是所有 6 种情

况 的 平均 值,这 里 为 (2 十 3 十 3 十 2 十 3 十3)/6一 2.67 次 。

(RDR2R3)

(RiRzR3) | 加

|CRRsR)

石 反 愉

(CRzRR) |

团

|C2RRD 旋三认

CR | 回 |RRR) | 回

Co @ mm @ |

图 10.1 排序的判定树

推广一下 ,对于”个 元 素 排 序 结果有 24 种 情况 ,对 应 的 判定 树是一棵有 2z! 个 叶子

结 点 的 高 度 最 小 的 二 叉 树 ,其中 单 分 支 结 点个数为 0, 结 点 总数= 加 十妖三221 一1。设

其 高 度为刀 , 可以 求

出 = [log:2211 = log:z! 1 十1, 对 应 的 关键 字 比 较 次 数 最 多 为 一 1 即

[log:z1!|,可以计算出| logsz!| smlogm, 即尹zzlogsm。

以 上 推出,从平均 情况 看,大约 需 要 mlogsz 次 关键 字比较(所有 z! 种 排序 情况 的 关键

字 比 较 次 数 的平均 值),移动 次数也 是 同样的数量 级,所以 排序的平均时间 复 杂 度 为

OCzlogsz) , 即 基 于 比较 的 排序 算法 最 好 的 平均时间 复 杂 度为OCzlog:z)。也 就是说 ,如 果

采用 基于 比较 的 方法对 任意 的 ) 个 元 素 排 序,最 好 的 平均时间 复 杂 度为OCzlogsz)。后面

介绍 的 堆 排序、 二 路 归并 排序和 快速排序 都属于 这 一 类 好 的 排序 算法 。

5 排序 数据 的 组织

在 本 章 中以 顺序 表 作 为排序 数据 的存储 结构。为 简单 起见,假设关键 字 的 类 型 为 整型。

待排 序 的 顺序 表 中 数据 元 素的类 型 声明 如 下 :

typedef int KeyType;

typedef struct

{

KeyType key;

// 定 义 关 键 字 类 型为int

//元素类型

// 关 键 字 项

InfoType data;

// 其 他数据项,类 型为InfoType

} RecType;

// 排 序元素的类 型

367

数据 结构教程

[第! 5版

捅 和 排序的基本 思想是: 每次将一个 待排序的 元 素 按其关键字大小 搬入 到 前 面 已 经 排

好 序 的子表 中 的 适当 位 置,直到 全 部 元 素搬入 完成 为 止 。本 节 介绍 3 种 插入 排序 方法, 即 直

接 插 入 排序、 折 半 搬 入 排序和和希 尔 排序 。

1021 直接 插入 排序

1

假设 待 排序 的 元 素 存 放 在 数组 RL0..z 一 1] 中 ,在 排序过 程 的 某一中 间

扫--要

时刻,R 被 划分 成 两 个子区 间 尺 [0一 和 Ri 一 I,其中 前 一 个子区 间

是 已排好序 的有序 区 (ordered region) ,后一个子区间 则 是 当前 未 排序 的 部

分 ,不 妨 称 其 为 无序区 (disordered region) ,初始时 ;一 1, 有 序 区只有 RL0O]

一 个 元 素 。

视上HH邮

直接 插入 排序(straight insertion sort) 的 一 趟 操作 是 将 当前 无序区 的 开头

元素R[iGsi

英变为新的有序
过2一1)插人到有序区 R[0..z 一匡中 的适当 位 置 ,使 RL0..

区 ,如图 10. 2 所示。这 种 方法通常 称 为增量 法 ,因为 它 每 次 使有序 区增加一个元素。

有 序 区

无 序 区

对 于 第 ; 趟 排序 ,如 何 将 无序区 的 第 一 个 元 素

RIO]... RIEI |

RD RD

有尺[ 训 插入 到 有 序 区 呢? 其 过 程 是 先将尺 [菇 暂 放 到 tmp

炒 二夺

R[0]...RIEI RD | RU...Rp-0|

中,在有序 区 中 从 后 向 前 找 ( 初 值为 ;一1), 凡 是 关键
字 大 于 tmp. key 的记录 均 后 移 一 个 位 置 。若找到某个
玉RE 门,其 关键 字小 于 或 等于 tmp. key, 则 将 tmp 放 在 它
们 后 面 ,即置 RD 十 本 =tmp。

有 序 区
和人 说明:直接插入排序每赵产生 的有序 区 并不一 定

无序区

是 全 局有序 区 ,也 就 是 说有序 区 中 的 元 素 并 不一定 放
图 10.2 人 在最终 的 位 置上。 当 一个元 素 在 整个排序结束 前就忆

经 放 在 其 最 终 位 置上 称 为归 位(homing) 。

2 排序 算 闫

直接插入 排序的 算法 如 下 :

void InsertSort(RecType RD] ,int n)

//对R[o..n一菇按 递增有 序 进 行直接 插入 排序

{

inti j; RecType tmp;

for (i王1;i<nj;i十十)

{

, 庄 (R 加 .key<RIi一.key)

// 反 序 时

{ tmp一RD ;

j 王 i 一 1;

do

//找R 呈 的 插入 位 置

{ RD二IJ一 R 中 ;

// 将关键字大于 [器 .key 的记录后移

368

MO 内排序 |

j一一;
while (j>=0 && RD站.key>tmp.key);

)
RD 十 二 一tmp;

//在j十1 处插入 了器

)》

了 算法但析

若初始 数据 序列 按 关键 字 递增有 序即 正序, 则 在 每一趟 排序中 仅 需 进 行 一次关键 字 的

比较 ,因为每趟 排序 均 不 进入内 循环 。由 此 可 知 , 正 序 时 插入 排序的 关键 字 间 比 较 次数和 元

素 移动次数均达 到 最 小值Cu和 Ma。

Cu 忆 7

一 1, Mu一0

反之 , 关 初始数据序列 按关 键 字 递减有 序即 反 序 , 则 每 趟排序中, 因为当前有序 区

尺 [0 一 巧 中 的关键 字 均 大 于 待 插 元 素 Ri 的关键字, 所以内循环需要 将待插元 素 tmp 的

关键字和R[0..; 一 匡 中 全部 的关键 字 进行比较 ,这需要进行 ;次关键 字比较; 显然内循环里

需 将 R[0..i 一 匡 中 的所有 元 素 均后移 ,共 (一1) 一 0 十1=;i 次 移动 ,外加 tmp一RCI 与

RD十可=tmp 的 两次移动 ,一趟 排序所需 移动 元 素的总 数 为 ?十2。由 此 可 知 , 反 序 时 插入

排序的关键字 间比 较 次数和 元 素 移动次数 均 达到 最 大值 Cu 和 Mass。

=-吕=-2- OO ,

Ma 一 瑟 ii十 2 一 二全一 002)

在 平均 情况下 ,RIi](1反;和受2一1) 搬 入 到 有 序 区 RL0.. 一1]( 其中有 ;个 元素) 时 平均

的 比较次数为/2 ,平均 移动元素 的 次 数 为 i/2十2,故总的 比较和 移动 元 素 次 数约 为 :

阿 去 十立 十 2 =互 6+2= 卫生 = 002)
和 这 分打 -当 亲二 本不 同 下 技 拓 大让所 放 的间有委大 二 最

好 情况 是 表 初 态 为 正序, 此 时 算法 的 时间 复 杂 度为 OCz) ,最 坏情况 是 表 初 态 为 反 序,相应 的

时 间 复 杂 度为0(衬) 。算 法 的 平均时间 复 杂 度 也 是 O(z) ,也 就 是说 ,算法 的平均时间 复 杂

度接近最坏情况。

直接 搬入 排序 算法 中 只 使用;7) 和 tmp这 3 个 辅助变量 ,与 问题 规模, 无关,故辅助空

间复杂度为 O(1) ,也 就是说 , 它 是一个 就 地 排序 算法 。

ES

另外,当这7上且尺[可 .key王RD站 .key 时 ,本 算法将 RED 插入到 尽 L 门 的后面 , 使尺C

和 RCI 门 的相对 位 置保持 不 变,所以 直接 插入 排序 是一种 稳定 的 排序 方法 。

【例 10.1】 设 待排序的表有 10 个 元 素 ,其关键 字 分 别 为

(9,8,7,6,5,4,3,2,.1,0) ,说

明 采 用 直接插入 排序 方法 进行 排序 的 过 程 。

其 直接 插入 排序过 程如 图 10.3 所 示 。 图 中 用 带 阴 影的部 分 表示 当前 的有序 区 ,每

趟 都向有 序 区 中 插入 一 个 元 素 , 并 保持 其有序 性 。

369

数据 结构教程

[第! 5人版

初始 关键 字 国 喇 同 辐 日 日 习 回
友 1 趟结果 国 国 司 司 日 日 可 回回
=at,

后
国 国 国 辐 恒 回回器 器

器 后

和3 趟结果 :

-uns, 国 国

=5 趟结果 :

吕

器

-un,国 国 国国国 国国回 品
-ax,国国国国国国国国口
-un,国 国 国 国 国 国国国 国 局
rs, 国 国 国 国 国 国 国 国 国生

gb6eE

1022 折 半 插入 排序

四 10.3 ”直接插入排序的过程

直接插入 排序中 将 无序区 的 开头 元 素 RL 让 (1 近 ij和 2 一1) 搬入到 有 序 区 RL0..: 一 1] 是 采

用 顺序比较的方法 。由 于 有 序 区 的 元 素 是有序的,可 以 采用 折 半 查找 方法 先在RL0..i一]

中 找到 插入 位 置 , 再通过 移动 元素进 行 插入 ,这 样 的插入 排序称为折 半 插入 排序(binary

insertion sort)
或二分插入排序。

一1)中采用折半查找
第 守 趟在及 [low..high](初始时 low=0,high=:

十1..z一匡元素后移
方法 查找插入 尺 [菇 的 位 置 为尺Lhigh十匡,再将REhigh

一 个 位置 ,并 置 Rhigh十1一 RI。

说明: 和 直接插入 排序一 样,折 半 插入 排序每赵产生 的有序 区 并 不 一

定 是 全 局 有 序 区 。

2 排序 算法

折 半 插 和人排序 的 算法如 下 :

void BinInsertSort(RecType R[] ,int n)

{

intij,low,high,mid;

RecType tmp;
for (i=1;i<n;i十十)

{

疾 (R回 .key<Ri一可.key)
{ tmp一RD;

// 反 序 时
// 将 R 加 保存到 tmp中

low王0; high一i一1;

while (low < 一 high)

//在R[low..high] 中查找插入的位置

370

MO 内排序 |

{

mid 一(low 十 high)/2;

// 取 中 间 位 置

这 (tmp.key<RLmid] .key)

high 一 mid 一 1;

// 插 入点 在 左 半 区

else

low 一 mid 十 1;

】}
for (j 一 一 1;j>一high十1;j一一)

RD 十切一RD;

有R[high 十二 二 tmp;

//插入点 在右半 区
// 找 位置high
// 集 中进行元素后移

// 插 入 tmp

】}

》}

}

3 全 天作

折 半 插 和人排序 的 元 素 移动次数 与 直接 搬 和人排序相 同 ,不同 的 仅 是 变分散 移动 为集中 移

动。在 R[0..一1]G 个 元 素)中 查找 搬入 R[ 菇 的位 置,折 半 查找 的 平均 关键 字 比 较 次 数约

为 log:(i十1) 一1, 平 均 移 动元素 的 次 数为 /2 十2, 所以 平均时间 复 杂 度 为 :

7一1
> (log,i 十 1 一 1 十 广 十2)

四

一 OC2)

实际上 , 折 半 插入排序和 直接 插入 排序相 比 移动元素的性 能没有 改善,仅仅 减少了关键
字 的比较次数。就 平均性 能 而 言,由 于 折 半 查找 优 于 顺序 查找 ,所以 折 半 插 和 人 排序也 优于 直

接 搬入 排序。折 半 搬 和人排序的空间 复杂 度为 O(1) ,也 是 一 种 稳定 的 排序 方法 。

1023 希 尔排序

和 三 排序 客

希 尔 排 序(shell sort) 也 是 一 种插入 排序 方法 ,实际上 是 一 种 分组插 和 方法。其 基本思

想 是先取 一 个 小于 的整数 di 作为 第 一 个 增 量 ,把 表 的 全 部 元 素 分成

个 组,将所有上距离

为 由 的 倍数 的 元 素 放 在 同一 个组中 ,图 10.4 是 分为d 的 情况。在 各 组 内 进行 直接插入 排

序; 然后取 第 2 个增量 & (过 ), 重 复上述 的 分组和 排序,直到 所 取 的增量 4 三

1(d sd -二 ... 二 加 二 di),即所有 元 素 放 在 同一组中 进行直接 插 和 人 排序 为 止 。所以 希 尔 排

序 称 为减少 增 量 的 排序 方法 。

第 1组 |RI0,

Rd,

RD2d,...,

Rd

jd-1

第 2组 |RI,

RII+ 可 ,RII+2d,...,

RII+kd]

第 ;组 |RIFH,R[E1+g,R[-1+2d,...,R[1+kd]

第 4d组 |RId-1,R[2d-1],

R[3d-U,...,

RerDd-H

每 组 中 相 邻的 两 个 元 素相距 4 个 位 置

图 10.4 和希 尔排序时分为 & 组

371

数据 结构教程

[第! 5 【版

每一赵 希 尔 排序从 元 素 RLd] 开 始 起 ,采用 直接 插入 排序,直到 元 素 RLz一菇为止。每

个 元 素的比较和 插入 都在同组内 部 进行,对 于 元 素 Ri, 同组 的 前 面 的 元 素有 { RD7 | 7一

1 一 4 二 0) 。

说明: 希 尔排序 每赵并 不 产生有 序 区 ,在 最后一 趟 排序结束 前 ,所 有 元 素 并 不 一 定归 位

了 ,但 是 在希尔排序 每赵完 成 后 数据越 来 越 接近有 序 。

2 排序算关

取 力 =2/2,dsa=Ldi/2|时 的 硕 尔 排序 算法 如 下 :

void ShellSort(ReeType RD ,int mn)

。 // 希 尔排序算法

{

intij,d;

RecType tmp;
d 一 n/2;

while (d>0)

// 增 量 置初什

{

for(i=dii<nii十十)

// 对 所 有 组 采用 直接 插入 排序

{ tmp一RD
j一一d;
whbile (j >一0 && tmp.key<RD丫.key)

// 对 相隔 d 个 位 置一组 采用 直接 插入 排序

RD+d=RD,

j 一 j 一 d;

{

】》

RD 十 可 一 tmp;

】}

d 一 d/2;

}

}》

3 全 天启 和

//减小增量

希 尔 排 序 法 的 性 能 分 析 是 一 个 复杂 的 问题,因为它的时间 是 所 取 * 增 量 序 列的函数 ,到

目前 为止增 量 的选取 无 一 定论 。但 无 论增量 序列如何 取 , 最 后 一 个 增 量 必须 等于1。 如果

按照上述 算法 的 取 法 ,即

心 =zy/2,ds=|diy/2| (二 1), 也 就 是 说 ,每 次后一 个增量 是 前 一

个 增 量的 1/2, 则 经 过 :一 log* (2 一1) 次 后 叉 =1。 和希 尔 算法 的时 间 复 杂 度 难以分析 ,一 般 认

为 其 平均时间 复 杂 度为00x3)。 和希 尔 排序 的 速度 通常要 比 直 接 插入 排序 快 。

分 析 希 尔 排序过 程 ,可 以 看 到 当 增 量 d=1 时 希 尔排序和 直接 插入 排序基本 一 致 。为

什么 希 尔 排序 的时间 性 能 优 于 直接 插入 排序呢? 一 方面,直接插入 排序 在 初始数据 为正序

时 所 需 的时间 最少; 另 一方面,当交值较小时,”和 寡 的 差别 也 较小 ,即 直接插入 排序 的 最

好 时 间 复 杂度 OC0z) 和 最 坏时 间 复 杂 度 OCz2 ) 差别 不 大。在 希 尔 排序开始时 增 量 必 较大,

PE

分 组 较 多 ,每组的 元 素数 目少; 故 各 组 内 直接 插 和人较 快,后 来增量 w 逐渐 缩小,分组 数 逐 渐

减少 ,而 各组 的 元 素数 目 逐 渐 增 多 ,但 由 于 已经按 凡 -; 作 为 距离排过序 ,使 数据接近 于 有 序

状态 ,所以 新 的一趟 排序过 程也较 快 。因 此 , 希 尔 排序在 效率上 较 直 接插入 排序 有很 大 的

改进。

例如有 z(z 一10) 个 元 素 进行 递增 排序 ,在 采用 直接 插入 排序时 平均时间 大约为10?一

100。 而 采用和希 尔 排序 ,四 一 5, 分 为5组 ,每 组两个 元 素 , 执 行 时 间 大约为 5X 痛 一20; 心一2,

分 为 两组,每组 5 个 元 素 ,执行时间大约为 2 勾 显 =50; ds 一 1 ,分 为 一组 ,每 组 10 个 元 素 , 但

372

MOMS 内排序 |

此 时 数据 序列 基本正 序 ,直接插入 排序 呈现 最好 性 能 ,执行 时 间 大约 为1X10=10。 累计 起

来 , 希 尔 排 序 的 时 间 大约为 80,好 于 直接插入 排序 。

在 希 尔 排序 算法 中 只 使 用 入 和 六 & 和 tmp 这 4 个 辅助变量 ,与 问题 规模 无 关 , 故 辅助空

间复杂度 为 O(1) ,也 就 是说它 是 一 个就地 排序 。

另外 , 希 尔 排 序 法 是 一种不 稳定 的 排序 算法。例 如 , 若 希 尔 排序 分 为 {3,10,7,|8| ,20}和

{5,8,2,1,6}

两组,显然第 1 组的 |3| 排 列 在第 2 组的 8 的后面,两组采用 直接插入 排序 后 的

结果为13,7,|8|,10,20}

和{1,2,5,6,8} ,这 样第1 组的 |3|排列到第 2 组的 8 的 前 面,它们的

相对位置发生了改变。

说明: 一 般 情 况 下 ,一 个 排序 算法 在排序过程 中 需要以 较 大 的间隔 交换 元 素 或者把 元

素 移动一个较大 的 距离时该排序 方法 是不稳定 的,因为 可 能 会 把 原来排在前面的 元 素 移 动

到 具有 相同 关键 字 的 另 一 个元素 的 后 面 。证 明 一 个排序算法 是 不稳定 的,只 需要 给 出 一 个

反例即可; 反之,需要 给 出证明 过程 。

【 例 10.2】〗 设 待排序 的表有 10 个 元 素,其 关键 字 分 别 为 (9,8,7,6,5,4,3,2,1,0),说

明 采 用和希 尔 排序 方法进行排序的过 程 。

其排序过程如图 10. 5 所示。第 1 趟 排序时,d=5,整个表被分 成5组 ,即(9,4)、

(8,3)、 (7,2)、(6,1)、 (5,0), 各 组 采用 直接 插入 排序 方法变 成 有序 的 ,即结果 分 别 为 (4,9)、

(3,8)、 (2,7)、(1,6)、 (0,5) ,最 终结 果 为 (4,3,2,1,0,9,8,7,6,5)。

第 2 趟 排序时,dg一2, 整个表 分 成 两 组 ,即 (4,2,0,8,6) 和 (3,1,9,7,5), 各 组 采用 直接

插入 排序 方法 变 成 有序 的 , 即结果 分 别 为 (0,2,4,6,8)和 (1,3,5,7,9)。

第 3 趟 排序时,qd=1, 整个表 为一组 ,采用 直接 插入 方法 使 整个 数列 有序 ,最终结果 为

(0,1,2,3,4,5,6,7,8,9)。

ax 回 辐 辐 园 辐 加 回回 口 回

F

F

册 分 为 5组
加 加 局 国 国 加 局 电压国
画 品 口口回国

ak,国

册 分 为 两组

口上四 已四品目 已目己 晶

oa, 器国局 四 局 四 局 四

用 分为 -组
回国 回国回国 轩辕 回避

as 园国回国

园 罩 园 团 加 曲

图 10.5 希 尔排序过程

373

数据 结构教程

[第! 5 【版

交换 排序的基本思想 是 两两比较待排序元素的 关键 字 , 发现这 两 个元素 的 次 序相反

时 即 进行 交换 ,直到 没有反 序 的 元 素 为 止 。本 节 介绍 两种交换 排序 ,即冒泡 排序和 快速

排序。

1031 冒泡排序

全 拉 序 二

冒 泡 排序 (bubble sort) 也 称 为 气泡 排序 ,是 一种典型的交换 排序 方法,其 基本思想 是 通

过 无序区 中 相 邻 元 素 关键 字 间 的 比较和 位 置 的 交换 使关键 字 最 小 的 元 素 如 气泡一般 逐 渐 往

上 ”漂浮?直至“水 面?。

整个 算法 从 最 下 面 的元素 开始 ,对 每 两个相邻的 关键 字 进 行 比较 , 且 使 关键 字 较小 的 元

素 换 至 关键 字 较 大 的 元 素 之上 ,使得经过一趟 骨 泡 排序后 关键 字 最 小 的 元 素到达 最 上 端,如

图 10. 6 所示。接 着 ,在 剩下的 元 素 中 找 关键 字 次 小 的 元 素 , 并 把 它 换 至 第 二 个 位 置上。 依

此 类 推,直 到 所 有 元 素 都有序 为止。

-|

RIOI

中
区 | 一 趟 排序

RI0]

”|

C一一一> 机

有

序
区

于 |器 将无序区中的 “|
最 小 记录 放 到
AR

,
RH

RIHH] 天

RH

区

AL

10.6

冒 泡排序 的 一 趟 排序过 程

有 序 区 是 全局有 序 的,初始时为空 ,排序趟次i: 0 一2一 2

说明: 冒泡 排序 每趟产生 的有序 区 一 定是全 局 有 序 区 ,也 就是说 每 趟产生 的有序 区 中

的所 有 元 素 都 归位了 。

2 排序 算法

冒 泡 排序 的 算法如下 :

void BubbleSort(RecType 人RD] ,int n)

{1

intij;

for (ji一0;i<n一1;i十十)

for Gj一n 一15j> ij 一 一 )

和 (CR四 .key<RD 一可 .key)

//将R 辐 元 素 归 位
// 相 邻 的 两 个元素 反 序 时

swap(RD] ,RD一可);

//将RD 和 RD 一蕊 两个元 素 交 换

374

MOS 内排序 |

【例10.3〗 设 待排序的表有 10 个 元 素 , 其 关键 字 分 别 为 (9,8,7,6,5,4,3,2,1,0),说

明 采 用 冒 泡 排序方法 进行 排序的过 程 。

其排序过程如图 10. 7 所示,每次从无序区中冒 出 一 个 最 小关键字的元 素 并 将 其 定

位 (图 中 用 带 阴 影 的部分 表示 当前 的 有序 区 ) 。

初始 关键字 “| ?| | 5j

| [可 卓

团

同

辐 癌 辣

一 一

ma 国可梧 品 回回 回避 回 6

1超结有果, 同| 于 习
ma

同 同 同 朋 下 [ 蔬
国 国 国器加 日 加 日 品目

mus 国 国 国

国 可口品司器

ras, 国 国 国国国可品

品 品 日

rs , 团

国 国 同

国

=6 趟 结

i7 趟 结果 ,

司

司

恒 回避 国

瑟 回回 国

己

国

加

右

上

园

国

上 门口

己 FF 一

?jl:j

|

-下

喇 所

思 ?|

rs , 于

国 国 国 国 同 国 国 加

|
|

图 10.7

冒 泡排序过程

在 有 些情 况 下 ,在第 ii<z 一 1) 趟 时 已排 好 序 了 ,但 仍 执行 后 面 几 趟 的 比较 。实际上,

一 旦 算法 中 的 某 一 趟 比较时 不 出 现任 何元 素 交 换 ,说 明 已排好 序 了 ,就可以结束 本 算法。为

此,改进冒泡排序算法如下 :

void BubbleSortl (RecType RCI] ,int n)

{

intij;

bool exchange;

for (i一0;i<n一1;i 十十)

{

exchange一false;

// 一 趟 前 exchange 置 为假

for (G 一 n 一 1;jj>ij一一)

// 归 位 RD ,循环n一一1 次

证 (R四 .key<RD一可.key)

// 相 邻 两 个 元素反 序 时

aa

{ swap(RD]

,RD一IJ); /将 RD 和 RD 一切 两个元素交 换

exchange一true;

// 一旦有 交换,exchange 置为真

】}

让 (!exchange)

// 本 趟没有发生 交换 ,中 途 结 束算法

Teturni

数据 结构教程

虹 和 5 人版

3 算 关 介入

若初始 数据 序列是正序的 , 则 一 趟 扫描即 可 完成排序,所 需 的 关键 字比较和 元 素 移动 的

次 数 均 分别达到 最 小值 ,

Cnin 一 7 一 1, Ma 一 0

若 初始数据序列是反 序 的 , 则 需要 进行 x-1 趟 排序,每趟 排序 要 对 无序区 REi.x一1

中的x 一; 个元素 两 两比较 ,比较次数 为 w 一 ;一1(0<i< xn一 2), 且 每次比较都必须 移动 元 素

3 次 来达到 交换 元 素 位 置 的 目的 。在 这 种 情况下,比较和 移动次数均达到 最大值 ,

2

Co

1

002)

Ma 吕 3 一 十1 2 了

OG2)

平均 情况 分 析 稍 微复杂 一 些 , 因 为 算法 可 能 在 中 间 的 某 一 道 排序 完成 后 就 终止 ,但 可 以

证 明 平均 的排序趟数仍是OC0z) ,由 此 得 出 平均 情况 下 总 的比较次数仍是O(02 ) , 故 算 法 的

平均时间复杂度为OCz) 。

由 上 述 分 析 可 知 , 当初始 数据 序列 不同时 冒 泡 排序所 耗费 的时间 有很 大 差异 。最 好 情

况 是 表 初 态 为 正序 ,此 时 算法 的时 间 复 杂 度为 O(z) ,最 坏 情况 是 表 初 态为反 序,相应 的时 间

复杂 度为0(02) 。算 法 的平均 时 间 复 杂 度 也 是 002 ) ,也 就是说 ,算法 的 平均时间 复 杂 度 接

近 最 坏情况。虽 然冒泡 排序 不 一 定 要 进行 x 一1 趟 ,但 由 于 它 的 元 素 移动次数 较 多 ,一 般 平

均 时 间 性 能 要 比 直 接插入 排序差。

在 冒 泡 排序 算法 中 只 使用zz 和 tmp 这 3 个 辅助变量 ,与 问题规模 ) 无 关 , 故 辅助空间

复杂 度为O(1) ,也 就 是说它是一 个就地 排序。

另外,当 ;z>) 上 且尺Li. key王RL门 .key 时 ,两 者 没有逆序 ,不 会 发生 交 换 , 也 就 是说 使

REz 和 尽 [ 门 的 相对位 置 保持 不 变,所 以冒泡 排序是 一 种稳定 的 排序 方法 。

1032 快速 排序

和

快速排序(quick sort) 是 由 冒 泡 排序改进 而得 的 , 它 的 基本思想 是 在 待 排序 的 ”个 元 素

中任 取 一 个 元 素 ( 通常取 第一个 元 素 ) 作 为 基准 ,把 该 元 素放和人适当位 置后,数据 序列被此 元

素 划 分 成 两 部 分 。所 有 关键 字 比 该 元 素 关键 字小 的 元 素 放 置 在 前 一 部 分,所 有比它大的元

素 放置 在后一 部 分 ,并 把 该元素 排在这 两 部 分的中间 ( 称 为 该 元素归 位),这 个 过 程 称 为一趟

快速排序,即一趟划分。

之后对 产生 的 两个部 分 分 别重复上 述 过 程,直 至 每部分内只 有 一 个 元 素 或 空 为 止 。简

而 言之,每 趟使表 的 第 一 个 元 素放人 适当位 置 ,将 表 一 分 为二,对 子 表 按 递归 方式继续 这 种

划分 ,直至 划分 的子表 的 长 为1或 0。

一 趟 快速排序 的 划分 过 程 partitionCR,s,

记是采用从两头向中间 扫 描 的 办

法 ,同时 交换 与 基准 元 素 逆序 的 元 素 ( 参 见第 2 章 的例2. 4) 。 具 体方法是设两

个 指示 器 和 产 它们 的 初 值 分 别 为指向 无序区 中 的 第 一个和 最 后 一 个 元 素 。

假设无序区中的元素为RLS],RLs

十1,......RIO,则站 的 初 值 为*,7 的 初值为

上, 首先将Rs]移至变量 tmp 中 作为 基准,令 7 自 位 置: 起 向 前 扫描 直至

376

MOMSP 内排序 |

及 [7门.key<tmp. key 时 将 R[I7 门移至位置;然后让守 向后

无序区 Rs .可

扫描 直至尽[ 让 . key二tmp. key 时将Ri移至位置), 依此

RE] RES+H]

册

RI

重复 直至 ;一) ,此 时 所 有RELA](C 一 ss 十 1,... 一 1) 的 关键

可 是排 序

一:十1十2,...的关
字 都 小于 tmp. key,而所有RLA](E

键字必大于 tmp. key,此时再将 tmp 中 的 元 素移 至位置 记 ,
它 将 无序区 中 的 元 素 分 割成RE 一可 和 RE 十 1.. 口 ,以便
分 别进行排序,如图 10.8所示。

RES]

RE-1H] | RD | RE+1H ....... R[

无 序 区
Rs

。”归位 无 序 区

RIHL

图 10.8 快速 排序的_ 直划分过程

说明: 快速排序每赵 仅将一 个 元 素归位。

显然 ,快速 排序 是 一 个递归 过 程 ,其递归 模型如下 :

CR,s*, 电 皇 不 做任何事情

当 RS. 器 中没有 元 素 或 者只有 一 个 元 素 时

CR,s 昌 二 ;一 partition人

Rs 划;

其 他 情况

CR 一 1);

CR十1,D7

2 排序 算 闫

快速排序算法如下 ,

int partition(RecType RD] ,int s,int t) //一趟划分
{1

一 s,j一t;

inti

RecType tmp王RD ;

//以及口为基准

while (Ci<j)

// 从 两 端交替 向中间 扫 描 , 直 至 i 一 j 为目

{

while 0j>i 攻 RD.key> 一tmp.key)

j 一一;

RD 一 RD ;

// 从 右 向左扫描 , 找 一 个小于 tmp.key的RD
// 找 到 这 样的RD,放和 及器 处

while (i<j 必 & RD .key<一tmp.key)

i 十 十 ;

RD门=RDD;

}
有R 口 王tmp;

return ii

// 从 左 向 右 扫 描 , 找 一 个大于 tmp.key的有器
// 找 到 这 样的R口,放入了RD 处

)}
void QuickSort(ReeType RD] ,int s,int tb)

。 //对 R[s..吕的 元 素 进行 快速 排序

{人 inti

这 (s<t

// 区 间 内 至 少存在 两个元 素 的 情况

{

ii王partition(R,s,t);
QuickSort(R,s,i 一1);
QuickSort(R,i 二 1,b;

// 对 左 区 间 递 归 排 序
// 对 右 区 间 递 归 排 序

)》

【例 10.4】 设 待排序的表有 10 个 元 素 ,其关键 字 分 别 为 (6,8,7,9,0,1,3,2,4,5),说

明 采 用 快速 排序 方法 进行 排序的过 程 。

其排序过程如图 10.9 所示。第 1 趟 是以 6 为 关键 字 将 整个区 间 分 为 (5,4,2,3,0,1)

和(9,7,8)

两个子区间 ,并将 6 元 素 归 位; 对 于 每 个子区间 , 又 进行 同样 的排序,直到 该子区

间 只 有 一 个 元 素 或不存在 元 素 为止。

377

1Rh本=of1受

\@6@

一

四
局
|这
1芝1

em上lm|m上上册
加H-人OF一扑
|,le区|jsFP@II>”
己1一|=十|1长
=四吕YE县
了|才2E加忆肌Jo-辐1|=忆局1ee呈Ifl2属二||
一刁Is||盈
下4车一zi
oo一上+Tlinlmn
避避1上_世
~全--;ENW”中、1
1ie一1一1mm1[el11
二屎一,
11“hanhe@,不
上上间一己.
11|
1m|c=|A媳NA羡
,加局一LE
1=H|
|一|写oo加
11太
1王
1灾
1
国电NEN玉
oo了人11+[
天定1十上二F--@
区|-G
已|名
Q
人2
呈
+|如
加辐四
11过
上一一一:己
-ID全
4,闪
上百+||aol去
玉
1ce1
四
"=回
Im|瑟宫|r一一一-一一1
上|呈
|-|-@-
aa
<到
加日=
问|

w
1
e
1要
i芝
入1|十|吐

,
写

四
加

抢

四

6879013245

=区

一

6879013245

6879013245

542301
Z

14230

四

234

以

978

do@

他

542301

|
@

五 人
由

0123453678

01234536789

(e) 第 5 次 划分 :[0[LL213[41516[9[7[s

(D 第 6 次 划分:

0|1|1213|14|151618|719

6879013245

@

542301

了

14230

皮

忆

相

四

1 上

SO

3456789
2
(g) 第 7 次 划分 :[0[il213[4[s16[7Tsl9

10

图 10.9 快速 排序过 程

378

MO 内排序 |

结果 如 图 10. 9(g) 所 示 ,这 样 的 一 棵 树 称 为 快速 排序递归 树 ,其 中 每 个 分 支结点对

应 一 次递归调用,这 里递归次数 为7次 。从 中 可以 看 出 , 左 、 右 分区处 理 的 顺序 是 无关 的 ,也

就 是说, 当 一 次 划分 产生 两 个子区间 时 先处理 左 分 区 还 是 右 分 区 不 影响 排序 的结果 ,因为 这

两个子 问 题 是独立 的 。

快速排序最好 的情况 是 每 一 次划分都将 个 元 素划 分为 两个长 度 差不多 相同 的 子 区

间,也就 是说,每 次划分 所 取 的 基准 都 是当前 无序区 的 “中值?元素 ,划 分 的结果 是 基准 的 左 、

右 两 个 无 序子区 间 的 长 度 大 致 相等 ,如图 10. 10 所 示 ,这 样的 递归 树 高度为 O(log:z) ,而 每

一 层 划 分 的时间 为

空间复杂度为
O(z) ,所 以 此 时 算法的时间 复 杂 度为O(Czlogsz)、

O(Clog27)。

于 个 元 素
几 一国 分 Cl

个 元素 “| () | ,--1个元素

修 人 外

大约[logxz]层

图 10.10 快速排序 的最好 情况

快速 排序最 坏 的 情况 是 每 次 划分选取 的 基准 都是当前 无 序区中 关键 字 最 小 (或最大 ) 的
元 素 , 划 分 的结果 是 基准 左边 的子区 间 为 空 (或 右边的子区 间 为 空), 和全的 地 和个非

空 的子区间 中 元 素 的 数目仅比划 分 前 的 无序区 中 的 元 素个 数 减少一 个。这 样的 递归 树 高 度

为 见 需 要 做 2 一 1 次 划分 ,此 时 算法 的 时 间 复 杂 度为OCO2)、闪 间 复杂 成为OCz)。

在平均 情况下 ,每 一 次划分将半 个 元 素 划分 为 两 个长 度 分 别 为 A 一1 和 ”一 &的子区间,

& 的 取 值 范围是1一2”,共守 种 情况 ,如图 10. 11 所 示 。 设执行时间为 Te(Cz) ,显然有 :

Ts一o 十二1 TD 十 TeGz一如))

7 k=1

由 上 式 可 以 推出 Te 王 OCzlogsz),其中 cz 表示 划分的时间 。

7 个 元 素

几 一 EN, /的 取 值范围是1-m,共 和 情况

记-1 个 元素 | () | zt个元素

公休

图 10.11 快速排序的平均情况

最坏的时间复杂度为
由 上 述 分 析 可 知 , 快 速排序最好 的 时间 复 杂 度为OCzlog:z)、

OG2 ) ,平均时 间 复 杂 度为 OCOzlogsz) ,也 就是说 ,算法 的 平均时 间 复 杂 度 接近 最 好 情况 。

当初始数据 序列 为正序 或者反 序时 ,显然呈现 出最坏 的 情况。如 果 初 始 数 据 序列是随

机 的 ,每 次可以 划分 为 两 个 长 度 差 不多相同 的子区间 ,会 呈现 出最好 的 情况 。

在 快速排序 算法 中 一 趟 使 用 让) 和 tmp 这 3 个 辅助变量 ,为 常量级, 若 每 一 趟 排序 都 将

379

数据 结构教程

[第! 5人版

,所需栈空间为
元 素 序列 均匀 地 分 割 成 两 个 长度接近 的子区 间 ,递归 树 的 高 度为O(log:z)

O(logs*z)。但 是 在 最 坏情况 下递归 树 的 高 度为 OC0z) 所 需 栈空间为O(z) ,平均 情况下所 需

栈空间为 O(logsz) ,所 以 快速 排序 的 空间 复杂 度为O(logsz)。

另外 ,快速 排序算法是一 种不稳定 的 排序 方法 。例 如 ,排序 序列 为 15,2,4,8,7,|旨),基

准为 5, 在 进行 划分时 后 面 的 |介会放置到前面 2 的 位 置上 ,从 而 使其放 到 4 的 前 面,两个相

同 关键字(4) 的 相对 位 置 改变了 。

实际上 ,在 快速 排序中 可 以以任意 一 个 元 素为基准 (更 好 的 选择 方法是从 数序中 随机 选

择 一 个 元 素 作为 基准),以 下 算法以 当前 区间 的 中间位 置 的元素为基准 ,同样可 以 达到 快速

排序 的

目的;

void QuickSortl (RecType RD ,int s,int b) //对有R[s..口 以中间 位 置 元 素 为基准 进行 快速排序

inti,pivot;
pivot 一 (s 十t)/2;
这 (s<tb

{

, 诈 Cpivot!=s)

// 用 区 间 中 间 元 素作为基准
// 区 间 内 至 少存在 两 个元素 的 情况

// 若 基准 不 是区间 中 的 第 一 个 元 素 ,将 其 与第一 个 元 素 交 换

swap( 了人了 [pivotj ,R[Ls] ) ;

i 一 partition(R,s,t);
QuickSortl(R,s,i 一1);
QuickSortl(R,i 十1,b;

// 划 分
// 对 左 区 间递归 排 序
// 对 右 区 间 递 归 排 序

}

{

)》

选择 排序的基本 思想 是 每一趟 从 待排序 的 元素中 选出关键字最小的 元 素 ,顺序放在已

排 好 序 的子表 的 最 后 ,直到 全 部 元 素 排序 完毕 。由 于 选择 排序 方法 每一赵总是从 无序区 中

选出全 局 最小 (或 最大) 的关键字, 所以 适合于从 大 量 的 元 素 中 选择 一 部 分 排序 元 素 ,例如从

10 000 个 元 素 中 选择出 关键 字 大小 为 前 10 位 的 元 素 就 适合 于 采用 选择 排序方法 。

本 节 介 绍 两 种 选择 排序 方法 , 即 简单 选择 排序 (或称直接 选择 排序)和 堆 排序 。

1041 简单选择 排序

下

PE 简单选择排序(simple selection sort) 的 基本思想 是 第 ; 趟 排序开始时 ,当前有序区和无
序 区 分 别为RL0..一1和必 Ci. 一 1(0 过 ;过 2 一 1) ,该 趟 排序 是从当前 无序区 中 选出关键

字 最小 的 元 素 RLA],将它与无序区 的第 1 个 元 素 尺 [交换 ,使 RL0..菇 和民

打-归

忆 十 1..2 一 匡 分 别 变 为 新 的有序区和 新 的 无序区 ,如 图 10.12 所 示 。

因为每趟 排序均 使有序 区 中 增加 了 一 个 元 素,且 有 序 区 中 元 素 的 关键

字 均 不大于 无序区 中 元 素 的 关键 字 , 即 第 ; 趟 排序之后R[0.. 实 的所有 关键

字 均小 于 等于RC 十 1..2 一 中 的所有 关键 字 , 所以 进行 2 一1 趟 排序之后

视频讲解

380

MOMS 内排序 |

RL0..z一2] 的所有 关键 字 小 于 等 于 R[2 一1]. key, 也
日、
就是说,经过-1 趟 排序 之 后 整个表 R[0.. 一1 递增 [RONRT [RATTCAT

有 序 区 无序区

有 序 。

1

说明, 简单 选择排序每下 产生 的 有 序 区 一 定是全 | 冰 瑟 刘 区 下庆

局 有 序区,也 就 是说 ,每 趋 产生的有序区申所 有 元 素都 本

只 位 了

,

那么如何从无序区 RE 一 1 中 选出关键 字 最小

R[0] .... REET RD RE ...., RIz-1]

有 序 区 无序区

的 元 素 R[A 呢 ? 简单选择排序 就是采用 最 简单 的 两两 ”图 10. 1 直接选择排序的一趟
元 素比 较 的 方法 实现的,其 过 程如下 ,

排序过程

k 一 ii;

/kk 存放 R[i..n 一切中 最 小 关键 字 的下标 , 初 值为i

for (一 i 十1;j<njj十十)

// 扫 描 无序区 中 的所有 元 素

计 (RD阅.key< 有RU .key)

// 将 较小 的 元 素 下 标存放 到 k 中

上 一 j;

显然,RLz..2

一1苛中共有 2 一 ; 个 元 素,上 述 过 程需要 ”一;一 1 次关键字比较。然 后 将

RELA]与 RE 详 交 换 , 将 RLA]放在无序区 RLi..z 一 芍 最 前 面,从 而 实现了 一 趟 排序 。这 种采

用 简单比较 方法 选出关键 字 最小 的 元 素 就是简单 选择 排序名 称 的 由 来 。

2 排序 算闫

简单 选择 排序 的 算法如 下 :

void SelectSort(RecType RD] ,int n)

intij,k;
for (i王0;i<n一1;i十十)

人 kk一i

// 做 第 i 趟 排序

for (一i计1;j<n;j 十十)

// 在当前无序区 R[i..n 一 切中选key 最小的R[I

让 (RD .key< 有R[k] .key)

上 一 j;

让 (k!一iD

swap( 有R[ 口 ,R[k] );

}

/VEk 记下目前 找到 的 最 小 关键 字 所 在 的 位 置
//R 呈 和 有[]两个元素交换

{

)》

【例 10.5】 设 待排序的表有 10 个 元 素 , 其 关键 字 分 别 为 (6,8,7,9,0,1,3,2,4,5),说

明 采 用 简单选择 排序 方法进行 排序 的 过 程 。

其排序过程如图 10. 13 所 示 ,每 趟选择 出 一 个 元 素 ( 图 中 用 带 阴影 的 部 分 表示 当前

的有序区) 。

3 算法分析

Ta

显然,无 论 初始数据 序列 的 状态如 何 ,在 第 ; 趟 排序中 选出最 小 关键 字 的 元 素 ,内 for 循

环 需 做 "一 1 一 G 十 1) 十1=2 一 ;一1次 比较,因此总 的比较 次 数为:

C 7

1 一碾 本
至 于 元素的 移动 次 数,当初始 表 为正序 时 ,移动次数 为 0; 当 表 初 态 为反序时 ,每 直 排 序
均 要 执行 交换 操作 ,所以 总 的 移动次数 为最大值3(*一1) 。然 而 ,无论元 素 的 初始序列 如 何

OCz2)

7 一;一

所

吕
>,

CO 一 1)

381

数据 结构 教程

\ 上OO

初始 关键 字 司辐同辐辣 相
六0 越结果,

盾 同 司 辣 同 局 同 占 辐 卓

[辐 |可上 5

-aas 国 国 同 辐 回 国 吕 回回 扣
疡 邮 是 ,国 国 国 癌 同国司 同 辣 后
六3 趟结果 : 司国国 国 司辐癌 同 辣
ma 国国国国国品 中 同 同日
司 [可问 辐 辐
加 区
-5而引采, 国
ou, 国 国 国 国 国 国国辣口晤
区 国 癌 日
国 国 国 国 加
并#果, 国
=s5呆, 国 国 国 国 攻 司回国 国 加

国

国

图 10.13 ”直接选择排序的过程

排列 ,所 需 进 行的关键 字 比 较 相 同 ,因此总 的 平均时间 复 杂 度为OO2) 。

在 简单选择 排序 算法 中 只 使 用 认 六 A 和 tmp 这 4 个 辅助变量 ,与问题规模 无关, 故 畏

助 空间复杂 度为O(1) ,也 就 是说它是 一 个 就 地 排序 。

另外 ,简单选择 排序 算法 是一个 不 稳定 的 排序 方法 。例 如 排序 序列 为 15,3,2,|5|,4,1,

8,7} ,第 1 趟 排序时 选择出最小 关键字 1 ,将其与第 1 个 位置上 的 元 素 交 换 ,得 到 {1,3,2,5,

4,|5|,8,7) ,从中看到两个 5 的相对 位 置 发生了 改变 。

1042 堆排 序

全 振 序 二 全

堆 排 序C(heap sort) 是一种 树 形 选 择 排序方法 , 它 的 特点 是 将 RL1.. 站 CR[ 菇 的 关键 字 为

A 司 ) 看 成 是 一 棵 完全 二 又 树 的 顺序 存储 结构 ,如 图 10. 14 所 示 。 利 用 完全 二 又 树中双亲 结 点

和 孩子结点 之间 的位置关系 在 无序区 中 选择 关键 字 最 大 (或 最小 ) 的 元 素 。

扫-- 扫

CC9

图 10. 14

将 关键 字 序列 看 成 一 棵完全 二 又 树

堆的定义是RL1..四中的半 个关键字序列 ,局 称为 堆 , 当 且 仅 当 该 序列 满足 如

下 性 质 ( 简 称 为 堆性质 ) :

382

MOMS 内排序 |

(1) 忆 委 li2 且 久 入pr 或 (2) 及全入且 居 全ArGsi雪 LV/2|)

满足 第(1) 种情况 的 堆 称 为小根堆 (对 于 图 10. 14 ,就

是树中 分 支 任何结 点的关键 字都 小于其 孩子结 点 的 关键 [AT

AT

TAIT 而

字 ) ,满足 第(2) 种情况的堆 称 为大根 堆(对 于 图 10. 14 ,就
是 树 中任何 分 支结 点 的 关键 字都大于 等于其 孩子结点 da
关键字) 。下 面主要讨论大 根 堆 。

记录放在 R

堆排序 的排序 过 程 与简单选择排序 类似 ,只 是挑选最 [LA ... AE-U mA ... Am

大 或 最小元素时 采用 的 方法 不同,这里 采用 大 根 堆 , 每 次 二 有 区
挑选最大 元 素 归 位 ,排序 过 程如 图 10. 15 所 示 。 挑 选 最大 图 10.15 堆 排 序的一 趟排序过程

说明: 堆排序 每 赵 产 生 的有序 区 一 定是全局有 序 区 ,也 就 是说 每 赵产生 的有序 区 中的

所 有 元 素 都归位 了 。

推排序 的 关键 是 筛选,其 过 程 是 假如 完全 二 又 树 的 根结 点 是R[,它的左右子树已是

大 根 堆 ,将 其 两 个 孩子的关键 字 RL2i. key\、RL2i十1]. key 的最大 者 与 R[i. key 比较,若尺

[让. key 较小 ,将其与最大 孩子进行 交换 ,这 有 可 能 破坏 下 一 级 的 堆。继 续 采 用 上 述 方法构

造 下 一 级 的 堆 , 直 到 这 棵 完全 二 又 树 变 成 一个大 根 堆 为止。

假设对RLlow..high]

进行得选,必须满足如图 10. 16 所 示 的 前 提 条件 ,即 以 RLlow]为

根结 点 的 左 子树和 右 子 树 均 为大根 堆 , 其 筛选 算法 sift()如下:

void sift(RecType RD ,int low,int high)

{

int i 一 low,j一 2* ji

/RD 站 是 R口的 左 孩子

RecType tmp一RD ;
while (j <一high)
{

话 G<high&& RD.key<RD 二巧.key) // 若 右 孩子较大 ,把 j 指向右孩子

j十十;

这 (tmp.key<RD] .key)
{

RD=RD],
i 一 j;

j 一 2x<i

】}
else break;

}
及器 一 tmp;

)}

// 若 根 结 点小 于 最 大 孩子的关键 字
//将R 呈 调整到双亲 结 点 位 置上
// 修 改i和 j 值,以 便 继续向下筛选

// 若 根 结点大 于 等于最 大 孩子关键 字 ,筛选结束

// 被 筛选 结 点放和人最 终 位 置上

构建 初始堆RL1..站的过程是: 对 于 一 棵 完全 二 又 树,从 ;一 Lz/2|一1,即 从 最 后 一 个

分 支结 点 开始 ,反复利用上 述 筛 选方法建堆。大 者“上 浮”,小 者被“筛选"下去。即:

aa

for (ji 一n/2;i>一1;i一一)

sift(R,i,n);

在 初始堆 RL1.. 站 构造好以后, 根结 点 RLI] 一 定 是最大 关键 字 结 点 ,将 其 放 到 排序序列

的 最后,也 就 是将堆 中 的 根 与 最 后 一个叶子 交换。由 于 最 大 元 素已归位 ,整个待 排序 的 元 素

个 数 减少一个。由 于 根 结 点 的改变 ,这 ”一1 个结 点 RL1..x 一 1 不 一 定 为堆,但 其 左 子树和

383

数据 结构教程

[第! 5人版

图 10. 16 ”第 选 算法 建 堆 的 前 提 条 件

右 子 树 均为 堆 , 再调用 一 次 sift 算法 将这 ”一 1 个结 点 RL1..” 一 匡调 整 成 堆 ,其 根结 点 为 次

大 的 元 素 ,将 它 放 到 排序 序列 的 倒数 第 2 个位 置 ,即 将堆中 的 根 与 最 后 一个叶子 交换 , 待 排

序 的 元 素 个 数 变为 2 一2 个 ,即 RI1..” 一2], 再 调整 ,再将根 结 点 归 位,如 此 这 样,直 到 完全

二 又 树 只 剩 一 个 根 为 止 。实 现 堆 排 序 的 算法如 下

void HeapSort(RecType RD ,int n)

inti3
for (ji一n/2;i

sift(R,i,n);

for (一 nii>一2;i 一 一 )
swap(RLI] ,RD);
{
sift(R,1,i 一 1);

}

人

)》

// 循 环 建立 初始堆 , 调 用 sift 算法Ln/2|次

// 进行 n 一 1 趟 完成 堆 排序 ,每一赵 堆 中 元 素 个 数 减 1
// 将 最后一个元 素 与根 RDI] 交换
//对RU..i

一菇进行筛选,得到 i 一1 个 结 点 的 堆

【例 10.6】 设 待排序的表有 10 个 元 素 ,其关键 字 分 别 为

(6,8,7,9,0,1,3,2,4,5),说

明 采 用 堆 排 序 方法进行排序 的 过 程 。

国 其 初始 状态如图 10. 17(a) 所 示 ,依次从结点0.9.7、8、6 调用 sift 算法 ,构建的初始

堆 如 图 10. 17(b)所示。堆排序过程如图 10. 18 所 示 ,每 归位 一 个 元 素 ( 将 其 交换 到 有 序 区

开头), 就对堆 进行一次 筛选调整 。

人9)

外 一

)

包

OOORG

GOONRG

OO

(a) 初始状态

CC CD

(Cb)建立的初始堆为 :
2345678910

8|7|6|5|1|13|1214|0

1

9

图 10.17 建立初始 堆

384

MOSP内排序 |

(a)9 人 0。

第 1 趟结果 :

(人b) 筛选调整

12345678910
0|8|7|6|5|1|13|2|14|9

()8全0。 第2 趟结

12345678910
0|6|7|4|5|1|3|2|8|9

(d) 禾 选 调整

(e)7扫2。第 3 趟结果 :
123456789%10

(筛选 调整

5必 区

GO OOD

OOOD GO

OO

GO

全6呈0,第4赴结
12345678910
015[3[4[2[1[5[7[8[9

人) 第 选调整 GD5汐1。第 5 趟结果

12345678910
11413|01215161718[9

人 筛选调整

但)

避)
忆) gd D

)

G)
(41 。 第 6 趟结果

12345678910
1 2[3[o[alslal7lsls

(9)

CD) 镍 选调整 (mn) 391.。 第 7 趟结果:

Co) 筛选调整

12345678910
o[2[335slcl7ls[9

Co)

(o)291.。 第 8 趟结果 :
12345678910
1]o12[314151617[s[9

Go)

(p) 蔓 选调整

CD

(q) 1的0。 第 9 趟结果 :
12345678910
o[1T2[3[41516[71s[9

中

(D 得到最终
排序结果

图 10.18 堆 排序过 程

385

数据 结构教程

[第! 5人版

堆 排 序 的时 间 主 要 由 建立 初始堆和 反复 重建堆这 两 部 分 的时 间 构 成,它们 均 是通过 调

用 sift(O)实现的。

对 于 高 度为& 的 完全 二 又 树 / 子 树 ,调用 sift()算法时,其中 while 循环最多执行 人 一 1

次 ,所 以最多 进行 2 一1) 次 关键 字 比 较 ,最 多 进行A十 1 次 元 素 移动,因此 主要 以 关键 字 比

较 来 分 析 时 间人性 能 。

个 结 点 的 完全 二 又 树 的 高度/= log:z 十1。在 建立 初始堆时 ,需要 筛选调整 的层为

1一1一1 层 , 以第;z 层 中 某 个 结 点 为 根 的子树 的 高 度为/一 ;十1, 并 且 第 ;层中最多有 2一个

结点。设 建立初始 堆 所 需要 的 关键 字 比 较次数最多为Ci(z) ,有 :

1

工

Ci >2mX2A 一 iT1I-1 = > 2X(C一D

令 一/一 i 当;1一六 Cn 当;i=1 时 ,一7 一1, 所 以

=- 2 X /一1 一一忆 2 yx
一 2 X1十2 义 2 十... 十2 义

下 一 1

一 2 一 六 一 2一2 < 一4X2om” 一 47

因此 ,建立初始 堆 总 共 进行 的 关键 字比较次数不超过 42z。 类似 地 , 设重建堆中 对 sift()

的 2 一1 次调用 所 需 的 比较 总 次数CCz)。其中守 从寻到 2, 每 次对 忆 [1 一 的 ;一1个结

点 的完全 二 又 树 进行 筛选 调整 ,该树 的 高 度为log*(i一1) 十1, 所以有 :

Ci = >)2X(Clog ii一 1 +1-D=2 log:

ii 一1 二 27mlog2y

这样,堆 排序 所需 的关键 字 比较 的 总 次 数 最 多为 Ci CDOTHCoDp=tHonlogoOCzlogz7)。

一 2

综 上 所 述 , 堆 排序 的 最坏时 间 复 杂 度为OCzlog:z)。堆 排序 的平均 性能 分 析 较 难 , 但实

验 研究 表明 , 它 较 接近 最 坏 性 能 。实际上 , 堆 排序和 简单选择 排序 算法 一 样 ,其时 间 性 能 与 初

始序列的顺序无关, 也 就 是说, 堆 排序算法 的最好 、 最坏和 平均时间 复 杂 度 都是OOxlogzz) 。

由 于 建 初始推所 需 的比较 次 数较多 ,所 以 堆 排 序不 适合 元 素数 较少 的 排序 表 。

推 排序只 使 用 i)tmp 等 辅助 变量,其 辅助空间 复杂 度为OC1)。

另外 ,在 进行 筛选时可 能 把 后 面相同 关键 字 的 元 素 调整 到前 面,所以 堆 排序 算法 是 一 种

不 稳定 的 排序 方法 。

PE

全 振 序 二 全

归并 排序(merge sort) 是 多 次 将两个 或 两 个以上 的有序 表 合并 成 一 个 新 的有序 表 。 最

简单的归并 是 直接 将 两 个有序 的 子 表 合 并 成 一 个有序 的 表 , 即 二 路 归并 。

二 路 归并 排序(2-way merge sort) 的 基本思路 是将 尺 [0..2一1]看成是半 个长度 为

1 的有序 序列 ,然后进行 两两归并 ,得 到 | /2|个 长 度为 2( 最 后 一 个有序 序 列 的 长度可 能

386

MOMS 内排序 |

为 2) 的 有序 序列 ,再 进行 两 两归并 ,得 到 | /4 |]个长度为 4( 最 后 一 个 有 序

序列的长度可能小于 4) 的 有 序序列 ,..., 直 到得 到 一 个 长 度 为冯的有序

序列。

说明: 归并 排序 每 趋产生 的有序 区 只 是 局 部有序 的,也 就 是 说 在 最后 | 和

一 趟排序结束 前所 有 元 素 并 不 一 定归 位了 。

和
视员if册

先 介绍 将 两 个 有序 表 直 接 归并 为 一 个 有序 表 的 算法 Merge()。设 两 个 有序 表 存 放 在 同

二1..high],先将它们合并到一个局部的暂
一 数组 中 相 邻 的 位 置 上 ,即RIlow..mid],REmid

存 数组 R1 中 , 待合并完成后将 尺 1 复制 到尺中。

为了简便,称R[low..mid]为第 1 段,RImid

十1..high]为第 2 段 。每次从 两 个 段中取出

一 个 元 素 进行 关键 字 的比较 ,将 较小 者放和人 R1 中 ,最 后 将 各 段中余下 的部 分 直接 复制 到

R1 中。这样R1 是 一 个 有序 表 , 再 将 其 复制 到

尺 中。对 应 的算法如下 :

void Merge(RecType R[I] ,int low,int mid,int high) 归并 RUlow..highj]

{

RecType *R1;

一mid十1,k一0;
int i 一low,j

/仆是 Rl 的 下 标 ,ij 分 别 为 第 1.2段的下标

R1王(RecType * )malloc((high 一low 十1) * sizeof(RecType));

// 动态分 配 空间

while (i<一mid && j<一highb)

// 在第 1 段和第 2 段 均 未扫描完时循环

让 (RD 口 .key<一RD] .key)

// 将 第 1 段中的 元 素放和人 R1 中

RIU 一 RD

计十;k十十;

(1

】}

else

, RIU=RD],

j十 十ik+ 十 ;

(1

】}

while (i<一mid)

{ RII=RD,

计十;k 十 十;

}

while (j <一high)

_ RI[I=RD,

j 十十;十十;

{

}

// 将 第 2 段中的 元 素放和人 R1 中

// 将 第 1 段余下 的 部 分 复制 到 R1

// 将第 2 段余下 的 部 分

复制到 R1

for (k 一 0,i 一 low;i<一high;k十十,i 十十)

//将R1 复制到R[low..high] 中

RU 一 Rl[k] ;

freeCR1) ;

)》

aa

Merge() 实现了 一 次 归并 ,其 中 使用的 辅助空间正好 是 要 归并 的元 素 个 数。接 下 来 需

利用 Merge()

最后一个子表
解决一赵归并问题。在 某 趟 归并 中 , 设 各 子 表 的 长 度为length(

的 长 度 可能小于 length) , 则 归并前R[o..x 一 中共 | 记 守|个有序 的子表 ,

387

数据 结构教程

[第! 5 【版

及Lo0..length 一 1j,RLlength..2length 一 1],......:尺 |

玫

length

| X length..7 一 1

在 调用 Merge() 将 相 邻 的 一对子 表 进行 归并 时 ,必须对 表 的 个 数可 能 是 奇数以 及 最 后

一 个 子 表 的 长 度小于 length 这 两 种特殊情况 进行特殊 处 理 : 若 子 表 的 个 数 为 奇数,则最后

一 个子表 无须和 其 他 子 表 归并 ( 即 本 趟 轮空); 若 子 表 的 个 数 为 偶数 , 则 要注意 到 最 后一对

子 表 中 后 一 个子表 的 区间 上 界是"一1。一 趟 归并 的 算法如 下 :

void MergePass(RecType RD ,int length,int n)

//对整个排序 序列 进行一趟 归并

{

inti;

for (ij一0;i十2 * length一 1<n;i一i十 2* length) ,// 归 并 length 长 的 两相邻子表

Merge(CR,i,i 十 length一1,i十 2* length一 1);

这 (Ci 十 length一 1<n 一 1)

Merge(R,i,i 十length 一1,n一1);

// 余 下 两 个子表 , 后 者 的 长 度小 于 length
// 归 并 这 两 个子表

}

在 进行 二 路 归并 排序时 ,第 1 趟 归并 排序 对 应 length=1,第 2 趟 归并 排序 对 应 length一

2,...,

依此类推,每一次 length 增 大 两 倍,但 length 总 是小于 2 所以 总 趟 数为|logsz| 。 对

应 的 二 路 归并 排序 算法 如 下 :

void MergeSort(RecType RT] ,int n)

// 二 路归并排序

int length;

for (length王1;length< ni;length一2 * length)

// 进行[logzz]趟 归并

MergePass(R,length,n) ;

{

)}

视频 讲解

上 述 二 路 归并 排序 实际 上采用的是自底 向 上 的 过 程,也 可以 采用 自 顶 向 下 的 递归过 程 ,

其 算法 如 下 ,这 里 不 再 详细 介绍 。

进行二路归并排序
void MergeSortDC(RecType RD] ,int low,int high) //对RUlow..high]

{

int mid;

这 (low<high)

{

mid一(low十high)/2;

MergeSortDCCR,low,mid) ;

MergeSortDC(CR, mid十1,high) ;

Merge(R,low,mid,high) ;

}

)}

void MergeSortl(RecType RD ,int n)

// 自 顶 向 下 的 二 路 归并 算法

{

)}

MergeSortDCCR,0,n 一 1);

【例10.7】 设 待排序的表有 10 个元 素 ,其 关键 字 分 别 为 (6,8,7,9,0,1,3,2,4,5),说

明 采 用 二 路 归并 排序 方法 进行 排序 的 过 程 。

在 采用 二 路 归并 排序时 需要 进行 [log:z | 一4 趟 归并 排序 ,其排序 过 程如图 10. 19

388

ix&r |国可 园 品 园 回国回 国攻

一 一 二 一 一 一三

> 一 一

第1超结果, 可

FF

[引[ 可

[一
[可 园 国 回回 回忆

一

1
1
1
1
1
1
1
1

1
1
1
1
1
1
1
1
1

1
第?赵结果: 1[

F
引 [可 ] 可

二
F

归
可 园 回 回回 回回 一 #

第 3 趟结果:

第 4 趟结果:

1一 一一 1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

图 10. 19 二 路 归并 排序过 程

了 和算 六人析

对 于 长 度 为 的 排序表 , 二 路 归并 需要 进行|log:”|]趟 ,每 趟 归并 时间为OCz) ,故其时

间 复 杂 度 无 论是在最好 还 是在最 坏 情况下 均是 O(zlogsz) ,显然平均 时间 复 杂 度 也 是

O(Czlogz7z)。

在 二 路 归并 排序过程中 ,每次二 路 归并 都需要 使用一 个 辅助数组 来哲存 两 个有序 子 表

归并 的 结果 ,而 每次二 路 归并 后 都 会释放 其 空间 ,但 最 后 一 赵 需 要 所 有 元 素 参与归并 ,所 以

总 的 辅助 空间 复杂 度为OCz)。

在 一 次 二 路归并中,如 果 第 1 段元素 尺 [英和第 2 段元素 尽 [ 门的关键 字 相 同 , 总 是 将

尺 [ 可 放 在 前 面.RI 让 放 在 后 面 ,相对 次 序 不 会 发生 改变, 所 以 二 路 并 归并 排序 是一种 稳定 的

排序 算法 。

归并 排序可以是多 路 的 ,如 三 路 归并 排序 等

。以 三 路 归并 排序 为例, 归 并 的 趟 数 是

[logs>” |, 每一趟 的 时间为O(z) ,对 应 的执行时间为O(Czlogsz) ,但 logsm一logsz/log:3,

所以时 间 复 杂 度 仍为OCzlogzz) ,不 过 三 路 归并 排序 算法 的 实现 远 比 二 路 归并 排序 算

基数 排序

洒

和 站 序 ee

前 面 所讨论 的 排序 算法 均 是 基于 关键 字 之间 的比较来实现的,而 基数 排序(radix sort)

是 通过 “分 配?和 ”收集 过程 来实现 排序,不 需要 进行 关键 字间 的 比较,是 一 种借助于多 关键

字 排 序的思想对 单 关 键 字 排序 的 方法 。

一 般 情 况 下 ,元 素 R[ 英 的 关键字 Ri让]. key 由 d 位 数字 (或 字符 ) 组 成 ,即 ee-1Re2

忆如 ,每 一个数字 表示 关键 字 的 一 位,其 中 台 为 最 高 位 如 是 最 低位 ,每一位 的 值 都在 0 所

Ai<r 范 围内,其中> 称为基数(radix)。 例如,对于二进制数 ~ 为2,对 于 十 进 制数~ 为 10。

389

数据 结构 教程

眶 第人5 人版

基数 排序 有 两 种 , 即 最 低位 优先 (least significant digit first,LSD) 和 最 高 位 优先(most

significant digit first,MSD) ,其 原理 是 相同的,后 面 主要 讨论 前者。

最 低位 优先的过 程是先 按 最低位 的 值对 元 素 进行 排序 ,在 此 基础 上 再 按 次 低位 进行 排

序 , 依 此 类 推 。由 低位 向 高位,每 趟 都是根据 关键 字 的 一 位 并 在 前 一 趟 的 基础上 对 所 有 元 素

进行排序 ,直至最高 位 , 则 完成了基数排序的整个过程。

在 对 一 个 数据 序列 排序时 是 采用 最 低位优先还是 最 高 位优先 排序 方法是由 数据 序列 的

丑 点确定的。例如 对 整数 序列递增 排序 ,由 于 个 位 数 的重要 性 低于 十位 数 , 十 位 数 的 重要性

低 于百 位 数 ,一 般 越重要 的 位 越 放 在 后 面排序 ,个位数属于 最 低位,所以 对 整数 序列递增 排

序 时 应 该 采用 最低位 优先 排序 方法 。

以 为 基数 的 最 低位 优先排序的过 程 是 假设线性 表 由 元 素 序列 co ,al,...'a,-i 构成,每

个 元 素 w 的关键字为d 元组:

2

其中 0 过 包 受 r 一1(00 二) 二 00 过 ji委 d 一1)。 在排序过程中使用-个 队列 Qu,Q,...,Q-:。

排序过程如下,

对 主 0,1,......d

一 1, 依 次 做一次“分 配 ?和 “收集”( 其 实 就 是 一次稳定 的排序 过 程 ) 。

分配: 开始时,把 Qu,Q,...',Q,.-:

各 个 队列 置 成空队列 ,然后依次 考查 线性 表 中 的 每 一

个元素wG=0,1,...,2

一1) ,如果元素 w 的 关键 字 外 一A, 就 把元 素 w 插入到Qu 队列中。

收集: 将 Qu,Qi ,...',Q.-: 各 个 队列 中 的 元 素 依 次 首尾 相 接 ,得 到 新 的元 素 序列,从 而 组

在 4 趟 执行后数据序列 就 有 序 了 。

说明: 基数 排序每赵 并 不 产生有 序 区 ,也 就是说 在 最 后 一 趟 排序结束 前所 有 元 素 并 不

一定归位了 。

2 放任关

在 基数 排序 中 每 个元 素 多 次 进出 队列 ,如 果 采 用 顺序 表 存 储 , 需要有 大 量 元 素 的 移动 ,

而 采用 链 式 存储结构时 ,只 需要 修改相关 指针 域 。所以 这 里 将 排序 序列 采用链 式存储结构

假设 待 排序 的 数据 序列存放 在以

为 首结 点指针 的 单链 表 中 ,其 中 结 点 类 型

NodeType 的声明如下 :

typedef struct node

{

char dataLMAXD] ;

//MAXD 为最大 的 关键 字 位 数

Struct node x nexti

// 指 向 下 一 个 结 点

} NodeType;

// 基 数 排序 数据的结 点 类 型

视频讲解

依次存放关键字的低位到
其中,data 域存放 关键 字 , 它 是一个 字符 数组 ,data[0..MAXD-1]

高位 的 各 数字 字符 ,关键 字 的 实际 位数由 参数 d 指定。

以 下 基数 排序 算法 radix_sord(p,r,d)实现LSD 方法 ,其中参数 如 为存储 的 待排序序

列 的 单链表 的指针 ,> 为 基数 ,d 为关键字位数。

390

MOMS 内排序 |

void RadixSort(NodeType * &p,int r,int d)

//LSD 基数 排序 算法

{

NodeType * headLMAXR], * tailLMAXR], *t; // 定 义 各 链 队 的 首尾 指针

int ij,k;

for (i一0;i< 一d一 1;i 十十)

{

for G=0;j<rij十十)

head[] =tail中=NULL;

// 从 低位 到 高 位循环

// 初 始化各 链 队 的 首 、 尾 指针

while (p!I=NULL)

// 分 配 : 对 于 原 链 表 中 的 每个结 点循环

{

kk一p 一 data[口一'0';

// 找第 个 链 队

问==NULL)
这 (head[

//第k 个 链 队 空时, 队 头.队 尾 均 指向 结 点 p

{

head[ 回 一pitail[ 辐一p;}

else

//第上 个 链 队非 空时结点 p 进 队

{

tail[回-> next一pitail[ 国一pb;

)》

p一p 一 next;

// 取 下 一 个 待排序 的 元 素

)》

p=NULL;

// 重 新 用 p 来收集所有结点

for (一0;j<r;j十十)

// 收 集 : 对 于 每一个 链 队 循环

i (headD中 !王NULL)

// 若 第 j 个链队 是 第 一 个非 空链队

{

这 (p==NULL)

{

,p=head[D];t=tailD;)

else

// 若 第 j 个 链 队 是 其 他非空链 队

{

t->next=head[] ;it=tailD;

》

)》

t 一> next王NULL;

// 最 后 一 个 结 点的 next 域置NULL

)》

【例10.8〗 设 待排序的表有 10 个 元 素 , 其 关键 字 分 别 为 (75,23,98,44,57,12,29,64,

38,82) ,说 明 采 用 基数 排序 方法 进行排序的过 程 。

这里 "一10,d 王 2,r 一10, 先 按个位 数 进行排序,再 按 十位数 进行 排序 ,排序 过 程如

图 10. 20 所示 。

在 基数 排序 过 程 中 为 什么不需要 关键 字 比 较 就能

够判断 关键 字 的 大 小呢? 实际 上 是 从

两 个 方面 来确定 关键 字 的 大小的,一 是 选择最 低位 优先还是 最 高 位 优先,这 样 就 确定了 关键

字 各位 的重要性; 另外 ,在对 每一位 排序 中 收集 时 是 按 Qu ,Qi ,...',Q.-; 的 顺序进行的,这就

说明有 0 二 1 二 ... 反 (Cr 一1) 的 大小 关系 。

了 算 关 作 术

在 基数排序 过 程 中 共 进 行了 x 趟 的 分配和 收集。每一趟 中 分 配 过 程需要 扫描所有 结

aa

点 ,而收集 过 程是按 队 列 进行 的,所以 一 趟 的 执行 时 间 为 O(z十 >), 因 此 基数 排序 的 时间 复

杂 度 为OC&Cz十~) ) 。

在 基数 排序 中 第 一 趟 排序 需要 的 辅助存储 空间 为 ~( 创建> 个队列),但以后的 各 趟 排

序 中 重复 使用这 些 队 列,所以 总 的 辅助空间 复杂 度为OCr) 。

另外 ,在 基数 排序 中 使用的是队列 , 排 在后面 的元 素 只 能 排 在 前 面相同 关键 字 元 素 的 后

面,'相 对位 置 不 会 发生改 变 , 它 是 一种稳定 的 排序 方法 。

391

数据 结构 教程

9@

也 一一 75

23

一| 98

呈 44

一 5S7

12

一| 29

一 64

一 38

于 82 | 人

(a) 初始状态

链队头指和

head[0]

”head[1]

head[2]

head[3]

“head[4

head[5

head[6]

head[7]

”head[8]

”head[9

12
1

82
入
下

23
人

44
|

64
人
下

75
人

57
人
下

98
|

38.
人

29
人

tail[0]

tail[1]

tail[2

tail[3

tail[4

tail[5]

tail[6]

tail[7]

tail[8]

tail[9]

链队尾指和

(b) 按 个位 分 配 之 后

卫 一一| 12

82

一| 23

一 44

一| 64

75

| 57

一 98

一 38

一 29 | 人

链队头指和

(9) 按 个位收集之后

head[0,

head[1

head[2]

”head[3

head[4-

head[5

head[6

head[7]

”head[8

head[9-

12
人

23
|
下
29

38
人
下

44

57

64

75

82

98

tail[0]

tail[1]

tail[2.

tail[3]

tail[4]

tail[5]

tail[6]

tail[7]

tail[8]

tail[9]

链队尾 指针

(d) 按 十 位 分 配 之 后

P一“12| -23| -| 29

中 38

叫 44| 一 下 57| 一| 64

一| 75 呈82 | 一呈 98 | 人

(e) 按 十位收集之后

10. 20 ”基数排序 过 程

各 种 内排序 方法 的比较 和 选择 兴

本 章 介绍 了 多 种 内 排序 方法 ,将 这 些 排序 方法 总 结 为如表 10. 1 所示。通 常 可 按平均时

间 将 排序方法 分 为 下面 3 类 。

(1) 平方阶OC2)排序: 一 般 称 为 简单 排序 方法,例如 直接 搬入 排序、 简 单选择排序和

392

MOMS 内排序 |

冒泡排序。

(2) 线性对数阶OCzlog:z)排序: 如 快速排序 . 堆 排序和 归并 排序 。

(3) 线性阶 OCz) 排序:

如 基数 排序(假定数据的位数 & 和进制 ~ 为 常量时 ) 。

表 10.1 各 种 排序 方法的 性 能

排序 方法

平均 情况

于 问 复杂 度
最坏情况

空间
最 好 情况| 复杂度

稳定 性 复杂性

直接 插入 排序 | OG2)
折 半 插入 排序 “| OCz2)

希 尔 排序

冒 泡排序
快速 排序

OCm3)

OC2)
OCnalog:z)

OC2 )
OC2)

OC2 )
OO)

简单选择排序
堆 排 序

| OCz)

OCalogz7)

OO2 )
OCzlog:z)

OCD)
OOCD)

OOD)
OCalogz7D)

OO )
OCalogz7z)

二 路 归并 排序

OCalogz7)

OCzlogz7)

OCalogz7)

OGD)
OG1)

OG)

稳定
稳定

简单
简单

不 稳定 较复杂

OG)
O(log:z) | 不 稳定

稳定

简单
较 复杂

OGD)
O(C1)

OCD)

不 稳定
不 稳定 较复杂

简单

稳定 较复杂

基数 排序

OCdC十D) | OCdCz十D) | 0OCdoz十D) | 0 稳定 较复杂

在内排序 算法 中,一类是稳定的, 另一类 是 不 稳定 的 。下 面通过一个示

例 说 明 在 什么情况 下 需要 考虑 算法 的 稳定 性 。

【例10.9】 设 线性 表 中 每个元素有 两 个 数据 项 证 和心 , 现 对线性表按

以 下 规则进行排序: 先看数据项所 ,书 值小 的 在 前 ,大 的 在后; 在局 值相同 和

的情况下再看包 ,A 值 小 的 在 前 ,大 的 在 后。满足这 种 要 求 的 排序 方法 是 :

视频讲角

(1) 先按 局 值 进行直接 插入 排序,再 按 包 值 进行 简单 选择 排序 。

(2) 先按 忆 值 进行直接 插入 排序,再 按 所 值 进 行 简单选择 排序 。

(3) 先按 已

值 进行 简单选择排序,再 按 久 2

值 进行直 接插入 排序 。

(4) 先按 避 值 进 行 简单选择排序,再 按 所 值 进行直 接插入 排序 。

这 里 是 按 两个关键 字 排序 , 越 重要 的 关键 字 越 在 后 面排序,所以 应 先 按 名 值 排序 再

按 户 值排序。在 简单选择排序和 直接 插入 排序中 前 者 是不稳定 的 ,后 者是稳定 的 。当 先 按

As 值 进行 直接插入 排序,再 按 包 值 进行 简单 选择 排序时 ,由 于 简单选择 排序 的 不稳定 性 ,可

能 会 造成 书 值相同而A 值 大 的 元 素 排 在 前 面,这 不 符合 要 求,所以 应 该 先按 As 值 进行 简

单选择排序,再按 局 值 进行 直接 插入 排序,答案 是(4) 。

正 是 因为不同 的 排序 方法 适应不同 的 应用 环境和 要 求,所以 选择合适 的 排序 方法 应 综

合考虑下列因素:

(1) 待排序 的 元 素数 目 z(问题规模 ) 。
(2) 元 素 的 大小 (每 个元素 的规模 ) 。

(3) 关键 字 的 结构 及 其 初始状态 。

(4) 对稳定性的要求。

(5) 语言工具的条件。

(6) 数据的存储结构 。

(7) 时 间 和 空间 复杂 度 等 。

没有 哪一种 排序 方法 是绝对 好 的。每 一 种 排序 方法 都有其 优 缺 点 ,适合 于 不 同的环境 ,

393

Ta

数据 结构 教程

虹 第人5 【版

因此 在 实际应用 中 应 根据 具体 情况 做 选择。首 先考虑排序对 稳定 性 的 要 求 , 若 要 求 稳 定 , 则

只 能 在 稳定 方法中选取 ,否则 可以 在所有 方法 中选取 ; 其 次 要 考虑 待 排序 元 素 个数”的大

小,若 较 大 , 则 可 在 改进 方法中选取 ,否则 在 简单 方法 中选取 ; 然后 再 考虑 其 他 因素。下

面 给 出综合考虑 了以 上 几 个方面所得 出 的 大 致结论:

(1) 若 闻 较小(如 大 50) ,可 采用 直接 插入 或 简单 选择排序。一 般 地 ,这 两 种 排序 方法

中 ,直接 搬入 排序较好 ,但 简单选择 排序 移动的元素数少于 直接 搬入 排序 。

(2) 若 文件 初始 状态基本 有 序 ( 指 正 序), 则 选用 直接 搬入 或冒泡 排序为 宜 。

(3) 若 较 大 ,应 采用 时间 复 杂 度为 O(0xlogsz) 的 排序 方法 ,例如 快速排序 、 堆 排序 或 二

路 归并 排序。快 速排序 是 目前 基于 比较 的 内 排序中 被 认为是较 好 的 方法, 当 待排序 的 关键

字 是 随机 分 布时 ,快速排序 的 平均时 间 最少; 但 堆 排序所 需 的 辅助 空间少 于 快速排序,并 且

不 会出现 快速 排序可 能 出 现 的 最 坏 情况。这 两 种 排序 都 是不稳定 的 , 若 要求 排 序 稳定 , 则 可

选用二路归并排序。

(4) 若需要 将 两 个有序 表 合 并 成 一 个 新 的有序 表 , 最 好 用 二 路 归并 排序 方法 。

(5) 基数 排序 可 能在 OCz) 时间 内 完成 对 个 元 素 的排序 。但 遗憾 的 是,基数 排序只 适

用 于 像 字符串和 整数 这 类 有 明显 结构 特征 的 关键 字 , 而 当 关 键 字 的 取 值 范围 属于某个无穷

集合 (例如 实数 型 关键 字 ) 时 无 法 使用基数 排序,这时 只 有 借助于"比较 ”的 方法 来排序。由

此 可 知 , 若 盖很大,元 素 的 关键 字 位 数 较少且 可以 分解时 采用 基数 排序较好 。

一 本章小结 一一一

本 章 的 基本 学 习 要 点 如 下 :

(1) 理解排序的基本概念,包括 排序 的稳定性 ,内 排序和外排序 之 间 的

(2) 掌握 插入 排序 算法 ,包括 直接 插入 排序 、折 半插 入 排序 和 希 尔 排序

的 过 程 和 算法 实现 。

(3) 掌握 交换排序 算法 ,包括 冒 泡 排序 和 快速 排序的过 程 和 算法 实现 。

(4) 掌握 选择 排序 算法 ,包括 直接 选择 排序 和 堆 排序 的 过 程和 算法 实现 。

(5) 掌握二路归并 排序 的 过 程和 算法 实现 。

(6) 掌握 基数 排序 的 过 程和 算法 实现 。

(7) 掌握各种排序 方法 的比较 和 选择 。

(8) 灵活地运用 各 种 排序 算法 解决 一 些综合应用问题 。

要-要

视频讲解

一人 练习题 10 一 一

1. 直接 插入 排序 算法 在 含有 ?7 个 元 素 的 初始数据 正 序、反序和 数据 全 部 相等 时时间 复

杂 度 各 是 多 少 ?

2. 回答以 下 关于 直接 插 和 人 排序和折 半 插入 排序的 问题 ;

(1) 使用 折 半 插入 排序所 要 进行的关键 字 比 较 次 数是否 与 待排序 的 元 素 的 初始状态

有 关 ?

394

(2) 在 一 些特殊情况 下 , 折 半 插 和 排序比直接 插入 排序 要 执行更多 的 关键 字比较,这句

MOSP内排序 |

话 对 吗 ?

3. 有 以 下 关于 排序 的 算法 :

void fun(int a[] ,int n)

{

intij,d,tmp;

d一n/3;

while (true)

{

for(i=dii<nii十十)

{ tmp一aD;

j 一 i 一 d;

while 0j >=0 && tmp<a[])

, a0+吕=aD];

j 一 j 一 d;

{

】}

a0D十四一tmp;

】}

让 (d=一一1) break;

elsei过(d<3) d 一 1;

else d一d/3;

)}

算法的功能。
(1) 指出 fun(Ca,z)

(2) 当 a[]={15,1.3,6,2.7,4,8}时,问 fun(Ca,8)

共执行几趟排序? 各 趟 的排序结果是

什么?

4. 在 实现 快速排序 的非递归 算法时 ,可 根据 基准元 素 将 待排序 序列 划分 为 两 个 子序

列。若 下 一 趟 首先对较 短的子 序列 进行排序 , 试证明在此 做法下 快速排序 所 需要 的 栈 的 深

度为O(log:m)。

5. 将 快速 排序 算法 改 为非递归 算法时 通常 使用一 个栈, 若把栈 换为队列 会对最 终 排序

结果有什么影响?

6. 在 堆 排 序.快 速排 序和 二 路 归并 排序 中 ,

(1) 若只从 存储空间 考虑 ,应首先选取 哪 种 排序 方法,其 次 选取哪 种 排序 方法,最后选

取 哪 种排序方法?

(2) 若只从 排序 结果 的 稳定 性考虑 , 则 应 选取 哪 种 排序 方法?

(3) 若只从 最 坏情况 下 的 排序时 间 考 虑 , 则 不 应选取 哪 种排序 方法?
7. 如果只 想 在 一 个 有 并 个 元 素 的任意 序列 中得 到 其 中 最 小 的第上 (< 二 2) 个 元 素 之 前

an

的 部 分 排序 序列 ,那么最好 采用 什么 排序 方法? 为 什么?例如有 一 个 序列 (57,40,38,11,

要得到其第 4 个元素(4一4)之前的部分有序序列,用所选择的算
13,34,48,75,6,19,9,7),

法 实现时 ,要 执行多少 次比较 ?

8. 在 基数 排序 过 程中用 队列 暂 存 排序 的元 素 ,是 否可以 用 栈 来 代替 队列 ? 为 什么?

9. 线性表有 顺序 表 和 链表 两种存储 方式,不 同 的 排序 方法适合不同的存储结构。对于

常见的内 部 排序 方法,说 明 哪些更 适合于 顺序 表 ? 哪些更适合于链表? 哪些两者都适合?

数据 结构教程

[第! 5版

10. 设 一 个整数数组 a[0..x 一 中 存有互 不相同 的 个 整数,上且 每个元 素 的 值 均在1一

元 之间。设 计 一 个算法在OCz)时间内将 a 中 的 元 素 递增 排序,将 排序结果 放 在 另一个 同样

大小的数组 2 中。

11. 设计一个双向 冒 泡排序的算法 ,即 在排序过程中 交 革 改变 扫 描 方向 。

12. 假设有 ?个

关键 字 不 同 的记录 存 于 顺序 表 中 ,要 求 不 经 过 整体 排序从中 选 出 从 大

到小顺序的前 mm<<72)个元素。试采用 简单选择 排序 算法 实现 此 选择过 程 。

13. 对 于 给 定 的 含有 ?个

元 素 的 无 序数 据 序列 (所有 元 素 的 关键 字 不 相同), 利 用 快速

排序 方法求这 个 序列 中 第 AGI 和 4A委 思 小 元 素 的 关键 字 ,并 分 析 所 设计 算法 的 最好和 平均 时

间复杂度 。

14. 设 个 记录 尽 [0..z 一 菇 的 关键 字 只 取 3 个值 ,即 0.1、.2, 采 用 基数 排序方法 将 这 ?

个 记录 排序,并 用 相关 数据 进行 测试 。

一 >- 上 机 实验题 10 一

从 验 证性实验

实验题 1, 实现直接 插入 排序算法

目的: 领会直接 插入 排序的 过 程和算法 设计 。

内 容 , 编写一个 程序 expl10-1. cpp 实现 直接 插入 排序算法 ,用 相关 数据进行测试 并

世

出 各 趟 的排序 结果 。

实验题2: 实现折 半 插入 排序算法

目的: 领会折 半 插入 排序 的 过程和 算法 设计 。

内 容: 编写一个程序exp10-2. cpp 实现 折 半 搬入 排序 算法 ,用 相关 数据 进行 测试并 输

出 各 直 的 排序 结果 。

实验题3: 实现希尔排序算法

日 的: 领会硕尔 排序的过 程和算法 设计 。

内 容: 编写一个程序exp10-3. cpp 实现 硕 尔 排序 算法 ,用 相关 数据 进行 测试并 输出 各

趟 的排序结果 。

实验题4: 实现冒泡排序算法

日 的: 领会冒泡 排序的过 程和算法 设计 。

内 容: 编写一个程序exp10-4. cpp 实现冒泡 排 序 算 法 ,用 相关 数据 进行 测试并 输出 各

PE

趟 的排序结果 。

实验题5: 实现 快速排序 算法

日 的: 领会 快速 排序的过 程和算法 设计 。

内 容: 编写一个程序exp10-5. cpp 实现 快速排序 算法 ,用 相关 数据 进行 测试并 输出 各

次划分后的结果。

实验题6: 实现 简单选择排序算法

日 的: 领会简单 选择 排序 的 过 程和算法 设计 。

396

MO 内排序 |

内 容: 编写一个程序exp10-6. cpp 实现 简单选择 排序 算法 ,用 相关 数据 进行 测试 并

输

出 各 直 的排序结果

实验题7: 实现堆排序算法

日 的: 领会堆排序的过程和 算法 设计 。

内 容: 编写一个程序exp10-7. cpp 实现 堆 排序 算法 ,用 相关 数据 进行 测试并输出 各 趟

的 排序结果 。

实验题8: 实现 二 路归并 排序算法

目的: 领会二路 归并 的 过 程和算法 设计 。

内 容: 编写一个程序exp10-8. cpp 实现 二 路 归并 排序 算法 ,用 相关 数据 进行 测试 并

世

出 各 直 的排序结果

实验题9: 实现 基数 排序 算法

目的: 领会基数 排序 的 过 程和算法 设计 。

内 容: 编写一个程序exp10-9. cpp 实现 基数 排序 算法,用 相关 数据 进行 测试并 输出 各

趟 的排序结果。

民设计 性 实验

实验题10: 实现可 变 长度的 字符串序 列快速 排序算法

目的: 掌握 快速 排序 算法 及 其应 用 。

内容: 某 个待排序的 序列 是 一 个可 变 长度的字符串序列,这 些字符串一

储 于 单个 字符 数组 中 ,采用 快速排序 方法对 这 个 字符 串 序列进行排序人有

一 个 地 存

据 进行 排序 的 程序exp10-10. cpp:

char S 口 一{"whileifif 一 elsedo一whileforcase"} ;

struct node

{

int start;

// 该字符串在 S 中 的起始 位置

int length;

// 该字符串的长度

}》 AD 一 {{0,5},{5,2},{7,7},{14,8},{22,3},{25,4})3

实验题11: 实现 英文 单词按字典 序 排列的基数 排序 算法

目的: 掌握 基数 排序 算法 及 其应 用 。

内容: 编写一个 程序exp10-11. cpp, 采 用 基数 排序 方法将一 组 英文 单词按 字 典 序 排列 。

假设 单词均由小写字 母 或 空格构成,最 长 的 单词有 MaxLen 个 字母,用 相关 数据进行 测试 并
输出 各 直 的排序 结果 。

必 _

谷 综 合性实验

实验题12: 实现学生 信息 的 多 关键 字 排 序

目的: 掌握 基数 排序 算法 设计 及 其 应 用 。

内容: 假设 有很 多学生记录 ,每 个 学生 记 录 包 含姓名 、 性别 和 班 号,设计 一 个 算法 按 班

号.性别有序输出 ,即先按 班 号输出,同一 个 班 的 学 生 按 性 别输出 , 班 号为1001一1030。 编

写一个程序 exp10-12. cpp 实现上述功能。

397

数据 结构教程

[第5 【版

实验题13:

求 各 种 排序算法 的绝对 执行 时 间

目的: 掌握 各 种 内 排序 算法 设计 及 其 比较 。

内容: 编写一个程序exp10-13. cpp,随机产生 7 个 1一99 的 正 整 数 序列,分别采用直接

插入 排序、.折 半 搬 和 排序、 希 尔 排序.骨 泡 排序.快速 排序 简单 选择 排序 、 堆排序和 二 路 归并

排序 算法 对 其 递增 排序, 求 出每种 排序 方法所 需要 的 绝对时间 。

398

第 10 章 介 绍的内排序都 是 在内存 中 进行 的, 如 果 参 与排序的

数据

量 特别大, 存放 在外存 文件中 , 一次 不 能 全 部读入 内 存 ,

用 内 排

序 方法 就 不 能 完成对 数据 的 整体 排序 。 为此采用分段处理, 每 次将

文件中 一 部 分 数据 调 到 内 存 中 进行排序, 这样 在 排序过 程中 需要 进

行多次的内、外 存 之间 的 数据 交换 , 称 这 种 排序 为 外 排序 。

本章介绍外排序的基本算法, 包括 磁盘 排序 和 磁带 排序。

数据 结构教程

[第! 5版

文件 存储 在 外 存上 ,因此 外 排序 方法与各 种 外 存 设备 的 特征有关 , 外 存 设备 大体上 可 以

分 为两类 ,一 类 是 顺序 存 取 设 备 , 例 如 磁带 , 另一类 是 直接 存 取 设备 ,例如 磁盘 。

磁带 (tape) 出 现在 20 世纪 50 年代 早期,是 一种典型的顺序存取设备,

它 是 通过读 写头 读 写 数据 的。磁 带 对 于 检索 和 修改 操作 都 很不方便 ,其 主

要 用 于 处 理 很 少需要 修改的并 且 进行 顺序 存 取 的 信息 ,特别用作 备 份数据

的 设备 。

磁盘 是 一种直接 存 取 的 外 存 设备 , 它不仅 能 够进行 顺序存取 , 而 且 能 直

接 存 取任何 记录 , 它 的存取 速度比 磁带 快 得 多。磁 盘 分 为硬盘 和 软盘 两 种 ,

硬盘 的 容量 比 软盘大 得 多 ,而 且 存 取 速度也 比 软盘 快得多 。

目前 磁盘 多 使 用带有 可 移动式的 磁头,图 11.1 所 示

为 磁盘 结构 示意 图,从 中 可 以 看 到 ,整个磁盘 由 多 个 盘 片

组 成,固定 在 同一轴 上 沿 一 个 固定 方向 高 速 旋转,每个盘

片包括 上 、 下 两个盘面 ,每个盘面用于 存储 信息 ,每个盘

面有一 个 读 写 头 ,所有 读 写 头是固定 在 一 起同时 同步 移

动的。在 一 个 盘面上 读 写 头的轨迹 称为磁道,磁道 就是

磁面上 的 圆 环。各 个 磁面上 半径 相同 的 磁道总 和 称 为 一

个 柱 面 。在 一 个 磁道内又 分 为 若干 个 扇面 。一 般 情况

图 11.1 磁盘 结构示意 图

下 ,把 一次向 磁盘写和 或 读 出的数据称为 一个物理块, 一

个 物理 块 通常由若干 个记录 组 成 。

对 于 磁盘 而 言 ,影响存取 时 间 的 因素 有 3 个 ,即 搜索时 间 ( 磁 头 定位 到 指定 柱 面所需要

的 时 间 )、 等待时 间 ( 磁 头 定位 到 磁道 的 指定 扇区所 需要 的 时间 ) 和 传送 时间 ( 从 磁盘 或向磁

盘 传 送一个 物理 块的数据 所 需要 的时间 ) 。

外 排序 的 基本 方法 是 归并 排序 法 , 它 分 为 以下两 个步骤 。

(1) 生成 若干 初始归并 段 ( 顺 串 ): 将 一 个 文件 ( 含 待排序 的 数据)中 的 数据 分 段 读和人内

存 , 在 内 存中对 其 进行 内 排序,并 将 经 过 排序的 数据 段(有 序 段)写 到 多 个 外 存 文件上 。

(2) 多 路归并: 对 这 些 初始归并 段 进行多遍 归并 ,使得有 序 的 归并 段逐渐 扩大 ,最 后 在

外 存 上 形成整个 文件 的 单一归并 段 ,也 就 完成了这 个 文件的 外 排序 。

从 中 可 以 看出,外 排序的时间 主 要 花费 在 内 、 外 存 数 据 的 交换 (对 应存取时 间 ) 和 内 排序上 。

磁 盘 排序

洒

11.21 磁盘 排序 概述

对 存放 在 磁盘 中 的 文件进行排序属于 典型 的 外 排序 , 称 为 磁盘 排序(disk sort) 。 由 于

MA 外排序 |

磁盘 是 直接 存 取 设 备 , 读 写 一个数据 块的时间 与 当前 读 写头所 处 的 位置关 系不大 ,所以可 以

通过 读 写 数据 块 的次数 来 衡量存取 时间 。

图 11. 2 所 示 为 基本 的 磁盘 排序 过程 ,磁盘 中 的 Fi 文件 包括 待 排序 的 数据 ,通过 相关 算

法将 Fi 文件中的记录 一 部 分 一 部分地调和人内 存处理 , 产 生 若干个文件 已 一己 ,它们都是有

序的 , 称 为 顺串(runs)。然后再次将 媚 一已, 文件中 的记录 调 人 内 存 ,通过 相关 归并 算法 产

生 一 个 有 序 文件Fe ,从 而 达到 数据 排序的目的 。

文件

写

该

局 文作 上 Lp 二 及让得-

|

记 文作

生成 若干 初始归并段

归并成一个有序文 件

图 11.

2 ”基本的磁盘排序过程

下 面通过 一 个 例子 来说明 磁盘 排序 过 程 。 设 有 一 个 文件 Fi ,内含4500 个 记录,即Ri ,

及 ,...,Riso ,现在 要 对 该 文件进行排序 ,但 内 存 空 间最多 只 能 对 z=750 个记录 进行 排序 ,

并 假设 磁盘 每次读 写 单位为250 个记录的数据块 ( 即 一 个物理块,对应 250 个逻辑记录 ,也

称 为 页 块) ,其 排序 过 程如下 。

(1) 生成初始归并段: 每次读 3 个数据块(750 个 记录 ) 进 行内 排序(由 于 这 些 数据 全 部

在 内 存 中 ,可以采用第 10 章 介绍 的 内 排序 方法) ,整个 文件 得 到 6 个 归并段 一Fe(即初始

归并段) ,把这 6 个 归并 段存放 到 磁盘 上 。

(2) 二路归并: 将 内 存 工作区 分 为 3 块,每块可容纳 250 个记录 ,把其中 两 块作为输入

缓冲 区 , 另 一 块作为 输出 缓冲区 。

先对归并段 玉

和 已 进行 归并 ,为 此 可 把 这 两个归并 段 中 每 一个归并 段的第 一 个 物理

块(250 个 记录 ) 读入输入 缓冲区 ,再 把输入 缓冲区 的 这 两个归并 段的物理 块加以 归并 (采用

内 排序的二 路 归并 过 程) , 送入输出 缓冲 区。当 输出 缓冲区 满时,就 把 它 写人磁盘; 当 一 个

输入 缓冲区 腾空时 , 便 把 同一 归并 段中的 下 一 物理 块 读入,这 样不断 进行,直到 归并 段 书

与归并 段 F; 的 归并 完成 为 止(将 其结果 存放 在 F 文件中) 。

再 归并 Fs 和 RF (结果 存放 在 Fs 文件中),最后归并 忆 和 Fe (结果 存放 在 Fe 文件中) ,

到 此 为止归 并 过 程已对 整个 文件 的所有 记录 扫描 一 遍。扫 描 一遍意 味 着 文件中 的 每 一个记

aa

录 被 读 写 一 次 ( 即 从 磁盘上 读入内 存 一 次 ,并 从 内 存 写 到 磁盘 一 次) ,并 在 内 存 中 参加 一 次 归

并。这 一 遍 扫描 所 产生 的结果 为 3 个归并段 妃 一到 ,每个段含 6 个物理块,合 1500 个记录 。

再用上 述方法把其中的F 和 Fs 两个归并 段 归 并 起 来(将 其结果 存放 在 Fi 文件中,其

大小为3000 个记录的归并段); 最 后将Pie和 Fs 两个归并 段 进行 归并 ,从 而 得 到 所 求 的 排

序 文件Fu。图 11.3 显示 了 这 个 归并 过 程 。

从 归并 过 程可 见 ,扫描 的 遍 数对 于 归并 过 程 所 需要 的存取时间 起 着 关键 的作用。在这

401

数据 结构教程

[第! 5人版

Four

图 11.3

6 个 归并 段的归并 过 程

个 例子 中 ,除了 在 内 排序 形成 初始归并 段 时 需 做一遍 扫 描 外 ,各 归并 段的归并 还 需 2 三 遍 扫

描: 把 6 个 长 度为750 个记录 的 归并 段 归并 为 3 个 长 度为1500 个 记录 的 归并 段需要 扫描

一遍; 把 两 个长度为1500 个记录 的 归并 段 归 并 为一个长度为3000 个记录 的 归并 段 需 要 扫

撒 过 遍 , 把 一 个 长 度为3000 个 记录 的 归并 段 与 另一个 长 度为1500 个记录 的 归并 段 进行 归

并 需要扫描一遍。显 然 ,减少对 数据的扫描 遍 数 可以 减少存取 时间 , 从 而 提高 排序 速度 。

由 于 磁盘 的 读 写 是以 物理 块 为 单位的 ,而一个 物理块可 能 包含 多 个记录 ,在 实际中 读 写

物理 块的次 数 与 很多因素 有 关 , 难以 计算。为 了 简单 ,假设 一 个 物理 块只存放 一 个记录 ,这

例如 ,对 于 图 11. 3 , 若 一 个 物理 块只存放 一 个记录 , 则 在 整个归并 过 程中读记 录 的 次 数

恰好 等于带权 路 径 长度, 即 :

WPL=(750 十75 十750 十750) X3 十 (4750十750) X2 一 12000

它 正好 表示 各 归并 段的归并 需要 2 三 遍 扫 描 。 写 记录 次 数与读 记录 次 数相等,也 为

12 000 次。后 面 均 假设一 个 物理块只 存放 一 个记录 。

归纳 起来,影响 磁盘 排序时间 性 能 的 主要 因素如 下 :

(1) 读 写记 录 次 数 。

(2) 关键字比较次数。

不 同 于 内 排序,磁盘 排序中 元 素 移动 的 次 数 相对 上 述 两个因素 可 以 忽略,所以一般 不 考

虑 元 素 移 动 的时 间 开销 。

ee

因此 可以 大 致认为 磁盘 排序时间 一 读 写 记录 次 数十关键 字 比较次 数 。
由 于 磁盘 排序主要 包含 生成 初始归并 段和多 路 归并 两个阶段,所以 在 这 两 个 阶段中尽

可 能 选择好 的 方法 减少上述 两个因素 的 影响 。

1122 生成 初始归并 段

一 般 情 况下 ,初始归并 段 的个数越多 ,多 路 归并 的 性 能 越 差

。 如 果 采 用 第 10 章中介绍

的 内 排序方法 来 生成 初始归并 段 ,生成的归并 段的大小 正好 等 于 一 次 能放和 内存 中 的记录

个数mm,当m 相 对 较 小时 产生 的 初始归并 段 较 多。这 里 介绍 一种置换 -选择 排序算法 用 于

402

MA 外排序 |

生成 长 度较大 的 初始归并 段 ,从 而 减少 初始归并 段 的个数 。

算法的基本步骤如下 :
置换 -选择 排序(replacement selection sorting)

(1) 从 待排 序 文件 Fas 中 按 内 存 工作区 WA 的容量(设为zw)读和人z个

引-提

记录。设归并段编号 ;一1。

(2)

从 WA 中 选出关键 字 最 小 的记录 Ran。

(3) 将 Ru 记录 输出 到 文件 已 中 ,作为 当前 归并 段 的一个 记录 。
(4) 车 本 不 空 , 则 从 已 中 读 和人下 一 个记录 到 WA 中 代替 刚 输出 的记录。 各 和

(5)

在 WA 工作区 中所有 大 于 或 等于 Ra 的记录 中 选择 出 最小记录 作为 新的Ran,

转(3) ,直到 选 不出这 样的Re。

(6) 置 ;二 ;十 1, 开 始一个 新的归并 段 。

(7)

若 WA 工作 区 已 空 , 则 初始归并 段已全 部 产生 ,算法 结束 ; 否则转(2) 。

【例 11.1】 设 磁盘 文件 中共有 18 个记录 ,记录 的 关键 字 分 别 为 (15,4,97,64,17,32,

108,44,76,9,39,82,56,31,80,73,255,68)

,若内存工作区可容纳 5 个记录 ,用 置换-选择排

序 算 法 可 产生 几 个 初始归并 段 ,每 个 初始归并 段 包 含 哪些记录 ?

初始 归并 段的生成 过 程如 表 11. 1 所 示 。

表 11.1 初始归并 段的生成过 程

读 和人记录

内 存 工作区 状态

Ran

输出 之 后 的 初始归并 段 状 态

15,4,97,64,17|15,4,97,64,17

|4(Gi一1)

归并段1:{4}

32

108

44

76

9

39

82

56

31

0

8

3

255

68

15,32,97,64,17

108,32,97,64,17

108,32,97,64,44

108,76,97,64,44

108,76,97,64,9

108,76,97,39,9

108,82,97,39,9

108,56,97,39,9

|15

|17

|32

|44

|64

|76

|82

|97

归并段1:{4,15}

归并段1:{4,15,17}

归并段1:{4,15,17,32}

归并段1:{4,15,17,32,44}

归并段1:{4,15,17,32,44,64}

归并段1:{4,15,17,32,44,64,76}

归并段1:{4,15,17,32,44,64,76,82}

归并段1:{4,15,17,32,44,64,76,82,97)}

108,56,31,39,9

|108

归并段1:{4,15,17,32,44,64,76,82,97,108)}

9560,31,39,

8 5 3 29 |录 汪 增 1,i=2) |归并 段2:19)

9(没有达108 的记|归 并 段 1:{4,15,17,32,44,64,76,82,97,108}

80,56,31,39,9

|31

归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段 2.19 31)

80,56,255,39,73

|39 归并段 2.19 31 39}

归并段1:{4,15,17,32,44,64,76,82,97,108}

80 ,56,255,68,73

|56

80,,255,68,73

830,...255,73

380,...255
,255,,

68

3

0

8
255

归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段2:{9,31,39,56}
归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段2:{9,31,39,56,68}

归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段2:{9,31,39,56,68,73}
归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段 2:{9,31,39,56,68,73,80}
归并段1:{4,15,17,32,44,64,76,82,97,108}
归并段2:{9,31,39,56,68,73,80,255}

:{4,15,17,32,44,64,76,82,97,10

Su

403

数据 结构 教程

虹 第人5 【版

这 里 共产生了 两 个 初始归并 段,归 并 段 书 为 (4,15,17,32,44,64,76,82,97,108),归

并段 已 为 (9,31,39,56,68,73,80,255)。

显然 ,置换 -选择 排序 算法 生成 的 初始归并 段 的 长度既 与内存 工作区 WA 的 大小 有 关 ,

也 与输入 文件中记录 的 排列 次序有 关 。 可以证明 , 如 果 输 入 文件 中 的记录 按 关键 字 随 机 排

列 , 所得 到 的初始 归并 段的平均 长 度 为内存 工作区 大小 的两倍 。

在 置换 -选择 排序 算法 中 ,内 存 工作区 WA 内频繁的操作是,从 zw 个记录 中 选择一个 关

键 字 最小 的 记录 。 如 果 采 用 基于 简单选择 排序 方法 ,每 次操作 需要 ww一 1 次比较 , 若输入 文

件有交 个 记录 , 则 算法 的时间 复 杂 度为OOzro)。

实际上 ,这 种 频繁的操作 可以 采用 败者树 来 实现,从 训 个 记录 中 选择 一 个 关键 字 最小

的记录的时间 为O(logw) ,从 而 使置换 -选择 排序 算法 的时间 复 杂 度 降低 为OCn logsz)。

败 者 树 将 在 后 面 介绍 。

1123 多 路 平衡归并

所谓 二 路 平衡归并 (2- way balanced merge)就是每一趟从 mm 个 归 段 得 到 | >/2 1 个 归并

段,图 11. 3 所 示 的 归并 可以 看 成是二 路平衡归并 ,这 样的归并 树 就有 | logsm|十1 层 ,需要

对 初始 数据 进行 logsm|遍扫描。做 类似 的 推广, 当 采 用 下 路 平衡归并 时 ,相应的归并 树 有

[ioguwm1十1 层 , 要 对数据进行:= | logiz | 遍 扫描 ,显然,& 越大,磁盘读写次数越少 。 那么

是 不是& 越大,归并 的 总 效率 就 越好呢 ?

在 进行上路归并时,在 & 个 记录 中 选择 最 小 者,如 果 采 用 基于简单选择

排序方法,需要进行 A 一 1 次关键字比较。每趟归并 v 个 记录 需要 做(zx一1) X

(一1) 次 关键 字 比 较 , 则 * 趟 归并 总 共 需 要 的 关键 字 比较 次 数 为 :

SX(z 一 1)XC 一ID)一[ log

|]X(Cx 一1)X(CR 一 1)

扫-扫

5

时

视频讲解

一 | log:zmz |]X(x 一1) (一 1)7[log1]

从 中 可以 看 出 ,在 初始归并 段个数 闷 与记录个数w 确定时,其中的|logzm| X(x 一 1)

是 常量,而 (一1)/| log:A|随 着 的增大 而 增 大 。

因此 , 若 初始归并 段个数 闷 与记录个数 wx 确定 ,在 选择几 路 归并 方案时 ,尽管增大 归并

路数& 会 减少磁盘 读 写 次 数 ,但 & 增 大 会 增加 关键 字 比 较 次 数 。当 & 增 大 到 一 定的程度 ,就

会 抵消 掉 由 于 减少磁盘 读 写 次 数 而 赢得 的时 间 。

也就是说,在& 路 平衡归并 中 ,如 果 采 用 基于 简单选择 排序 方法 ,其 效率 并 非&越大,归

利用败者树 实现 路平衡归并 的 过 程是先建立 败者树 ,然后对 上 个 输入有 序 段 进

行

路 平衡归并 。

败者树(tree of losen)是一棵有 上 个 叶子 结 点 的完全 二 又树(可 将 大 根堆看 成 胜者树),

其 中 叶子 结 点 存储 参与 归并 的 记录 ,分 支 结 点 存放 关键 字 对 应 的 段 号 。所 谓 败者是 两个记

录 比 较 时 关键 字较大 者 ,上胜者 是 两个记录比较时 关键字 较 小 者 。

建立 政 者 树是采用 类似于 堆 调整 的 方法实现 的 ,初始时令 所 有 的 分支结 点 指向 一 个含最

MA 外排序 |

小 关键 字(MINKEY)的叶子结点,然后从各 叶子结 点 出 发 调整 分 支结 点 为 新 的 败 者 即 可 。

对 A 个 有序 段 进行上路平衡归并 的 方法如 下 :

(1) 取 每 个 输入有序 段 的 第 一 个 记录 作为 败者树 的叶子结 点 ,建立 初始败者 树 : 两两

叶子结 点 进行 比较 ,在 双亲 结 点 中 存放 比较 的 败者(关键 字 较 大 者 ) ,而 让 胜者去 参加 更 高 一

层 的比赛 ,如 此 在 根结 点之上 胜出 的“冠军?是 关键 字 最 小 者 。

(2) 将 胜出 的记录 写至输出 归并 段 ,在 对 应 的叶子结 点 处 补充 其 输入有 序 段的下 一 个

记录 , 若 该 有 序 段 变 空 , 则 补充 一个大 关键字( 比所有 记录 关键 字 都大, 设为es)的虚记录。

(3) 调整 败者树 ,选择 新 的 关键 字 最小 的记录 : 从 补充 记录 的叶子结 点向 上 和 双亲结

点 的 关键 字 比 较 , 败 者 留 在 该双亲结 点 , 胜者继续向 上 ,直到 树 的 根结 点 ,最后将 胜者放 在 根

结 点 的 双亲 结 点 中 。

(4) 若 胜出 的记录 关键 字 等 于 es,则归并结束; 否则转(2)继续。

【例11.2】〗 设有 5 个 初始归并 段 ,它们 中 各 记录 的 关键 字 分 别 是 :

Fu:{17,21,co) Fi :15,44,co) Ps:{10,12,co) Fs:{129,32,co) Fi:{115,56,co)

其中,ce 是 段结 束标志 即 ee。 说 明 利用 败者树 进行 5 路 平衡归并 排序的过 程 。

这里&=5, 其 初始归并 段 的 段号分别为 0 一4(与 已一F 相对应) 。先构造含有 5

个 叶子 结 点 的 败者树 ,由 于 败 者 树 中 不 存在 单 分 支结点,所以 其中有 4 个 分 支结 点,再加 上

一 个 冠军结 点 (用 于 存放 最小 关键 字 )。用 1s[0] 存 放 冠军 结 点 ,ls[1] 一 1s[4] 存 放 分 支结 点 ,

加 一 0 存放 叶子结 点。初 始时 ls[0]

一1s[4]分别取 5( 对 应 的 Fs 是 虚拟 段,只 含一个 最小 关

键字 MINKEY 即 一c) ,2 一 六 分 别 取 必 一局 中 的 第 一 个 关键字, 如 图 11.4(a)所示。为

了 方便,图 11.4 中 的 每 个 分 支 结 点 中 除了 段 号以外 另加 有 相应 的 关键 字 。

然后从久 一 2 进行调整 建立 败者树 。

调整 wm , 置 胜者(关键字最小者)为 4,z=一(Cs 十5)/2 一 4, 将 0[Ls].key(15)和 ofls[o.key]

中,一以2一2;
(CO[Lls[4]. key] 三 一 ce) 进行比较 , 胜 者 *=1s[ 自 =5, 将 败 者“4(15)” 放 在 lsL4]

将 1s[s].key(一co)与双亲 结 点 ls[门. key( 一 co ) 进 行比较 , 胜 者 仍 为 *王5, 一 0 2一1; 将

1s[s]. key(一=) 与双亲结点 1s[门.key(一=)进行比较,胜者仍 为 :一5, 上 一2/2 一 0, 最 后 置

1s[0]==s*(一co)。其结果 如 图 11.4(b)所示。实际上 就是从 到 1sL1](图 11.4(b)中的粗

线 部 分 ) 进 行调整 ,将 最 小 关键 字 的 段号放 在 lsL0]中 。

调整 六 一 2 的 过 程与此 类 似 , 它们 调整 后 得 到 的 结果 分别如图 11.4(c) 一图 11.4(f)所

示 , 图 11.4(f)

就是构建 的 初始 败者树 。

在败者树 建立 好以后,可以利用 5 路 归并 产生有 序序列 ,其 中 主要 的 操作 是 从 5 个 关键

字 中找 出 最 小 关键 字 并 确定 其 所 在 的 段号,这 对 败者树 来 说 十 分 容易 实现 。

先从初始败者 树 中 输出 ls[0] 记 录 到结果 输出 归并 段中, 即 输出 1 号 段的当前 关键 字 为

5 的 记录 ,然后在 已 中 补充下 一 个 关键 字为44 的 记录 到 11 号 段,再进行调整。调 整的过
程 是 将新 进入树的叶子 结 点 与双亲结点进行比较, 较 大 者 ( 败者) 存 放 到 双亲 结 点 中 , 较小 者

aa

(胜者 ) 与 上 一 级 的 祖先 结 点 再 进行比较,此 过 程不断 进行一直到 根结 点 ,最 后 把新 的 全 局优

胜者写 至 输出 归并 段 。

对 于 本 例 ,将 1(5) 写 至结果 输出 归并 段后在

已 中 补充 下 一 个 关键 字 为 44 的记录,调

整败者 树 ,即将 1(44) 与 2(10) 进行比较 ,产生 败者 1(44),放在 ls[3]中,胜者 为 20(10); 将

2(10) 与 4(15) 进 行 比较,产生败 者 4(15) , 胜 者 为 2(10); 最 后 将 胜者 2(10) 放 在 lsL0]中。只

经 过 两次比较 产生 新 的 关键 字 最 小 的记录 2(10) ,如图 11. 5 所示 ,其 中 粗 线 部 分 为 调整路 径 。

数据 结构 教程

眶 第人5 【版

So GCC)

1s[0]

(1(5) 7冠军(最 小 者 )

(d) 从 思 开始调整

1s[4]OF 17

0

六

29

加

15

思 AL
5

“

[nm

(e) 从 力 开始 调整

(D) 从 加 开始 调整

图 11.4 建立败者树的过程

说 明 :

在 上 一 小 节 的 置换-选择 排序算法 中第(2) 步从 WA 中 选出关键 字 最 小 的记录 时

也 可 以 使用败者树方法 以 提高 算法 效率 。

从 上 例看到 ,路 平衡归并 的 败者树 的 高 度为[log:A |十19 ,在 每 次 调整找下 一 个具有

最 小 关键 字 的 记录 时 仅 需 要 做 | log:& | 次 关键 字 比较 。

因此 ,若 初始归并 段为刀 个,利用 败者树在& 个 记录 中 选择最小者只 需要 进行| log:k |

次 关键 字 比 较 ,则 := | logum |]趟 归并 总 共 需 要 的 关键 字 比 较次数 为 :

SX (uk 一1) X[log:& |=[loge

|]X(x 一) X[ log:R 1]

@ 路 平衡归并 败 者 树是一 棵 含有。 个 叶子 结 点 , 且 没有单 分支结 点 (这 是 构建上 路 平衡归并 败者树 的约定 ) 的 完

全 二 叉 树 , 即 站 一0。有 关 一 和 一 1 一&一 1 一 7 十 三 十 轨 一次 一1], 则 大一| logs(Cz十1) 1一 [logz(2A)|]一 [logzk|十1。

32

所

56

阿

21

古

co

阿

12

已

图 11.5 重 购 后 的 败者树 ( 粗 线 部分结 点发生 改 变 )

一 [logsm |]X(x 一1) X[log:R TV/IlogR|

一 | log:zmz |]X(x一1)

这 样,关键字比较次数与上 无 关 , 总 的 内 部 归并时 间 不 会随& 的增大 而 增 大。但 & 越

大 ,归并 树 的 高度较小 , 读 写 磁 盘 的 次数也 较 少 。

因此 , 当 采 用 败 者 树实现 多 路平衡归并时 ,只 要 内 存 空间 允许 ,增大 归并 路 数 外 会有效

地 减少归并 树 的 高 度,从 而 减少读 写 磁盘 次 数 ,提高 外 排序 的 速度 。

1124 最佳归并树

由 于 采用 置换 -选择 排序 算法 生成 的 初始归并有 段 长 度不等,在 进行逐趟 人 路归并时对归

并 段 的组合 不同,会导致归并 过 程中读 写 记录 的 次 数 不 同 。为了 提高 归并 的时间 效率 ,我们

有 必要 对 各 归并 段 进行 合理 的搭配 组 合。按 照 最佳归 并 树 的 设计 可以使归并 过 程 中对 外 存

的 读 写 次 数 最 少 。

归并 树 是描述 归并 过 程的& 次树。因 为 每一次 做 上 路归并都需要有 A 个归并段参加,

因此 归并 树 是只包含 度 为0 和度 为上的 结 点 的标准& 次树。

下 面 看 一 个 例子 。 设有 11 个 长度不 等 的 初始归并 段,其 长 度 (记 录 个 数 ) 分 别为1.3、

5.7.9、13、16.20.24.30.38。 在对 它们 进行 3 路 归并 时 ,采用 归并 方案对 应 的 一 棵 归并 树 如

图 11.6 所示。

此 归并 树 的 带权 路 径 长度WPL=(24

十30十38十13十16十20) X4 十 9 义 3 十(5 十 7) 久

2 十(1 十3)X1一619。

因为 在 归并 树 中 各 叶子 结 点代表 参加 归并 的 各 初始归并 段,叶 子 结点上 的 权 值即 为 该

aa

初始 归并 段中的 记录 个 数 ,根结 点代表 最 终生 成的归并 段,叶 子 结 点 到 根 结 点 的 路 径 长度表

示 在 归并 过 程中的 读记录 次 数,各非 叶 子 结 点代表 归并 出 来 的 新 归并 段 , 则

归并 树 的带权 路 径 长度WPL 即 为归并过程中的 总 读 记 录 数 ,因此在归并

过 程 中总 的 读 写 记 录 次 数 为2X 友PL 王1238。

不 同的归并 方案 所 对 应 的 归并 树 的 带 权 路 径 长度各 不 相同 ,为了使 总

的 读 写 次 数 达到 最 少 ,需要 改变 归并 方案,重新 组织归 并 树 ,使其路 径长度

407

数据 结构教程

[第1 5 【版

150 宁 7

@ @ 二

图 11.6 一棵 3 路归并树

WPL 尽 可 能 短。所 有 归并 树 中 最 小 带权 路 径 长度WPL 的 归并 树 称 为 最佳归 并 树 (Coptimal

merge tree)。为 此 ,可 将 哈 夫 曼 树 的 思想 扩充 到 & 次 树 的情形。在 归并 树 中 ,让 记录 个 数 少

的初始 归并 段最先 归 并 ,记录 个 数 多 的初始 归并 段 最晚归 并 ,就 可 以建立 总 的 读 写 次 数 达到

最 少 的 最 佳 归 并 树。显 然图 11. 6 所 示 的 归并 树 不是一 棵 最 佳 归 并 树 。

为了使 归并 树 成 为一棵标准& 次 树 , 可 能 需要补 和人虚 段(记录 个 数为 0

的 归并段) 。

补 虚 段 的 原则为: 设 参加 归并 的 初始归并 段有疡 个 ,做上 路平衡归并。因为归并树

是只有度 为0 和度 为&的结 点 的 正则 & 次 树 , 设 度 为 0 的结点有 疡 个(因为初始归并段有

广 个,对 应 归并 树的叶子 结 点 就有疡 个) , 度 为&的 结 点有mr 个,则有mm 一 (一1)mx 十 1。

因此 ,可以 得出 mr 二 (Cm 一1)7GR一1)。如 果 该 除 式 能 整除 ,即(m:一1) mod (一1) 一0,则

说 明 这 z 个 叶子结 点 正好 可以 构造& 次 归并 树 ,不 需 加 虚 段,此时 分 支 结点有 mu 个 。如果

(2 一 1)%(R 一1) 一 vx天 0, 则需要 补和人A一x一1 个 虚 段,这样 就 可以 建立归并树了 。

因此 ,最佳归并 树 是带权 路 径 长度最 短的& 次 ( 阶 ) 哈 夫 曼 树 ,其 构造步骤 如 下 :

(1) 若 (m 一1)modCR 一1) 天 0, 则 需 附加 (一1) 一(2 一1)mod(&R一 1) 个 长度为 0 的 虚 段

(Cdummy run) ,以 使 每次归并都 可以对

应 个段。

(2) 按照哈夫 曼 树 的 构造 原则 ( 权 值 越小 的结 点 离根结 点 越远) 构 造 最佳归 并 树 。

对 于 前 面 的 例子,mm二11,A

一3,(11

一1)mod(3

一1)

一0, 可 以 不加空归 并 段,直 接 进行 3

路 归并 ,其 最 佳 归 并 树 如 图 11.7 所示 。

Q95

这 NT

ID

图 11.7 一棵 3 路 最佳归并树

408

MA 外排序 |

此 归并 树 的 带权 路 径 长度 WPL=38X1 二 (13 十16 十 20 十24 十 30) X2 十(7 十9) X3 十

(1 十3十5) X4 一 328 ,在 归并 过程中 总 的读写 记录 次 数 为2X WPL 一 656 。

也 就 是 说 ,同样 一组 初始归并 段,采 用 的 归并 路 数 也 相同 ,但 选择不 同的归并 方案 , 读 写

记录 次 数 可 能 是 不相同 的 ,最佳归并 树 对 应 的 归并 方案 是 读 写记 录 次 数 最 少 的 。

【例 11.3】〗 设 文件经 预处理 后得到 长 度 分别为49、.9.35、18、4、12、.23、

7、21、14 和 26

的 11 个 初始归并段,试 为4路 归并 设计 一 个 读 写 文件次数 最 少的归并 方案 。

国 初始归并 段 的 个数记 =11, 归 并 路数人 一4,由于(一 1)mod( 一1) 一1,不为0,因

此需附加(一D)

一(mm

一1)mod(C

一1) 一2 个 长 度为0 的 虚 段 。根 据 集 合{49,9,35,18,4,

得到按长度递增排序的结果为(0,0,4,7,9,12,14,18,21,23,26,
12,23,7,21,14,26,0,0)}

35,49),

由此构造的4 阶 哈 夫 曼 树如 图 11. 8 所 示 。

图 11.8

4 路 最佳归并树示例

该 最佳归并 树显示 了 读 写 记录 次 数 最 少的归并 方案, 即 :

@ 将 长 度 为4和 7 的 初始归并 段 归并 为长度为11 的有序段。

Q@ 将 长 度 为 9.12

和 14 的 初始归并 段以及 长度为 11 的有序 段 归并 为 长 度为46

的 有

序段。

@@ 将长度为18`.21.23 和 26 的 初始归并 段 归并 为长度为88 的有序段。

印 最 终 将 长 度为 35 和 49 的 初始归并 段以及 长 度为 46 和 88 的有序 段 归并 为 记录 长

度为218 的有序文件整体。

此 归并 方案 的 读 写记录 次 数 为2X[(4 十7)X3 十(9 十12 十14 十18 十21 十23 十 26) X2 十

(35 十49)X1]=726 次。

和全 一

由 于 磁带 的 特性 不同于 磁盘 的 特性,所 以 两者采用 的 外 排序 方法也 不尽相同 。

11.31 多 路 平衡归并排序

磁带 的 多 路 平衡归并 排序过 程 与 磁盘 的 多 路平衡归并 排序过 程基本 上 相同 ,先对 输入

数据 结构 教程

虹 第人5 人版

文件 的 各 段 进 行内 排序,生成 初始归并 段 ,再 把 它们 写 到 磁带 上,然后再把这些归并段进行

反复 归并 ,直到 只 剩 下 一 个 归并 段 ( 即 为排好序 的 文件 ) 为止。

磁带 排序(tape sort) 和 磁盘 排序的主要 不 同 之处在 于 磁带 排序需要 充分 考虑 归并 段 的

分 布状况 ,因为 磁带是顺序 存 取 的 ,所以 各 归并 段 分 布 在不同 磁 带和 同一 磁带 的 不 同位置对

排序效率影响极大。

先 看 一 个 二 路 归并 磁带 排序 的 例子,了 解 磁带 排序 所 涉及 的 各 种 因素 。

设 有 一 个文件包含4500 个记录 ,现在 要 对 其 进行排序 ,可 供 使用的 磁带 有 4 台 , 即 、

T Ti Ti ,可 供 排序 用 的 内 存 空间包 含 存放 750 个记录 的空间以 及 一 些 必 要 的 工作 区。设

内 、 外 存 交 换 的 块 的 大小为250 个记录 。 为了简化讨论 ,假设初始 归并 段中的 生成是采用 通

常的内排序方法实现的。这 样 ,一 次 可读 入 3 个输入 文件 的 物理 块,对 之 进行 排序,并 作为

一 个归并段输出。下 面 采 用 二 路 归并 的 方法 来实现 归并 段的归并 ,因而 使 用 两 个输入 缓冲

区 和 一 个 输出缓训 区 ,每 个 缓冲区 的 大小为250 个记录 。 排 序 过 程的具体步骤 如 下 (假设 输

入文件在磁带 Ti 上 ):

第 1 步: 把输入 文件分段 ( 每段包含750 个记录)读人

内 存 并 进行 内 排序 ,生成 初始归并 段 , 然 后将这 些 归 并 段 轮

九 | 归并段1 | 归并段3 | 归并段5

定 写 到 磁带 一

和 T 上。此 步骤 后 的 磁带状况如图 11. 9(a) 。 丈 | 归并段2 | 归并段4 | 归并段6

所 示。

第 2步:采用二路归并,把 六 上 的 各 归并段与T 上

的 各 归并 段 归并 (之后Ti 和 T 上 的记录 仍 存在 ,但 不 再

有 用 ,可 将 它们 看 成空磁 带) ,并 把 所 产生 的 较大归并 段 轮

流 分 布到 Ts 和 Ti 上 ( 若输入 文件带需 要 保留 , 则 在 第 1

必 | 输入文作4500个记录

(a) 第 1 步后磁带的 状态

闭 | 归并段1 | 归并段3 | 归并段5

步 完 成 后 把输入 文件带从 T,

上 外下来,换上 工作带)。此 开 归并段2 | 归并段4 | 归并段6

步后的 磁带 状况 如 图 11.9(b)所示。其中Ti 上 的 归并段1 信 | 归并段1

归并段3

是 上 的 归并 段1 和 Ts 上 的 归并段 2 归并的结果,T:, 上

的 归并 段 3

是

厂 上 的 归并段 5

和 T: 上 的 归并段 6 归并的

结果 ,T, 上 的 归并 段2是 石

上 的 归并段 3

和 T: 上 的 归并

玉 | 归并段2

(b) 第 2步后磁带的状态

段 4 归并的结果。

第 3 步: 把 上 的 归并 段1和 T 上 的 归并段 2 进行
归并 ,并 将结果 放 到 万 上。此 步后的 磁带 状况如 图 11.9(c)

忆

所示 。

归并段3

(c) 第 3步 后磁带的状态

九 | 归并 段1( 包 含 3000 个 记录 )

第4步:把 上 的归并段 1和Ts 上 的 归并段 3 归

图 11.9 磁带 排序 过 程

并,并把结果放到 T, 上 ,这 就 是排好 序 的文件 。

这 里 采用 的 是 二 路 归并 ,和 磁盘 排序 的情况 一样,排序 的 时间 主 要 取决于对 数据 的 扫描

遍 数。采 用 多 路 归并 能 够 减少 扫描 的 遍 数 ,但对 磁带 排序 来 说,多 路 归并 需要 多 台 磁 带 , 为

了 避免 过 多 的 磁带 寻找时间 ,要 归并 的 归并 段需要 放 在 不 同的磁带上。

要-碍

此 ,路 归并 至 少需要 & 十 1 台 磁 带 ,其 中 台 作为 输入带 , 另一台 为 归并 后 | 回和

输出之用 。但 是 这 样需要 对 输出 带 再 做 一 遍 扫描 ,把 输出带上 的 各 归并段

重新分配到 & 台 磁带上 ,以 便 作 为下一 级 归并 使 用。若 使 用 24 台 磁 带 , 则

可 避免这种 再 分配 扫描。把 & 台作为输入带,其余&台 作为 输出带,在下 一 视员和

410

MA 外排序 |

级 归并时 输入带与输出 带 的 作用 互相对 换 。

上 述例子就是用 4 台 磁 带 实现二 路 归并 ,Ti 、T 和 也 、T 轮流地 用 作 输 入带和 输出 带 。

1132 多阶段归并排序

所 谓 的 多 阶段 归并 排序 实际上 是 多 路非 平衡归 并 排序 ,即 各 条 带 上 的 归并 段 不再保持

平衡分布,它在上 路 归并 中 仅 使 用 (十1) 条 磁带就可 避免在多 路平衡归并 排序法中 遇 到 的

眶

新 分 布有序 段的问题 。

开始时 ,初始 归并 段 不 平衡地分 配 在前& 条 磁带上 ,第 (十 1) 条 磁带 作为输出 带,开 始

为空。每 一步归 并 只 是 部 分记录 参加 ,归并 段最少 的 带 在 本 步 归 并 完成后便 成 为空带 ,作为

下 一步归并 的 输出 带。这 样, (4 十 1) 条 磁带将轮流 成 为输出带, 直 到 整个 文件为一个 排序 文

件 为止。

例如 ,假设有 17 个 初始归并 段 (S,S: ,...,Svr),用4 台 磁 带 机 .T、T 和 Ti 做 3 路多

阶段 归并 排序 ,其 初始归并 段 的 分 布情况 及 排序过 程中各 磁带 数据 的 变化情况 如 表 11. 2 所 示 。

表 11.2 各 阶段 归并 段 的 分 布情况

阶段

磁带

初始 时

第 1 步月并后

第 2 步
第 3 步
归并后“| 归并后

第 4 步
归并后

全

Si,S4,Sy ,So ,Sis,Si Sr

Sa ,Su ,Sr

Sr

空 S(最终结果)

T

全

Sa ,Se ,SS

空

SS927

空

SS ,S9 ,SS5 SO

S9 ,SS

SS

SO

空

空

为 了 使 归并 的 趟 数 达 到 最 少 ,必须 合理 地 分 配 各 磁带上 初始 归并 段 的 段 数。通 过 分 析

斐波那契)序
可 以 得 出以 下结论: 归并 段 的 总 数 以 及 在 各 带 上 的 分 布情况 与A阶 Fibonacci(

列有关系。设 Fi 为 阶 Fibonacci 序列中的第;项

, 当 利用(十 1) 台 磁带 机 做 & 路 多 阶段

归并 时 , 若 初始归并 段 的 总 数 为 :

工一LAF和9十 (一 DEF 十 交 十 2F9uo 十 Fe]

则 需要 进行0: 一 A十2) 个 阶段的归并 ,初始归并 自在 各 带 上 分 布 的段数 应 为 :

五 一 FE 十 FS 十 全 十 Fw- 十 Fu-

T: 一 FS 十 下多 十 ... 十 Fe

Ti 一 FI 十下名

Ti 一 Fe

视频 讲解

其中必阶 Fibonacci 数列 可 用 下 面 的 递 推公式 导出 :

aa

FP = Fo 一 ...=F2 =0

Fo 一 1

例如 ,假设 在 4 台 磁 带 机 上 做 3 路 多 阶段归并 时 ,初始归并 段 的 段 数为193,则首先根

据 定义 可 以计算 出 三 阶 广义 Fibonacci 序列 为 (0,0,1,1,2,4,7,13,24,44,81,149,274,,...),

而 T=3F9 十2F8

十 F922 一3X44 十2X24十13王193,即 ;一9, 所以 各 磁带上 的 初始归并 段

411

数据 结构教程

[第! 5版

段数分别为:

一 FE 十 FE 十 FE 一 4 十24十13 一 81

思 一 FP 十FB

一 44十24一 68

三 一 FS 一 44

Ti一 0

一 共 需 要 进行(ti一上十 2)一 8 个 阶段的归并 ,其 各 阶段中归并 段段数在各 磁带 机 上 的 分

布情况 如 表 11. 3 所 示 。

表 11.3 四 带 三 路 归并 各 阶段中归并 段 的 段 数 分 布情况

阶段 号

初始

1

2

3

4

5

6

7

8

人

81

37

13

0

7

3

1

0

1

T

68

24

0

13

6

2

0

1

0

Ts

44

0

24

11

人

0

2

1

0

人

0

44

20

7

0

4

2

1

0

归并段总数

193

105

57

31

17

9

5

3

1

本 章 的 基本 学 习 要 点如 下 :

(1) 理解外排序的特点。

(2) 掌握 磁盘 排序过 程和影响磁盘 排序 性能

的 因素。

(3) 掌握生成初始归并段 的置换 -选择 排序 算法 。

(4) 掌握 利用 败 者 树 实现 多 路 平衡归并 的 过 程和特点 。

(5) 掌握 利用 最 佳归 并树 构 造归 并 方案的过程 。

(6) 理解 磁带 排序过 程 。

一 人 练习题 11 一

1. 外 排序中 两 个相对独立的阶段 是 什么?

2. 给 出 一组关键字 T={12,2,16,30,8,28,4,10,20,6,18},

设 内 存 工作区 可 容纳 4 个

记录 ,给 出 用 置换 -选择 排序 算法 得 到 的 全 部 初始归并 段 。

3. 设 输入的 关键 字 满足 局 二 包 二 ... 全 局 , 缓冲区 大小为六, 用 置换 -选择 排序 方法可 产

生 多 少 个 初始归并 段 ?

4. 什么是多 路 平衡归并 ? 多 路 平衡归并 的 目的是什么?

412

MASS外排序 |

5. 什么是败者树? 其 主要作用是什么 ?用于& 路 归并 的 败 者 树 中共有 多 少个结 点 (不

计和冠军结点)?

6. 如 果 某 个 文件经内 排序得 到 80 个 初始归并 段 ,试问 :

(1) 若 使用多 路平衡归并 执行 3 趟 完成 排序 ,那么应取 的 归并 路 数 至 少 应 为多少 ?

(2) 如 果 操 作 系统 要 求一个 程序 同时 可 用 的输入 /输出 文件 的 总 数不超 过 15 个 , 则按

多 路 平衡归并 至 少 需要 几 趟 可以 完成排序? 如 果 限 定 这 个 趟 数,可 取 的 最 低 路 数 是多少 ?

7. 若 采用 置换选择 排序 算法得 到 8 个 初始归并 段 ,它们 的 记录 个 数 分 别为37、34、300、

41.70、120.35 和 43。 画 出 这 些 磁 盘 文 件 进行归并 的 4 阶 最 佳 归 并 树 ,计算 出 总 的 读 写 记

录数。

实验题1: 创建一棵败者树

目的: 领会外 排序中 败者树 的 创建 过 程和算法 设计 。

内 容: 编写一个程序expl1l-1. cpp, 给 定 关 键 字 序列 (17,5,10,29,15),采用 5 路 归并 ,

创建 对 应 的 一 棵 败 者 树 ,并 输出 构建 过 程 。

愧设计 性 实验

实验题 2: 从 大 数据 文件 中 挑选天 个 最小 的 记录

目的: 掌握 外 排序的过 程 及 堆 的 应 用 算法 设计 。

内 容: 编写一个程序expl11-2. cpp, 从 大 数据 文件 中 挑选K 个 最小 的记录。假 设 内 存

工作 区 的 大小为&, 模 拟 这 个 过 程,并 输出 每 趟 的结果。假 设 整 数 序列 为 (15,4,97,64,17,

32,108,44,76,9,39,82,56,31,80,73,255,68)

,从中挑选 5 个 最小 的整数 。

实验题3:

用 败 者 树 实现置换 -选择 算法

日 的: 领会 外 排序中 置换-选择算法 的 执行 过 程和算法 设计 。

内 容: 编写一个程序expl11-3. cpp, 模 拟置换 -选择 算法 生成 初始归并 段的过 程以 求解

以下问题 。设 磁盘 文件 中共有 18 个 记录 ,记录 的 关键 字 序列 为 :

(15,4,97,64,17,32,108,44,76,9,39,82,56,31,80,73,255,68)

若内存工作区 可 容纳 5 个 记录 ,用 置换 -选择 排序 可 产生 几 个 初始归并 段 , 每 个 初始归

并 段 包 含哪些记录 ? 假设输入 文件 数据和 输出 归并 段 数据 均 存 放 在 内 存 中 。

实验题4: 实现 多 路平衡归并 算法

目的 : 领会 外 排序中 多 路 平衡归并 的 执行 过 程和算法 设计 。

内容: 编写一个程序expl1-4. cpp, 模 拟利用 败者树 实现 5 路 归并 算法 的过程以 求解以

下 问题 。 设有 5 个 文件 中 的记录 关键 字 如 下 :

Fo:{17,21,co)F:(15,44,co) Fa :{10,12,co》Fs:{(29,32,co) Fe:(15,56,co}

要 求 将其归并 为 一 个有序段并 输出。假设这 些输入 文件 数据 存放 在 内 存 中 ,输出结果

直接在屏幕上显示 。

413

在 处理 数据时经 常需要将 大 量 的 数据以 文件 方式 保存 在 外存

, 如何在 文件中有 效 地组织 数据 是 高 效 使用数据的关键。

本 章 介绍 文件的基本 概念 和 各 种 文件的存储 结构 。

EM2S

文 件

文件的基本 概念

洒

1211 什么是文件

文件 (file) 是 性质相同 的记录 的 集合。文件的 数据量 通常 很大, 它被放置 在外 存上。 数据

结构 中 所讨论 的文件主要 是 数据 库 意义上 的 文件 ,而 不 是操作 系统 意义上 的 文件 。操 作 系 统

中 研究 的 文件是 一 维 的 无 结构 连续 字符 序列 ,数据库中 所 研究 的 文件 是带有 结构 的记录 集合 ,

每 个记录 可 由 若干个数据 项 构成 。记 录 是 文件中 存 取 的 基本 单位 ,数据 项 是 文件 可 使用 的 最

小 单位。数 据 项有时 也 称为字段 。其 值能 唯一标识一个记录 的 数据 项 或 数据 项 的组合 称 为 主

关键字(primary key) ,其他 不 能 唯一标识 一 个记录 的 数据 项 则 称 为次关键 字 (secondary key) 。

图 12. 1 所 示 为 一 个 简单 的学生 文件 ,每 个 学 生 情 况 是 一 个记录 , 它 由 5 个数据项组成。

其 中 "学 号 ?可 作为主关键 字 , 它 能 唯一标识 一 个 记录 ,而姓名 、 性 别 等 数据 只 能 作为次关键

字 , 因 为 它们 的 值对 不 同 的记录 是 可以 相同 的 。

学 号

1

5

3

8

4

姓名

李 明

王 平

张 萍

陈强

马伟

人性 别

民族 班号

男

男

女

男

男

汉族

汉族

满族

汉族

回族

99101

99101

99102

99101

99102

图 12.1 一 个 学 生 文件

文件 可以 按照记录 中 关键 字 的 多 少 分 成单关 键 字 文件和多 关键 字 文件 。若文件中的记

录 只 有 一 个 唯一标识记录 的 主 关键 字 , 则 称 其 为单关 键 字 文件; 若 文件中 的记录 除了含有

一 个 主 关 键 字以 外 还 含有若干个次 关键 字 , 则 称为多 关键 字 文件。

文件又 可 分 成 定 长 文件和 不 定 长 文件。若 文件 中记录 含有的 信息 长 度相同 , 则 称 这 类

记录 为 定 长 记录 ,由 这 种 定 长 记录组 成 的 文件称 为定长 文件; 若 文件 中记录 含有的 信息 长

度 不 等 , 则 称 为不定 长 文件 。图 12. 1 所 示 的 学 生 文件是一 个 定 长 文件。

和 其他 数据 结构 一 样 ,文件 结构也 包括 逻辑 结构 存储 结构以 及 在 文件上 的 各 种 操作

(运算)这 3 个 方面。文件 的操作 是 定义 在 迎 辑 结构上 的 ,但 操作 的 具体 实现 要 在 存储 结构

上 进行 。

1212 文件 的 逻辑 结构 及 操作

文件 中 各 记录 之间 存 在 着 逻辑 关系 , 当 一 个 文件 的 各 个 记录 按照 某种次 序 排列 起 来 时

(这 种 排列 的次序 可以 是记录 中 关键 字 的 大 小 ,也可以是各 个 记录 存 人 该 文件 的时间 先后

等)各记录之间 就 自然地 形成了一 种 线性

关系。在 这 种 次序下 ,文件 中 的 每个记录 最多只 有

一 个 后 继记 录 和 一 个 前 驱记 录 ,而 文件 的第一 个记录 只 有 后 继 没有前 驱 , 文件的 最 后一个 记

录 只 有 前 驱 没有后 继。因 此 ,文件可 看 成是一 种 线性结构 。

数据 结构教程

[第! 5 【版

文件上 的 操作 主要 有 两 类 : 检索和维护 。

文件 检索 就 是 在 文件中 查找 满足给 定 条 件 的记录 , 它 既 可以 按 记录 的 逻辑号( 即记录 存

入 文件时 的 顺序 编号) 查 找 ,也 可以 按关键字查找。

文件维护主要 是指对 文件进行记录 的 插入、 删除及 修改 等 更 新

操作。此外,为了提高文

件 的 效率 ,还 要 进行 再组 织 操作 文件被破坏后 的 恢复 操作 ,以

及 文件中 数据 的安全 保护等。

1213 文件的存储结构

文件的存储 结构 是 指 文件 在外存上 的 组 织 方式 。采 用 不 同 的 组 织 方式 就 得 到 了 不 同 的

存储 结构。基 本 的 组 织 方式有 4 种 ,即 顺序 组 织 、 索 引 组 织 、 哈 希 组织和 链 式组 织。文 件组

织的各 种 方式往往是这 4 种 基本方式的结合。

由 于 文件组 织 方式 (即存储 结构 ) 的 重要 性 ,通常对以 不 同方 式 组织的 文件 给 予不同 的

名 称 。目 前 文件 的组 织 方式 有很 多,人 们 对 文件 组 织 的分类 也 不尽相 同 , 本 章 仅 介绍 几 种 常

用 的 文件 组 织 方式 ,即 顺序 文件.索引 文件、 哈 希 文件和 多 关键 字 文件 。选 择 哪 一种文件组

织 方式取决 于 对 文件中记录 的 使用 方式和 频繁 程度. 存 取 要 求 , 外 存 的 性质和 容量 。

顺序文件(sequential file) 是 指 按记 录 进入文件 的 先后 顺序 存放 ` 其 逻辑 顺序跟 物 理 顺

序 一 致 的 文件。若 顺序 文件中 的 记录 按 其 主 关键字有 序 , 则 称 此顺序 文件 为 顺序有序 文件 ,

否则 称 为 顺序 无 序 文件 。为了 提高 检索 效率 ,经常将 顺序 文件 组 织 成有序 文件 。

一切存储 在 顺序 存 取 存 储 器 (如 磁带)上 的 文件都只 能 是 顺序 文件 。顺 序文件只能按顺

序 查 找 法 存 取 , 即 顺序 扫描 文件,按 记录 的 主 关键 字 逐 个 查找 。 如 果 要 检索第;个记录 , 必

须 检索 前 ;一 1 个记录。这 种 查找 法对 于 少量 的 检索 是 不经济的,但 适合于 批量 检索 ,即 把

用 户 的 检索 要 求先进行积累 ,一 旦 待查记录 聚集到 一 定数 量之后 便 把 这 批 记录 按 主 关键 字

排序,然后通过 一 次 顺序 扫描 文件来 完成这 一批检索 要 求 。

存储 在 直接 存 取 存 储 器(如 磁盘)上 的 顺序 文件可以 用 顺序 查找 法 存 取 , 也 可以 用 分 块

查找 法或二 分 查找 法 进行存取 。 分 块 查找 法 在 查找 时 不 必 扫 描整个 文件中的记录 , 先 通 过

关键 字 找 到 相应 的 块 ,再扫描 这 个 块 即 可。二 分 查找 法 只 能 对 较 小 的文件 或一个 文件的索

引进行查找 , 当 文件 很大,在 磁盘上 占有 多 个 柱 面 时 ,二 分 查找 将 引起 磁头 来 回 移动 ,增加 寻

查时间。

顺序 文件不 能 按 顺 序 表 那样的方法 进行插和人、 删除和 修改 ( 若 修改 主 关键 字 , 则 相当 于

先做 删除后 做 插入) ,因为 文件中 的记录 不 能 像向量 空间 的 数据那样“移动 ”而 只 能 通过 复

制 整个文件 的 方法 实现上 述 更 新 操作。这 就 是 为 什么数据库 系统 总 会产生 很 多 临时 文件 的

顺序 文件 的主要 优点 是 连续 存 取 的 速度 较 快 ,即 若 文件中 第 守 个 记录 刚 被存取 过 ,而 下

一 个 要 存 取 的 是第 ;十1 个记录 , 则 这 种存取 将 会 很 快 完 成 。当顺序 文件存放 在 单一存储 设

备 ( 如 磁带)上 时 ,这 个 优点 总是可以 保持 的 ,而 当 它 是存放 在 多 路 存储 设备 (如 磁盘)上 时 ,

在 多 道 程序的 情况下 ,由 于 其 他 用 户 可 能 驱使 磁头 移 向其他 柱 面 ,就 会 降低这 一 优点 。

416

此,顺序文件多用于磁带。

EM2sSJ文 件 |

在 用 索引 的 方法 组织 文件时 通常是在 文件 本 身 ( 称 为主 文件)之 外 另外建立一张表,它

指明 逻辑记录 和 物理记录 之 间 的 一 一对 应 关系 ,这 张 表 就 称 为 索引 表 (index table) ,它和 主

文件 一 起 构成 的 文件称 为 索引 文件(indexed file) 。

索引 表 中 的 每 一项称 为 索引 项(index item) ,一 般 索 引 项 都是由 主 关键字和 该 关键 字 所

在 记录 的 物理 地 址组 成 的 。显然,索引 表 必 须 按 主 关键字有 序 ,而 主 文件本 身 则 可 以 按 主 关

键字有 序 或 无 序 ,如 果 主 文件有序 称 为 索引 顺序 文件(indexed sequential file) ,如果主文件
无序称为索引 非 顺 序 文 件(indexed non-sequential file) 。

对 于 索引非 顺 序 文件,由 于 主 文件中 的记录 是 无 序的, 则 必须 为 每个记录 建立一个 索引

项 ,这 样 建立 的 索引 表 称 为稠密 索引。对 于 索引 顺序 文件,由 于 主 文件中 的 记录 按 关键字有

序 , 则 可 对 一 组记录 建立 一 个 索引 项 ,例如 让 文件 中 的 每 个物理 块对 应 一 个 索引 项 ,这 种 索

引 表 称 为 稀疏 索引 。 通 常 将 索引 非 顺序 文件简称为索引 文件 ,本 节 只讨论 这 种 文件。

索引 文件在存储器上 分 为 两 个区 ,即 索 引 区 和 数据 区 ,前 者 存放 索引 表 , 后 者 存放 主 文

件。在 建立 文件的过程中 按输入 记录 的 先后 次序建立数据区和 索引 表 , 这 样 的 索引 表 其 关

键 字 是 无序的 , 待 全 部 记录 输入 完毕 后再对 索引 表 进 行排序 ,排序后的 索引 表 和 主 文件一起

就 形成了索引文件。

例如 ,对 于 图 12.2(a) 所 示 的 数据 文件(假设 物理地 址 编号从 1 开始 ) , 主 关键 字 是 学

号; 排序 前 的 索引 表 如 图 12. 2(b) 所 示 ( 假设物理 地 址 编号从 10 开始); 排序后的索引表如

图 12.2(c)

所 示 ( 假 设物理地址 编号从 10 开始) 。图 12. 2(a)和图 12. 2(c) 一 起 形成了 一 个

索引 文件 。

物理地 址 | 学 号 | 姓名 | 其他

物理 地 址 | 关键字 | 物理地址

物理地 址 | 关键字_| 物理地址

1|

2|

3|

4|

5|

1

5

3

地 明

于 平

张 萍

8 | 陈强

4

马 伟

10

11

12

13

14

1

5

3

8

4

1

2

3

4

5

10

11

12

13

14

1

3

4

5

8

1

3

5

2

4

(a) 数据 文件

(b) 排序 前 的 索引 区

(c) 排序后的 索引 区

图 12.2 索引 文件示例

检索 分 两步进 行,首先 将 外存上 含有索引 区 的 物理 块 送入内 存 , 查 找 所 需 记 录 的 物理 地

Sa

址 ,然后再 将 含有该 记录 的 物理 块 送入内 存。若 索引 表 不 大 , 则 可 将 索引 表 一 次 读人内 存 ,

因此 在 索引 文件中 进行 检索 只 需 两 次访问 外 存 , 即一次 读 索引 、 一 次 读 记

录。由 于 索引 表 是有序 的 ,所 以对 索引 表 的 查找 可 用 顺序 查找 或二分 查找

等 方法 。

索引 文件的 更 新操作 也很 简单 。在插入 时 将 搬入记录 置于数据 区 的 末

尾 , 并 在 索引 表 中 搬 和人索引 项 ; 在 删除时 删去相应 的 索引 项 ; 若 要修改主关

417

数据 结构 教程

虹 第人5 【版

键 字 , 则 必须 同时 修改 索引 表 。

当 记 录 数 目 很 大时 ,索引 表 也很大,以至于 一 个 物理 块容纳 不 下。在 这 种 情况下查阅 索

引 仍 要 多 次 访问 外 存。为 此 可以 对 索引 表 建立一 个 索引 , 称 为查找 表 。

上 节 介绍 的 索引 非 顺序 文件 适合于 随机 存 取 , 这 是 由 于 主 文件 是 无 序的,顺序存取 将 会

频繁 地 引起 磁头 移动,因此 索引 非 顺序 文件不适合 于顺序存取 。 而 索引 顺序 文件 的 主文件

也 是有序的,所 以 它 既 适合 于 随机 存 取 , 也 适合 于顺序 存取。 另 外 ,索引 顺序 文件由于 主 文

件 是 按 主 关键字有 序 的 ,因此 索引 表 采 取 稀 朴 索 引 , 占 用 的 空间较 少 。它 是 常用 的 一 种 文件

组 织 结构。本 节 将 介绍 两 种 最 常用 的 索引顺序 文件 ,即 ISAM 文件和 VSAM 文件。

1231 ISAM文件

ISAM 是 索引 顺序 存 取 方法(indexed sequential access method) 的 英文 缩写 。ISAM 文

件 是 一种采用 静态 索引 结构 的 磁盘 存 取 文 件 。由 于 磁盘 是 盘 组 、 柱 面和磁道 的 三级地 址 存

储 设备,因此 对 磁盘 上 的 数据 文件 建立盘组 、 柱 面和磁道多级 索引 。ISAM 文件 由以下 3 个

部 分组 成 :

全 革 林 数据 区

由 一 个 或 多 个 柱 面 组成,文件的记录 按 关 键字有 序 存放 于 柱 面 的 每个磁道上 。

2 省出区

每 个 柱 面都开 一 个 溢出 区 ,为插入 记录 而 设 。当 一 个 磁道 存 满记录 以 后 ,如 果 要 在 该 磁

道 插 入记录 ,就 将 该 磁道 的 最后一 个 记录 移 至 溢出 区 ,再 将 新记录 插 在 此 磁道 的适当位 置 。

每个磁道的溢出数据在溢出 区 中组 成链表。

3 多级 索 5|

多 级 索引 都 采用 稀 朴 索引 ,各 级 索引 的 结构 如 下 :

1) 磁道索引

其 包括 基本 索引项和 溢出 索引 项。基 本 索引 项 含本磁道 的 最大关键 字 及 起 始地址 ; 滋

出 索引 项含本 磁道溢出记录 的 最 大 关键 字 及 本 磁道 游出区 首 地 址 。

2) 柱 面索引

索引 项 包含 柱 面中的最大 关键 字 和 该 柱 面 磁道 索引 的 起 始 地 址 。

3) 主 索引

主 索引 是 柱面索 引 的 索引 。 每个索引 项 包含 柱 面 索引 中 一 组记录 的 最 大 关键 字 及 该 柱

面 索 引 组 的 起始地 址。检 索时 由 高 级 索引 到低级 索引 逐 级 查找 ,找到 待 查记 录 所 在 的 磁道

后 再 到 此 磁道中 查找 待 查记录 。

图 12. 3 所 示 为存放 在 盘组上 的 一个ISAM 文件的例子。因 柱 面 基 本 区 中 的 主 文件 按

关键字有 序 ,因此 可 对 每个磁道上的 记录 建立一个 磁道 索引 项 ,一 个 柱 面上的所有 磁道索引

项 形成一个 磁道 索引。然 后 对 每个磁道 索引 块 (即 同属一个 柱 面 的 磁道 索引 块)建 立一个 柱

面 索 引 项 , 盘组上 对 应 主 文件 的所有 柱 面 索引 项 形成 柱 面 索 引

。 若 柱 面 索 引 较 大 ,再 建立称

为 主 索引 的 柱 面 索 引 的 索引。此 例只有 一 级 主 索引 , 若 文件 的 柱 面 索 引 很大 ,使 得 一 级主索

引 也 很 大时 , 主 索引 可 建立多 级 。当 然 , 若 柱 面 索引 较小,也 可 不 建 主 索 引 , 以 减小 索引

高度。

418

CT

| |

柱面C

磁道 索引

孔

CoT一Co 广| 20

人

Ro| Ros| Ri| Re|Ro| 也

三 而

32

60

人| 一定RPR | Rs| 及 Ra

站 基本区

|

入 门生 Ras| Rs | Rs6| Reo

柱面溢出区

Co

280
5

贡
柱 面C>
| 了本 门 一 | 厂区

C27Tm

四

1

主 索引

5

3530

一一 3000

一 70

人

R6s | R6s | Re6|

Res| Rzo| 也

81

140

人|一= Rp | Ra Rs| Re Rs

下

基 本 区

|

和 门宅 Rsl| Ri3s| Rias|Rao

柱面溢出区

Co7o

柱面Cn

4010 | 一-一一 3500

人

FE | |

磁道 索引

克
Rasei|Ra4o3|R34e6| Ra4es|Rasoo| 刀

柱 面 索引

3610

人 |一一Raoo|Racol| Reos|RaeosjRacto| 7 基本区

4010 人 门 e Raoo3| Raoo6| Raoor|Raon

柱面溢出区

图 12.3 ISAM 文件 结构 示例

由图 12. 3 可 见 ,每 个 柱 面 分 为 磁道 索引 区 、 基 本 区 和 溢出 区 3 个 部 分 。磁 道 索引 区用

来存放 该 柱 面 的 磁道 索引 ,通常规定该柱 面 最 前 面的磁道Te。

为 磁道 索引 区。由 i 开始的

若干个磁道用 来存放 主 文件 的 记录 , 称为基本 区 。 每 个 柱 面 最 后 若干个磁道 称 为 溢出 区 。

每个柱 面 的 溢出 区 由 该 柱 面 基本

区 中 的 各 个 磁道 共享 。洪 出 区 为有序 链表 结构 ,简称 浇 出

链表。

关键字 | 指针 “| 关键字 | 指针

每个磁道 索引项有 4 项 ,即 基 本 索引 项 关键 字 、 基

本 索引 项 指针 溢出 索引 项 关键字和 溢出 索引 项 指针 ,

基本 索引 项

溢出 索引 项

其 结构 如 图

12.4 所 示 ,其中 基本 索引 项 关键 字 为 对 应

图 12.4 磁道 索引 项 结构

磁道在基本

区 中 最 末 一 个记录 的 关键 字 ( 即该磁道 的

最大关键字) ,基本 索引 项 指针 指示 该 磁道中 第 一 个 记

录 在 基本 区 中 的位 置; 浇 出 索引 项 关键 字 为 对 应 洪 出 链表 的最大 关键 字 , 溢 出 索引 项 指针

每个柱 面 索引项有 两 项 ,即关键字和指针 。 关 键 字 为 对 应 柱 面 (即对 应 磁道 索引 块)中

最后一 个记录 的 关键 字 ( 即 该 柱 面 的最大 关键 字 ) ,指针 指示 对 应 柱面上 的 磁道 索引 首 地 址 。

如 前 所 述 ,磁道 索引 放 在 对 应 柱 面 的 第 一个 磁道 , 即 指针 指示 对 应 柱 面 第 一个磁道中磁道索

引 的 起 始 地 址 。

419

数据 结构 教程

虹 第 5 【版

在 数据 文件 初始 建立时 ,磁道 索引 的 溢出 索引 项 均 为 空,各 个 柱 面溢出 区 也 均 为空。

图 12. 3 所示的 ISAM 文件 就 是 一个这 样 的 例子 。当 有 新 的 记录 插 和人时 需要 重组 某 个 磁道

的 记录 ,并 将 该 磁道 最后一 个记录 移 人 该 柱 面的溢出 链表 中 ,同时 修改对 应 磁道 索引 的 基本

索引 项 和 溢出 索引 项 内 容 。

例如 ,依次将记录 Rs、R 和有Rx插入到图12. 3 所 示 的 文件中之后 ,柱面C, 的 磁道 索引

及 Cs。 柱 面 中 主 文件记录 存储位 置 的变化 情况如 图 12. 5 所示。当 插入 Re 时 ,由 于关键字

排序有 63一64 一65 ,所 以 应 将 它 插 在 C, 柱面Th 磁道上第 二 个记录 的 位 置上 ,而 T 磁道上

从 记录 Re 开始 的所有 记录 依次 后 移 一 个位 置,于 是 磁道上的 最 后 一 个记录 Rn 被移人

流出 区。由于 们 磁道上的 最 大 关键 字 由 70 变 成了 68, 它 的 溢出 链表 也 由 空表变 成 为含有

一 个 记录 Rn 的 链表 ,因此 将 磁道 索引 中 对 应 磁道 索引 项 中 的 基本 索引 项 关键字由 70 改成

68 ,将 溢出 索引 项 关键 字 置为 70 ,并 将 溢出 索引 项 指针 指向 Cs 柱 面 溢出 区 中 记录 Rn 的 起

始 地 址。插入记录 Ra和 Rzxe 的 过 程和上 述插入 记录 Ru 的 过 程 类似 , 只 是游出 链表 要求有

序 , 所以 先后由基本 区 移 人 洲 出 区 的 记录 Rs 和 R 要 有 序 存放 。

CT

6
全

140

70
下

人

磁道 索引

柱 面 C

磁道索引

7

| Ra | Ri

Rs | Re | Res
Ra | Rn | Ri | Rs | Re

|
|厂 基本区

入

本 Rao| Ra | Ra6c|
[|Rzo|AlRs AR

Ras | Rao

人

人 | 桂面溢出区

图 12.5 ISAM 文件 记录 的 插入和 溢出处理

在 ISAM 文件中 删除记录 的 操作 比较 简单,只 要 找到 待 删除 的记录 ,在 其存储 位 置上

加 一 个 删除标志 即 可 ,而 不需要 移动记录 和 修改 索引 。

记录 检索 有 成功和 失败 两 种 情况。在 ISAM 文件中记录 检索 成功时 的 检索 路径有 下

面 两种,

(1) 若被检索记录 在 某 柱 面的基本 区 中 , 则 检索 路 径 为 主 索引 一 柱 面 索引 一 某 磁道索

引 一 某 柱 面 基 本 区 中 某 磁道有序 表 的 顺序 扫描 。

(2) 若被检索记录 在 某 柱面的 溢出区中 , 则 检索 路 径 为 主 索 引 一 柱 面 索引一某 磁道索

引 一 某 柱 面有序 溢 出 链表 的 顺序 扫描 。

在 ISAM 文件中记录 检索 失败时 的 检索 路 径也有 两种 :

(1) 主 索引 一 柱 面 索引一某 磁道 索引 一 某 柱 面基本 区 中 某 磁道有序 表 的 顺序 扫描一检

索 失 败 。

(2) 主 索引 一 柱 面 索 引一某 磁 道 索 引 - 某 柱 面有序 溢出 链表 的 顺序 扫描 一 检索 失败 。

例如要在图 12. 3 所 示 的 文件中 检索记录 Res , 先 查 主 索引 , 因 65 近 280, 所 以 进入柱 面

索引 的 第 一 个 索引 块; 因 65一140, 又 进入磁道 索引 的第二 个 索引 块; 因 65一70,又进入 C。

柱 面的Ti 磁道; 对 Ti 磁道按有 序 顺 序 表 法 查找 ,检索 到 记录 Res 后 成 功

返回。又 例如要在

图 12. 3 中 部 分修改成图 12. 5 所 示 的 ISAM 文件中的 检索记录 Rn , 先 查 主 索引 , 因 70一

420

EM2sS 文 件 |

280, 所以 进入柱 面 索引 的 第 一 个 索引 块; 因 70 过 140, 又 进入磁道 索引 的 第 二 个 索引 块 ,

70 和 70,又进入 C, 柱面 六 磁道浇出链表; 对 该 洪 出 链表 按 有 序 链表 法 查找 ,检索 到 记录

Rn 后 成 功返回 。

在 ISAM 文件 中经过多 次记录 增删 后 文件 的结构 可 能 变得 很 不合理 ,此 时 大 量 的记录

进入 游出区 ,而 基本 区 中 又 浪费了很 多 的 空间 ,因此 通常需要 周期性地 整理ISAM 文件,把

记录 读 和人内存 重 新排列,复制 成一个 新的ISAM 文件 , 填 满 基本 区 而 空出溢出 区 。

1232 VSAM 文件

VSAM 是 虚拟 存储 存 取 方 法 (virtual storage access method) 的 英文 缩写 。、VSAM 文

件 是 一种采用 虚拟 存储 存 取 方法的 文件 。VSAM 文件 的 存储 单位是 控制区间 和 控制 区域,

这 是 一些逻 辑 存储 单位,与 柱 面、磁 道 等 实际存储 单位并 没有必然 的

联系 。用户在存取

VSAM 文件的记录 时 不 需要 考虑 该记录 的 当前位 置 是在内 存 还是在 外存, 也 不 需要 考虑 何

时 执行 对 外 存 进 行 读 写 的 命令。可 见 , 这 种 文件较ISAM 文件更 方便 用 户 使用 。

就 文件的 组 织 方式 来 说,VSAM 文件和 ISAM 文件的相同 点 是 都是索引顺序 文件组织

方式,其不同点是ISAM 文件 采用 静态 索引 结构 ,而VSAM 采用 B 十树的 动态索引 结构 。

有关 B 十 树 的概念已在第 9 章 介绍 ,这 里 不 再讨论 。

图 12. 6 所 示 为 一个VSAM 文件 的 例子, 它 由 数据 集 \顺 序集和 索引 集 3 个 部 分 组 成 。

root 随 机 查找
|

24 59 85

be 9

ee

了
33 44 59
ea
9

波空

B+

15

24

| [一顺

2 和4-Pp53033]-67 40 4 57 5 6中-3 85A|)

9 1

-7

4

9 9

二 站二
图 国
1
9
(--- |

加 国外 了 辐 同
37||4o||44
33|
24

同同加 加
65
57

同 耻
3

了

加

引 和

序

申 蓝
集

sl
屈 |
二
时,
用
技 1

67

85
四

?|

榨 制 区域

控制区间

图 12.6 VSAM文件结构举例

(1) 数据集: 一 个 结 点 称 为一个 控制 区 间 , 它是 7O 操作 的 一 个 基本 单位。文件的 记
录 存 放 于数据集中。 一 个 控制区 间 除存放 一 个或多 个记录以外,还 包含有记录 的 控制信息

am

和 区 间 的 控制信息 , 且 每个控制 区间 留有空间 ,为 插入记录 时 备用 。

(2) 顺序集: 存放每个控制区间 的 索引 项 ,一 个 索引 项 包含该控制区间 的最大关键字

和 指向区间的指针。若干个控制 区间 的 索引 项 组 成 顺序 集中 的 一 个结 点 , 结点之 间 用 指针

链接 ,使 整个顺序 集 形成一个 链表。顺 序 集中 一 个 结点和 与之对 应 的 控制区 间 组 成一个 控

制 区 域 。

03) 索引集: 每 个 顺序 集 的结 点又在其上 一 层 的 结 点 中 建立索引 , 且 逐 层向上 建立 索

421

数据 结构教程

[第! 5版

引 , 每个索引 项 都 是由下 层 若 干个结 点 的最大 关键字和 指向 这 些 结 点 的 指针 组 成 。这 些 上

层 的 索引 组成了 索引 集。它们 是 B 十 树 的非 终端 结 点 ,与 顺序 集 共 同 构成 一棵 B 十 树 ,作为

文件的索引部分。

VSAM 文件 的记录 均 存放 在 数据集中 (其 中 的 一 个 结 点 就 是 一个控制 区间 ) ,每个控制

区 间 存放有 若干个按 关 键字有 序 排列 的 记录 。 控制区间 的 大小 可 随 文件 的不同 而 不同, 但

同一 文件 中 控制 区 间 的 大 小 相同 。顺 序集和 索引 集 一 起 构成 一棵 B十树, 为有序记 录 的 索

引 。 顺 序集和索引集中的所有 索引 项 都由关键字和 指针两部分组成。每个控制 区间 在 顺序

集中 都有一 个 索引 项 ,其 关键 字 为 控制 区间 中 记录 的最大 关键 字 , 其 指针 为 该 控制 区间 的 首

地 址 。顺 序集中 的 一 个 结点和 对 应 的 若干个控制 区间 组 成 的 部 分 称 为 控制 区域。每个控制区

间 可 看 作 一 个逻辑 磁道 ,每个控制 区 域 可 看 作 一 个 逻辑 柱面,而 控制 区间相当 于 一 个磁道。

与 ISAM 文件 不同的 是,VSAM 文件不设溢出 区 ,解决 记录 插入 的 方法 是 在 文件初始

建立时留下 一 定 的 空间。预 留空间 使用两 种 方法 ,一 种 方法 是 每个控制区间 初 建时不 填 满

记录 ,如 图 12.6 中 的 控制 区间 定 义 为存放 3 个记录 ,而 初 建 时 每 个 控制区间 最 多 只 放 两 个

记录; 另 一 种方法是在 每个控制 区 域 中 留有一些全 空 的 控制 区间 ,图 12. 6

中 有 一 个 这 样 的

全 空的控制区间。

在 VSAM文件中记录插入有 4 种 情况 :

(1) 新 记录 能 直接 插入到 相应 的 控制 区间 中 ,但 需要 修改 顺序集中 的 索引 项 。

(2) 新 记录 插入 的 控制 区间 未 满,但 需 把其中 关键字大 于 插 和人记录 关键 字 的记录 后 移 。

(3) 新 记录 要 插入 的 控制 区 间 中 记录 已 满,此时 要 进行 控制 区间 的 分 裂 ,即将 近 一 半 的

记录移到同一控制区 域中全 空的控制 区间 中 ,并 修改 顺序集中 相应 的 索引 。

(4) 新 记录 要 插入 的 控制 区 域中已 没有全 空的控制 区间 ,要 进行 控制区 域 的 分 裂,此 时

顺序 集中 的 结 点 也 要 分裂。

记录 的 删除过 程 与 插入过 程相反 , 当 要 删除记录 时 先 查找 到 该记录 ,然后将 该记录 右面

的 记录 顺 次 左 移以 使 空闲 空间 连续 ,同时 删除相应 的 控制信息。若 删除 后 该 控制区间 不 再

含有记录 , 则 回收 做 空闲 空间 使用,同时 删除 顺序集中 相应 的 索引 项 。

与 IJSAM 文件相比,VSAM 文件具有以下优点: 四 动态地 分配和 释放 存储 空间,@ 不

需要 对 文件 进行 重组; @@插入新 记录 后对 新 记录 的查找时间 和 对原有 记录 的查找 时 间

相同。

基于 B 十 树的VSAM 文件通常作为大型 索引 顺序 文件 的标准 组 织 方式 。

哈 希 文件

兴

哈 希 文件(hashed file) 也 称为散 列 文件,是 利用 哈 希 存储 方式 组 织 的 文件 ,也 称为直接

存 取 文件 。它 类似 于 哈 希 表 , 即 根据 文件中 关键 字 的 特点设计 一 个 哈 希 函数和 处 理 冲 突 的

方法 ,将 记录 哈 希 到 存储 设备上 。

与 哈 希 表 不 同 的是,对 于 文件 来说,磁盘上 的 文件记录 通常 是 成 组存放 的 ,若干 个记录

组 成 一个存储 单位 ,在 哈 希 文件 中 这 个 存储 单位 叫桶(bucket) 。 假 如 一 个 桶 能 存放

个记

录 , 则 当 桶 中 已有疡 个同义词的记录时存放 第疡十1 个同义词会发生*浇出”。处 理液出 虽

422

EM2sS 2 文 件 |

然 可 采用 哈 希 表 中 处 理冲突 的 各 种 方法,但 对 哈 希 文件而 言 主要 采用 链 地 址 法 。

当 发生 * 溢 出?时 ,需要将第 记 十 1 个 同义词存放 到 另 一 个 桶 中 ,通常称此 桶为“ 游 出

桶>。相 应 的 , 称 前 疡 个 同义词存放 的 桶 为“ 基 桶”。 洪 出桶和 基 桶 大小相同 ,相互 之 间 用 指

针 链 接。当 在 基 桶 中 没有找到 待 查记录 时 就沿着指针 到 所 指 溢出桶中 进行查找 ,因此 希望

同一 哈 希 地 址 的 溢出桶和 基 桶 在 磁盘 上 的 物理 位 置不要 相距 太 远 ,最好 在 同一 柱 面上 。

【例12.1〗 某 一 文件有 20 个 记录 ,其 关键 字 集 合 为 (2,23,5,26,1,3,24,18,27,12,7,

9,4,19,6,16,33,11,10,13)

,桶的容量 一 3, 桶 数 2 一7, 用 除留余数 法 做 哈 希 函数 刀 (key)一

key%7,
给出对应的哈希文件。

对 应 的 哈 希 文件如 图 12.7所示。

桶 编号

基 桶

溢出桶

0|7

1

1|

2|

人

入

2123|19| 一 16

和人

3|3|124|10| 和

4|11814101A

5|5|126112| 十二 19|33|

|入

6|27|16193| 和

图 12.7 了哈 希 文件示例

在 哈 希 文件中进行查找时 首先 根据给定 值 求出哈 希 桶的地 址 ,将 基 棚 的记录 读 人 内 存 ,

进行 顺序 查找 , 若 找到 关键 字等于 给 定 值的记录 , 则 检索 成功; 否则 , 读 人 洪 出 桶 的 记录 继

续 进 行查找。

在 哈 希 文件中删 去 一 个记录 仅 需 对 被 删记录 做 删除标记 即 可 。

哈 看 文件的 优点 是 文件随机 存放 ,记录 不 需 进行 排序; 搬入 删除 方便;

存 取 速度快;

不 需要 索引 区 ,节省 存储 空间。其 缺点是不能 进行 顺序存取 , 只 能 按 关键 字 随 机 存 取 , 且 询

问 方式限于 简单询问 ,并 且 在 经 过 多 次插和人 \ 删 除后也 可 能 造成 文件结构 不 合理 ,需要 重新

组织文件。

以上各 节 介绍 的 都是只 含 一 个主 关键 字 的 文件 。 为了提高 查找 效率 ,还 需要 对 被查询

的 次 关键 字 建立相 应 的 索引 ,这 种 包含有多 个 次 关键 字 索 引 的 文件 称 为多关键 字 文件

(Cmultiple key file)。次 关键 字 索 引 本 身 可以 是 顺序 表 , 也 可以 是 树 表。下 面讨论两种多关

键 字 文件 的 组 织 方法 。

1251 多 重 表 文件

要-

多 重 表 文 件(multilist file) 是 将 索引 方法和 链接 方法相结合 的 一种组

423

数据 结构 教程

眶 第人5 【版

织 方式,它 对 每 个需要 查询 的 次 关键 字 建立一个 索引 ,同时 将具有 相同 次 关键 字 的记录 链接

成一个 链表 ,并 将 此 链表 的 头指 针 、 链 表 长度及 次 关键字作 为 索引 表 的 一 个 索引 项。通常,

多 重 表 文 件 的 主 文件是 一 个 顺序 文件 。

【例12.2〗 图 12. 8(a) 是 一 个 多 重 表 文件 的示例 , 主 关键 字 是 学 号 ,次 关键 字 是 性 别 、

民族 和 班号,设计 对 应 的 多 重 表 文件 。

设计 3 个 链接 字段 ,分别 将具有 相同 性别`.民 族和 班号的记录链在一起,由 此 形成

的 性 别 、 民 族和 班号索引 见图 12.8(b).图 12.8(c)和图 12.8(d) ,有 了 这 些 索引 便于 处 理 各

种 有 关 次 关键 字 的 查询 。

物理 地 址 | 学 号 | 姓名
李 明

1

1

2|
3|
4
5

5
3
8
4

王 平
陈强
张 萍
马伟

性别
男

男
男
女
男

民族
汉族

汉族
渭 族
汉族
回族

班 号
99101

99101
99102
99101
99102

性别 链
2

民族链
2

班 号链
2

3
5
人
人

4
人人
人
和人

4
5
人
人

(a) 多 重 表 文 件

次 关键字 | 头指针 | 链长

次 关键字 “| 头指和

男
女

1
4

4
1

汉族
满族
回族

1
3
5

链 长
3
1
1

次 关键 字 头指针 “| 链长

99101
99102

1
3

3
2

(b) 性 别 索引

(c) 民族 索引

(d) 班 号 索引

图 12.8 多 重 表 文件示例

多 重 表 文 件在检索时 同样 先 查 询 索引 表 , 然 后 在 主 文件 中 读 出 待 查记 录 信息 ; 插入时

如 果 不 要 求 保持链表 的 某 种 次 序 , 则 可 将 新记录 插 在 链表 的 头 指针 之 后; 删除记录 时 比较

烦琐 ,需要 在 每个次 关键 字 的 链表 中 删 去 该记录 。

1252 倒 排 文件

倒 排 文 件Cinverted file) 和 多 重 表 文 件的区 别 在 于具有 相同 次 关键 字 的记录不进行链

接 , 而 是在相应 的 次 关键 字 索 引 表 的 该索引 项 中 直接 列 出 这 些记 录 的 物理 地 址 或记录 号 。

这 样 的 索引 表 称 为 倒 排 表 , 由 主 文 件和倒 排 表 共 同 组 成 倒 排 文 件 。

【例12.3】 设计 与图12.8(a)

对 应 的 倒 排 文件 。

将图 12.8(a)

所 示 的 多 重 表 文 件去掉 3 个 链接 字段后作为 主 文件,所 建立 的 性 别 、

民族 和 班号倒 排 表 分别如图 12. 9(a)、图 12. 9(b) 和 图 12. 9(c)所示 , 倒排表和 主 文件一起 就

构成了倒排文件。在 这 些 倒 排 表 中 ,各 索引 项 的 物理 地 址 是 有序 的 ,也 可以 将 这 些 物 理 地 址

按 主关键字 有 序 排 列 。

次 关键 字

男

女

物理地 址

1.2,.3.5

4

次 关键 字

汉族

满族
回族

物理地址

1.2,4

3
5

次 关键 字 物理地址

99101

99102

1.2.4

3.5

(a) 性 别倒排 表

(b) 民族倒排表

(c)

班 号 排 表

图 12.9

3 个 倒 排 表

424

EM2SJ文 件 |

倒 排 文件的 主要 优点是检索 记录 较 快,在处理 复 杂 的 多 关键 字 查询 时 可 在 倒 排 表 中 确

定 记 录 是 哪个 或 哪些 ,继而 直接 读 取 之 ; 倒 排 文件的 缺点 是 维护 困难 ,在 同一 个 倒 排 表 中 不

同 关键 字 的记录 数 不同,各 倒 排 表 的 长度也 不 等 。

一 本章小结 一一一

本 章 的 基本 学 习 要 点如 下 :

(1) 理解 文件的基本概念 。

(2) 掌握各 种 文件 的结构 ,包括 顺序 文件.索引 文件

.索引顺序 文件、哈 希 文件和多关键

字 文 件 等 。

1. 什么 是文件 的 逻辑记录 和 物理记录 ? 它们 有 什么 区 别 与 联系?

2 比较 顺序 文件 索引 非 顺序 文件.索引 硕 序 文件和哈 希 文件 的 存储代价 、 检 索 、 插 入

及 删除记录 时 的 优点和 缺点 。

3. 某职 工 表 文 件如图 12. 10 所 示 ,其 中 以职工 号 为主关键 字 。

物理地 址 | ”职工号

姓名 | 年龄 | 性别 | 工作 时间

1

2

3

4

5

6

7

105

125

108

182

135

116

140

李 华

王 丽

张 英

陈 军

吴 滤

章 东

华 明

36

42

28

52

25

58

40

男

女

男

男

男

女

男

图 12. 10 ”一个职工表

1997.7

1984.7

1998.7

1970.9

1999.9

1965.9

1989.7

职称

副教授

副教授

讲师

教授

助教

教授

讲师

(1) 若将职工 文件组织 成 顺序有序 文件 ,请 给 出 文件的 存储 结构 。

(2) 若 将 该 文件组 织 成 索引 非顺序 文件 ,请 给 出 其 索引 表 结 构 。

(3) 若 将 该 文件组织 成多重 表 文件 ,请 给 出 主 文件 结构 及 性 别 索引 ,工作时 间 索 引 ( 只

考虑 年 份)及 年 龄 段(10 岁 为 一 个 年 龄 段)索 引 。

(4) 若 将 该 文件组 织 成 倒 排 文件 ,请 写 出 性 别 索 引 、 职 称索引 及 年 龄 段 索 引 , 组 织 索 引

要求同(3) 。

实验题 1: 实现学 生 记 录 文 件 的创建和查找 基本 操作

目的: 领会 C/C++ 文 件的基本 操作 及 其 算法设计 。

内容, 有 若干 个学生成 绩记录 如 表 12. 1 所 示 ,假 设 它们 存放 在 st 数组中,设计一个程

数据 结构 教程

[第! 5人版

序 exp12-1. cpp 完成以下功能。

(1) 将 st 数组中 的 学生记录写和人到 stud. dat 文件中。

(2) 在 stud. dat 文件 中 查找 并 显示 指定学生 序 号 的 学 生记 录 。

(3) 在 stud. dat 文件 中 查找 并 显示 指定学生 学 号 的 学 生记 录 。

学 号

1

5

8

3

2

企

7

6

姓名

陈 华

张 明

王 英

刘 丽

许可

陈 军

马 胜

曾 强

表 12.1

学生成绩表

年 龄

性 别

语文 分

数学 分

英语分

20

21

20

21

20

20

21

20

男

男

女

女

男

男

男

男

78

78

86

78

80

78

56

78

90

68

81

92

83

88

67

89

84

92

86

88

78

82

75

82

民 设计 性 实验

实验题2: 实现学生 记录 文件 复杂 的 基本 操作

目的: 掌握 文件的 基本 操作 及 其 算法 设计 。

内容 : 有 若干个学 生成 绩记录 如 表 12. 1 所 示 ,假设 它们存放 在 st 数组中,设计一个各

序 exp12-2. cpp 完成以下功能。

(1) 将 st 数组中 的 学生记录写和人到 stud. dat 文件中。

(2) 将 stud. dat文件中的所有学4

上记录读入到 st 数组中 。

(3) 显示 st 数组 中 的所有 学 生 记 录 。

(4) 将 st 数组的学生记 录 复 制

到 stl 数组中,并对 stl 数组 的所有 学 生 记录 求 平均 分 。

(5) 对 stl 数组 的所有 学 生记 录 按 了

均分递减排序。

(6) 将 stl 数组 中 的 学 生 记录 写人 studl. dat 文件。

(7) 将 studl. dat 文件中 的 学生记录 读 人 到 stl 数组中。

(8) 显示 stl 数组 中 的学生记 录 。

实验题3: 实现 索引 文件 的 建立 和 查找 算法

目的: 掌握 索引 文件的基本 操作 及 其 算法设计 。

内容: 编写一个程序exp12-3. cpp,建立表 12. 1 中 学 生成 绩记 录 对 应 的主 文件data.

dat', 要 求 完成 以下功能 。

PE

(1) 输出主文件中的学4

上 记录。

(2) 建立 与主 文 件相对 应 的 索引 文件 ,其 中 每 个记录 由 两个字段 组 成 ,即 学号no 和该

学 生 记 录 在 数据 文件中的相应位置offset。 索 引文 件 中 的记录 按 学 号 no 升序 排列 。

(3) 输出 索引 文件的全 部记录 。

(4) 根据 用 户输入 的 学号在 索引 文件中 采用 折 半 查找 法 找到 对 应 的 记录 号 ,再通过 主

文件输出 该记录 。

426

数据 结构 课程 的 核心内容 是 培养学生 分 析 数据` 组 织数据的能

力 ,

其 目的 是编写 高质量 的 程序 。 程序 设计 主要有 结构 化 方法和 面

向 对 象 的 方法, 目前 面向对 象 的 方法 已 成 为 软件开发的主流 方法 。

前 面 各 章 都是采用 结构 化 方法 描述 算法 。

本 章 介 绍 采 用 C++ 面向 对 象 程序 设计 的 概念和 描述 数据结构 基

本算法的过程, 为 更 高 层次 地 开发数据 处 理 软件打下 扎实 的 基础 。

数据 结构教程

[第! 5版

面向对 象 的概念

洒

计算 机程序是计算 机 处 理 对 象和计算 规则 的 描述。程 序 设计 语言是用 来描述 计算 机 事

务 处理过程. 便 于计算 机 执行的规范 化 语言。

在出现 高 级 语言 之后,如何用 它 来编写较大 的 程序 呢? 人 们 把程序 看 成 是处理 数据 的

一系列 过 程 。过 程 或函数定义 为 一个接 一个顺序 执行 的 一组指令。数 据 与 程序 分开存储 ,

程序 设计 的 主要 技巧在于追踪哪些 函数和 调用 哪些函数 ,哪些 数据 发生了 变化。为 解决其

中 可 能 存在 的问题 ,结构化 程序设计 应 运 而生。 结 构 化程序设计 的主要 思想 是 功能 分 解 并

逐步 求精,也 就是说 ,当要 设计 某 个目标 系统时 先从代表 目标系统整体 功能 的 单个处理 着

手,自 顶向下 不断地 把复杂 的处理 分 解 为 子 处 理,这 样 一 层 一层地 分 解 下去,直到 仅剩下 若

干 个 容易处理 的 子处理 为 止 。当 所 分 解 出 的 子处理 已经十 分 简单,其 功能显而易见 时 ,就停

止 这 种 分解过程,对 每 个这样 的 子 处理用程序 加 以 实现。结构化 程序设计 仍然 存在诸多 问

题 ,例如 生产 率 低下`软 件 代码 重用 程度低` 软件仍然 很 难维护 等 。针 对 结构化 程序设计 的

缺点,人 们 提出 了 面向对 象 的程序设计 方法 。

面向对 象程序 设计 的 本 质 是 把 数据和 处 理数据 的 过程当 成 一 个 整体, 即 对 象 。面向对

象程序 语言 包含 下 面 一 些概念 。

人 对旬

昌 恒

对 象 是人们 要 进行 研究的任何实际 存在 的 事物 , 它 具有届 性(用 数据 来

描述) 和方法 (用 于 处理数据的算法 ) 。面向对 象 语言 把 属性和 方法封装 于
对 象 体之中 ,并提供 一 种 访问 机 制 ,使对象 的 <私有 数据" 仅能由 这 个 对 象的 机

方法 来 执行 。用 户 只 能 通过 向 允许 公开 的 方法 提出 要 求 (消息)才 能 查询和 修改对 象的状

态。 这样 ,对 象 属性的具体 表示 和 方法的具体实现 都是隐 项 的 。

2 一头

把众多 事物 归纳 、 划 分 成 一些 类,把具有 共性 的 事物划分 为一类 ,得 出 一 个 抽象 的 概念 ,

是 人 类 认识 世界 经常采用 的 思维 方法。类 是 面向对象语言必须 提供 的用户定义 的数据 类

型 , 它 将具有 相同 状态、操 作 和 访问 机 制的多 个 对 象 抽象 成 为 一 个 对 象类。 在 定义了 类 以

后 ,属于 这 种 类 的 一 个对象叫作 类 实例 或类对 象 。一 个 类 的 定义 应 包括 类 名 、类 的 说明和 类

的 实现。

E

PE

继承 是 面向对 象语言的另 一 个 必 备 要 素。类 与 类 之 间 可以 组 成 继承 层次 ,一 个 类 的 定

义 ( 称 为子类 ) 可 以 定义 在 另一个 已定义 类 ( 称 为 父类) 的 基础上。 子 类 可 以继承 父类中 的 属

性 和 操作 ,也 可 以 定义自己 的 属性和 操作 ,从 而使内 部 表示 上 有 差异 的对 象 可 以 共享 与 它们

结构有共同 部 分 的有关 操 作 ,达到 代码重用 的 目的 。

下 冰 忌

对 象 引 用 一 个 方法的过 程 称 为 向 该对 象发送一个 消息 ,或 者说 一个对 象接收 到 一 个 服

务 请 求

。消 息是对 象 之间 交 互的手段 。

428

[第人131章)

采用 面向对 象 的 方法描述 算法

通常人 们 定义 面向对 象二对象十类 十 继承 十消息 。

面向对 象方法 的 主要 优点如 下 :

人 大头 本 |呈亲 二 从方式一珀

结构 化 程序设计 是 面向过 程的,以 算法 为 核心,把 数据和 处 理 过 程 作为 相互 独立 的

部分。面向对 象 程序设计以 对 象为中 心 ,对 象 是一个 统一 体 , 它是由 描述 内 部 状态 表示

静态 属性 的 数据以 及 可 以对 这 些 数据 施加 的 操作 封装在 一 起 所 构成 的 。面向对 象设计

方法是对问题领域进行 自然 分解 ,确定 需要 使 用 的对象和 类 ,建立适当 的 类 等级,在 对 象

之间传 递 消息 实现 必要 的 联系,从 而 按照 人 们 习惯的思维 方式建立 起问题 域的模型,模

拟 客观 世界 。

2 可 重用 件 好

面向对 象 的软件技术 在 利用 可 重用 的 软件 成分构造 新的软件系统时 有很大的 灵活 性 。

有 两 种 方法可以重复 使用一个对 象 类 ,一 种 方法 是 创建该类 的 实例,从 而 直接 使 用它; 另一

种 方法是从 它 派生出一个 满足当前 需要 的 新 类。继 承 性 机 制 使 得子类 不 仅 可以 重用 其父类

的 数据 结构和 程序代码 ,而且可 以 在 父 类 代码 的 基础上 方便 地 修改和 扩充 ,这 种 修改 并 不 影

响 对原有 类 的 使用 。

可从扩作好

类 是 理想的模块 机 制 , 它 的独立 性 好 ,修改 一个类 通常 很 少会涉及 其 他 类。如 果 仅 修 改

一 个 类 的 内 部 实现 部 分 (私有 数据 成 员 或 成员函 数 的 算法),而 不 修改 该类的对 外 接口 , 则 可

以 完全 不 影响软件 的 其他 部 分。面向对 象 软件技术特有 的 继承 机 制 使 得 对 软件的修改和 扩

充比 较 容易 实现 ,通常只要 从 已有类 派生 出 一 些新类 ,无须 修 改 软件 的 原有成 分。面向对象

软件技术 的 多 态 性 机 制 使 得 扩充 软件 功能 时对 原 有 代码 所 需 做 的 修改 进一步 减少,需要 增

加 的 新 代码 也 比较少。所以 ,用 面向对 象方法 设计 的 程序具有很 好 的 可 维护 性 。

正 因为 面向对 象 程序 设计有 诸多 的 优点,所以程序 设计 方法 逐渐 由 结构 化 程序设计 发

展 为 面向对 象 程序设计 。

用 C++ 描述 面向对 象 的程序 深

C++ 是 一种广泛 应 用 的程序 设计 语言 ,它在 C 语言的基础上 扩展 了 面向对 象 的 程序设

计 特 点。最 主要 的 是 增加 了 类 功能 ,使它成 为 面向对 象 的 程序设计 语言,从 而 提高了开发 软

从 语言角度 来说,类 是 一种数据 类 型,而对 象 是具有 这 种 类 型的变量 。 扫-委

当有 int n 说 明之后,类 与对 象的关系如同 int 类 型 与变量 , 之间 的 关系 。

人 的 十 多

类 是 一种用 户 自 定义 的 数据 类 型 ,声明 类 的 一 般 格式如下 :

429

数据 结构教程

[第! 5版

class 类名

{

Private:

私有 数据 成员和 成 员 函数;

protected :

保护数据成员和成员函数;

public:

公有数据成员和成员函数;

) ;
各 个 成员函 数的实现;

其中,class 是 定义 类 的关键字。“ 类 名 ?是 一 个标识 符 , 用 于 唯一标识 一 个 类。一 对 大 括号

内 是 类 的 声明 部 分 ,指定 该 类 的所有 成 员。类 的 成员包含数据 成员和 成员函 数 两 部 分 。类

的 成员从访问权限 上 分有: 公有 的(public)、私有 的 (private)和 保护 的(protected)3 类 ,其

中 默认 为 private 权限。

【例 13. 1】 以下声明了一个Sample,

指出其私有和公有成员 。

class Sample

{

Private:

intx,y;

public:

// 定 义 类 Sample

//数据成员

void setvalue(int xl,int yl1);

// 成员函数

void display() ;

)

void Sample:

: setvalue(int xl,int y1){ x一xl;y一yl1;}

void Sample: : display()

{

)》

cout <<"x一"<< x <<",y一"<<y<<endl;

从 Sample 类 的声明看出,该 类 包含 两 个私有 数据 成员 z 和 y ,它们 都是 int 型的,

以 及 两 个公有 成 员 函数 setvalue()和 display()。该 类 的描述如图 13. 1 所示。

举区问如张六

类 Sample

sealue

<

|一 内 部数据成员

display

图 13.1

Sample 类 的 描述

类 的 成 员 函 数 对 类 的 数据 成员进 行操作 ,成 员 函 数 的 定义 体 可以 在 类 的 声明 体 中 ,也 可

430

[第人131章)

采用 面向对 象 的 方法描述 算法

是在类声明体外实现
以 在 类 的声明 体外 ,如 例 13. 1 中 的 成 员 函数 setvalue()和 display()

的。在 类 声明 体 中 定义 的 函数都是内 联 函 数。在 类 声明 体外 实现 的 函数 可以通过 在 函数 声

明和 定义 上 分 别 加 inline 来 表示 该函数是内 联 的 ,否则 不 是 内 联 函 数 。

在 类 的 声明 体内 定义成员 函 数 的 优点 是 使 整个类 集中 于 程序 代码 的同一 位 置,不利 的

方面 是 增加 了 类 声明 的 规模和 复杂 性 ,而 且 内 联 的 函数 代码 并 不 被相同 类 的对 象 所 共享 , 因

而 增 大 了 程序 的 内 存 开销 。

类 成员有 3 类访问权限 ,即公 有 (public)、 私 有 (private) 和 保护(protected) 。 声 明 为 公

有 的 成员可以 被 程序 中 的任何 代码访问 ; 声明 为科有 的 成员只 能 被类本 身 的 成员函 数 及 友

元类的成员函 数 访问 ,其 他 类 的成员 函 数 ,包括 其 派生 类 的 成员函 数都 不能 访问 它们 ; 声明

为保护的成 员 与私有 成员类似 , 只 是除了 类 本 身 的 成员函数和 声明 为 友 元 类 的 成员函 数 可

以 访问 保护 成 员以 外 ,该 类 的派生 类 的 成员也 可以 访问 。

这里需要先区 分 类 的 成员对 类 对 象 的可 见 性和 对 类 的 成 员 函 数 的可 见 性 的 不 同 。类的

成 员 函 数 可以 访问 类 的所有 成 员 ,没有任何 限制,而 类 的对 象 对 类 的成员 的 访问 是 受 成 员 访

问控制符制约的。例 如声明一个类 Samplel 如下 :

class Samplel

{

Private:

int i;

protected:

int j;

public:

int k;

int geti() { returni; }

// 类 的 成员函 数 可 以 访问 类 的私有 成 员

int getj() { returnj; }

// 类 的成员 函 数 可 以 访问 类 的 保护成员

int getk() { return k; }

// 类 的成员 函 数 可 以 访问 类 的公有 成 员

)

定义 该类的 一 个 对 象 s:

Samplel s;

其 成 员 访问 的 合法 性如 下 :

Si

// 非法,i 为 Samplel 的私有 成 员

访问,保护成员和
类 Samplel 具有 私有 成 员 i, 它 可以 由 类 Samplel 的 成 员 困数 geti()

公有 成 员 也 一 样 ,但 是 不能 通过 类 Samplel 的 实例 对 象来访问 类 Samplel 的 私有 成员 宇和

保护成员7 。

一 般 来 说 ,公有 成 员 是 类 的对 外

接口 ,而 私有 成员和 保护 成员是 类 的 内 部 实现 ,不 希望

外界了解。将 类 的 成 员 划分 为不同访问 级别 有 两 个好 处 ,一 是 信息 隐藏 ,即实现 的 封装,将

431

数据 结构教程

[第! 5版

类的内 部实现和外部 接口 分开, 这 样 使 用该类 的 程序不需要 了 解 类 的 详细 实现; 二 是 数据

保护 ,即将

类 的 重要 信息 保护起

来 ,以免其 他 程序不恰当 地 修改 。

1322 类 对 象

类 只 是 一 个 数据 类 型 ,为了使用 类 ,还 必须 定义 类 的 对 象 。在声明类时 扫一扫

系统 是 不 会给类 分 配 存 储 空间

的 ,只有 在 定义 类 对 象时才 会给对 象分配 相

应的内 存 空间 。

全 对 和 象 的定义格式

定义 类 对 象 的 格式如 下 :

类名 对象名表;

其 中 光 类 名 ?是 待定的 对 象所属 的 类 的名称 ,即 所 定义 的对 象 是 该类的对 象 .“ 对 象名表 ” 中

可以有 一 个或多 个 对 象名,多 个 对 象名之 间 用 逗号 分 隔。在 "对象名表 ? 中 可以 是 一 般 的对 象

名 ,还 可以 是 指向对 象 的 指针 名 ( 即 对 象 指针 ) 或 引用 名 ( 即 对 象 引用 ) ,也 可以 是对象数组 名 。

例如 ,在 类 Sample 声明 好 之后,以 下 语句 用 于 定义 它 的 对 象 :

Sample objl ,obj2, * pobj,obj[10] ;

其中,objl 和 obj2 是 一 般 对 象 名, pobj 是指向 对 象 的指针 ;obj 是 对 象 数 组 , 它有 10 个元

素 , 每 个 元 素 都 是 一个对 象 。

在 C++ 中 ,对 象 指针 、 对 象 引用 和 对 象 数组 的使用 方法 与 普通 指针 .引用 和 数组 类 似 。

类 对 象实例 化 就 是 分 配 类 对 象所指向 的空间 ,通过 new 运算符(类似 malloc 函数)实

现 ,例如 :

Sample * p 一 new Sample();

可 以通过 delete 运算符(类似 free 函数)释放其指向 的 空间 ,例如 ,

delete p;

2 对 象 成员的 表 个 方关

一 个 对 象 的成员 就 是 该对 象的类 所 声明 的 成员。 对 象 成员有 数据 成员和 成 员 函 数。一

般 对 象 的 成员表 示 如 下 :

对 象名.成员名

或者

对 象名 .成员名 (参数表)

前 者 用 于 表示 数据 成员, 后者用 于表示成员函数。这 里 的“. "是一个运算符 ,该运算 符

432

[第人131章)

采用 面向对 象 的 方法描述 算法

的 功能是表示 对 象 的成员 。

例如,前面定义的 objl 的数据成员表示为:

objl.i,objl.j,objl.k

objl 的成员 函 数表示为:

objl. setvalue() ,objl. display()

对 象指针 的 成员表 示 如 下 :

对 象指针 名 一 > 成 员 名

或者:

对 象指针 名一> 成员名 (参数 表 )

同样 ,前 者用于 表示 数据 成员, 后 者用于表示成员函 数。这 里 的 “一 > 是 一个表示 成 员

的 运算 符 , 它 与 前面介绍 过 的“. ”运算 符的区 别 是 “一>” 用 来 表示 指向 对 象 的指针 的 成 员 ,

而”. ”用 来 表示 一 般 对 象 的成员 。

对 于数据成员和成员函 数 ,以 下 两种表示 方式是 等价的 :

”对象指针名一>成员名

。

(:# 对 象指针名).成员名

1323 构造函数和析构函数

构造 函数和 析 构 函数都是类 的 成 员 函 数 ,但 它们 是特殊 的成员 函 数 , 不 用 调用便自 动执

行 ,而且 这 些 函 数 的名称 与类的 名 称有关 。

在 刚 定 义 类 的 对 象时 一 般 都需要 有 初始 值,如 给 上 例的Sample 类的并

和>y 赋 初 值 。但 在 类 声明 体 中 不 能 在 定义时 初始化 成员变 量 ,那么该怎么

办? 在 Sample 类 中 使 用 了 一 个 setpoint 函数 来实现 ,在 每 次 使用一 个 新 的
对 象 前 调用 一 下 该函数 就 可以 初始化 需要 的成员 变量 ,但 是 这 种 方法既 不

讽 大 用

方便 也 容易 忘记 ,如 果 用 户 不小 心忘记 了 调用 setpoint 来 初始化 类 对 象 ,那么结果 就 可 能 出

错。C++ 提 供 了 一 个 更 好 的 方法 ,即利 用 类 的 构造 函数 来 初始化类 的 数据 成 员 。

构造 本 数 是 类 的 一 个特殊成员杖 数 , 它 与类同名 ,并 且 没有返回值 。C++在创建一个对

象 时 会 自动调用 该 类 的 “构造 函数”, 在 构造函数 中 可以 执行 初始化 成员变量 的 操作。例如 ,

aa

以 下 是 一 个 构造函数 的声明 示例 ;

class Sample

{

public:

Sample(参数表) ;

}

433

数据 结构教程

[第! 5人版

构造 本 数 可 以像普通本 数 一 样 被重 载,C++ 根据声明 中 的 参数 个数和 类 型 选择合适 的

构造 函数 。

【例 13. 2〗 分 析以 下 程序的 执行结果 。

井 include < iostream >

using namespace std;

class Sample2

{

int value;

public:

Sample2() { value一0; }

//构造函数

Sample2(int v) { value一v; }

// 重 载构造函数

int getvalue() { return value; }》

void setvalue(int v) { value一v; }

)

int main()

{

Sample2 a[10] 一{0,1,2,3,4,5,6,7,8,9},bL10];

cout << "输出 a:" << endl;

for (Cint i 一0;i< 10;i 十十)

{

cout<< "a[" <<i<< 由 二 "<< a[癌 .getvalue() <<

"";

让 ((i 十1)%5王一0)

// 每输出 5 个 元 素 换 一 行

cout<< endl;

}
cout << "输出 b:" << endl;

for (Cint i 一0;i< 10;i 十十)

cout<< "b[" <<i<< 门 ="<<b[.getvalue() <<
让 ((i 十1)%5王一0)

// 每输出 5 个 元 素 换 一 行

”";

cout<< endl;

{

}

return 1;

上 述 程序说明了 类 对 象数组 的使用 方法。在 程序中 定义 对 象 数组时 编译器 调用 适

当 的 类 构造 本 数 建立数组 的 每 个 分 量。这 里 的 a 数组有 10 个 元素, 赋 有 初 值,编译器调用

眶

载 构造机 数 Sample2(int v) 构 造对象,所 以 a 的定义等价于:

Sample2 a[L10]

一{Sample2(0),Sample2(1),Sample2(2) ,Sample2(3),Sample2(4) ,Sample2(5),

Sample2(6),Sample2(7),Sample2(8) ,Sample2(9)}

0 数组也有 10 个 元 素 ,没有赋 初值 ,编译 器调用 第 一个构造 函数 Sample2()构造对象,

所 以 2 的定义 等 价 于 :

Sample2 b[10] = {Sample2(0),Sample2(0) ,Sample2(0),Sample2(0) ,Sample2(0),Sample2(0),

Sample2(0) ,Sample2(0) ,Sample2(0) ,Sample2(0))}

434

[第人13L章)

采用 面向对 象 的 方法描述 算法

程序的执行结果如下 :

输出 a:

a[o]j=0 a[J]王1 a[2]王2 a[3]一3 a[ 纪 一 4

a[5]一5 a[6]王6 a[7]王7 a[3]=8 a[9]一9

输出 b:

b[o=0 b[] =0 b[2=0 b[3] 王0 b[和=0

b[5 王 0 b[6]=0 b[7=0 b[L8=0 b[9]=0

一 个 类 可 能 在 构造函数 里 分配了 资源,这 些资源需要 在对象 不 复存在以前被释放 。 合

如 ,如 果 构造 函数中 分配了 内 存 , 这 块 内 存在 对 象 消失 之 前 必须 被释放 。

与 构造函数 对 应 的 是 析 构 丽 数。当 一 个 对 象消失 ,或 用 new 创建的对象用 delete 删除

时 ,由 系统自动调用 类 的 析 构 函数 。析 构 函 数 名 称为符号"~..." 加 类 各, 析 构 函数没有 参数 和

返回值。在一个美中 只 可 能 定义 一个析 构 函 数,所以析 构 琢 数 不能重 载 。以 下 是 一个析 构

函数 声明 的 示例 :

class Sample

{

public:

一 Sample() ;

}

在 析 构 函数 中 一 般 做一些 清除 工作 ,在 C++中 ,清除 就 像初始 化 一 样 重要 。 通 过 析 构 枯

数 来保证 执行 清除 。

当 对 象 超出 其定义 范围 时 ( 即 释放 该 对 象 时 ) 编 译器自动调用 析 构 函数 ,在 以下情况 下

析 构函数也会 被 自动调用 ,

(1) 若一个 对 象 被定义 在一个丽数体内 , 则 当 这 个 琢 数 结束时 该对 象的析 构 本 数被自

动 调用 。

(2) 若 一个对 象 是 使 用 new 运算 符 动 态 创建的,在 使用 delete运算符杰放它时 delete

将 会 自动调用析构函数。

【例 13.3〗

分 析以 下 程序 的 执行结果 。

井 include < iostream >

using namespace std;

class Sample3

{

intx,y;

public:

Sample3(int xl,int yl)

xx 一 xliy一yl1;

{
一Sample3()

}

{

cout<< "调用析构函数." << endl;}

void dispoint()

//构造函数

// 析 构 函 数

数据 结构教程

[第! 5版

人{

cout<< "("<<x<<","<<y<<")"<<endl;}

)

int main()

Sample3 a(12,6),*p一new Sample3(5,12);
cout << "First point一>";

// 对 象指针 指向 创建 的 无名对 象

a.dispoint() ;

cout << "Second point一>";

pP 一> dispoint();

V/delete p;

return 1;

{

)}

本 程序的执行 结果 如 下 。

First point一 >(12,6)

Second point一>(5,12)

调用析构函数.

从 程序 的 执行结果 看 到 ,对 于 一 般 类 对 象 ,系统 会 自动释放 并 自动

调用 析 构 函数 ,程序

中 的 对 象 < 就是这样的。对 于 用 new 运算 符 创 建的对 象 ,必须在使用 delete 运算符释放时

才调 用 析 构 函数,本 程序 中 的 对 象指针 书 没有使用delete 释放,故 未调用 析 构 函数。若除去代

码中 delete p 语句前 的注释 符号 , 则 会 自动调用 析 构 函数 ,结果 显示 两 次"调用 析 构 函数”。

13824 模板类

模板(template) 用 于 把 函数 或类要 处 理 的 数据 类 型参数 化 ,表现 为参数的多 态 性。模

板 用 于 表达 旭 辑结构

相同,且 具 体 数 据元 素 类 型不同 的 数据 对 象 的 通用行为,从 而 使 程序 可

以 从逻辑功能上 抽象 ,把 被处理 的对 象(数据 ) 类 型 作为 参数 传递 。

委--要

类模板使用户可 以 为类声明 一 种 模式 ,使 得类中 的 某 些 数据成员 .成员 |

型参数 化 。类 模板在表示 数据结构(如 数组.二 又 树和 图 等 )时 显得特别 重 回

蜡

要 ,这 些 数据结构 的 表示 和 算法 不受所 包含 的元 素 类 型 的

影响 。

视师讲解

声明 类 模板 的 一 般 格 式如 下 :

template 类 型 形 参 表

class 类模板名

{

)

类 声明 体 ;

template 类 型 形参表

返回 类 型类名 类 型名表 : :成员函数 1( 形参表 )

{

}

成员函 数定义体;

436

[第人131章)

采用 面向对 象 的 方法描述 算法

template 类 型 形 参 表
返回 类 型 类 名 类 型名表 : :成员函 数 n( 形 参 表 )

{

)》

成 员 函 数定义体;

甚

的 “类 型 形参表 ? 与 函数 模板 中 的 意义 一 样。在 后 面 的 成员丽 数 定义 中,“ 类 型名表 ? 是

有 目.“ 类 型 形参表 ”中 的 形 参 要 加 上 ”class?”

或“typename”关键词 。类 型 形参

可 以是C++ 中 的任何 基本 的 或 月

使用关键词class 或 typename。 如 果 类 型 形参多 于 一个, 则 每个形 参都 要 使用关键词class

或 typename。

同样 ,类 模板 不 能 直接 使用,必须 先 实例 化为相应 的模板 类 ,再定义 该模板类 的 对 象 后

才能使用,如图 13. 2 所示 。 在定义类模板之后,创建模板 类 的 一 般 格式如下 :

类 模板 名 <类型 实参表> 对 象 表 ;

一 个 或 多 个对 象 。

关机析、}实例化为具体类/ 计权类、创建具体类的对

图 13. 2 ”类 模板 模板类和 类 对 象之间 的 关系

【例 13. 4】

分 析 以 下 程序 的 功能 。

井 include <il

oOstream >

using namespace std;

template < typename 工 >

class Array

{

int size;

T工 * datai

public:

Array(int);

人一Array();

void setvalue() ;

void dispvalue();

)

template < typename 工 >

//T 为 类 型参数

//构造函数

//析构函数

// 输入数组元素

// 输 出所有 数组 元 素

Array<T>::Array(int D) //构造函数

{ Size一ni

data一new T[m];

// 为 动态 数组 分 配 内 存空间

)》

template < typename 工 >

437

数据 结构教程

[第! 5版

Array<T>::一Array()

{

delete [] data;

template < typename 工 >

void Array< 工 >::setvalue()

// 析 构 函 数

{

, cout<< "( 输入" << size << "个 数据 )"” << endl;

for (int i 一0;i< size;i十十)

cout<<" 第" <<i 十1 << "个 数据 :";

cin >> data[癌 ;

{1

》}

}

template < typename 工 >

机通 Aaay<TPEsdispaleO)

for (int i一0;i< size;i十十)

cout<< data[中<< " ";

cout << endl;

{

}》

int main()

{

, Array<char> ac(2);

//Array< char > 为 模板 类 ,ac(2) 定 义 模板 类 的 对 象

cout << "建立一个字符数组 ";

ac.setvalue();

cout<< " 数组的内容 是:";

ac.dispvalue() ;

Array<int> ad(3);

//Array<int> 为模板 类 ,ad(3) 定 义模板 类 的 对 象

cout << "建立一个整数数组:";

ad.setvalue();

cout<< " 数组的内容是:";

ad.dispvalue() ;

return 1;

)}

在 上 述 程序中声明了 一 个 类 模板 Array<

工>,其私有数据成员 size 是一个整数,表

示 动态数组的大 小,还有一个指针 data, 当 实例 化 模板 类 时 它指向 相应 类 型 数组 的 元 素 ,在

构造函数中为类型 T 的 数组 分 配指定 大小 的 空间 ,在 析 构 函数 中 释放 所 分 配 的 空间。在

main 冰数中定义 了 两 个模板类 ac 和 ad, 分 别 是 大小 为 2 的字符数组和大小为 3 的 整数 数

组,通过调用相应的成员函 数 实现 数组 的 输入和 输出 功能 。

用 C++ 描述数据 结构 算法 “”尖

数据结构 采用 面向对 象 方法实现 时 通常用类 模板 来描述,这 是由于 数

据 结构 关注 的是数据 元素及 其 关系 是如 何 保存的,基于 这 些 关 系 的 运算 是

如何实现的,而 数据 元 素 可 以 是任意 类 型 。 使用类模板来描述 ,可以避免对

于 具体 数据 元 素 类 型的依赖 。本 节 通 过 设计 顺序 表 类 模板和 链 栈 类 模板 来

438

[第人131章)

采用 面向对 象 的 方法描述 算法

说 明 采 用 面向对 象方法 描述 数据结构 算法 的 基本 思想 。

1331 顺序 表类 模板

有 关上 顺序 表 的 基本 运算 短 法 参见 第 2 章 ,这 里 不再介绍 。

[AT

在 设计顺序 表 类时 有 两 个私有 数据 成员,pelem 指针 指向 顺序 | 一sq

表 的 数据 ,length 指出 当前 顺序 表 中 数据 元 素 的 个 数。另外,

上 ep |

将 初始化顺序 表 的 功能 用 构造函数 实现 (分配 MaxSize 大小 的
空间,由 pelem 指针指向 它) ,释放 顺序 表 的 功能 用 析 构 函数实 | GetElem | eng
现 (释放 pelem 指针所指向 的 空间 )。顺序 表 的其他 基本 运算 | eeaeEiem
ListDelete
由 该类中的 其 他 成员函 数 实现 。顺序 表 类 SqList 如图 13. 3

DispUist

所示 。

为了通用 ,设计顺序 表 类 模板 SaList< 工 >如下:

图 13.3 Sqlist类

template < typename 工 >

class SqList

人

T*pelem;

int length;

public:

// 顺 序 表 类 模板

SqList(int n)

// 构 造 函 数,用 于 初始化 顺序 表

pelem=newT[n];

length王0;

{

}

一 SqListO)

{

delete pelem;》

bool ListEmpty()

{

}

return(length一一0) ;

// 析 构 函 数,用 于 释放 分 配 的 空间

// 判 断 线性 表 是 否 为空表

int ListLength()

// 求线性 表 的 长 度

{

}

return(length) ;

void DispList()

{

inti

迁 (ListEmpty()) return;

cout << "顺序表 :";

for (i一0;i< length;i十十)

cout<< pelem[ << "”";

cout << endl;

}
bool GetElemCint iT&e)
让 Gi<l 1 i>length)
{
Teturn false;

e一pelem[i一] ;

Teturn true;

}
int LoacteElem(T e)

// 输 出 线性表

// 求线性 表 中 的 某 个 数据元素 值

// 按 元 素 值查找

439

数据 结构教程

[第! 5人版

inti=0;
while (i< length && pelem上 口 !一e) i十十;

过 (ji>王length)return 0;

else return i十1;

{

}

bool ListInsertCinti,T e)

// 插 入数据元素

人

intj;

过 (Ci<1 | i> length十1)

Teturn false;

这 一 :
for (Gj王length;jj>ijj 一一)

pelem[D] 王 pelemD 一匡 ;

pelem[癌一 e;
length 十十 ;

Teturn true;

}
bool ListDelete(inti,T &e)

{

intj;

if (i<1 | i> length) return false;

这 一 :

e一pelem[癌 ;

for (0 一 ij< length一1;j十十)

pelem[i] 王 pelemD 十 可 ;

length一一;

Teturn true;

}

)

// 将 顺序 表 位 序 转化为pelem 下 标
//将 pelem[ 及 后 面的元 素 后 移 一个位 置

// 顺 序 表 的 长度增 1

// 删除数据元素

// 将 顺序 表 位 序 转化为pelem 下 标

在 设计好 SqList< 工 > 类模板之 后可 以 定义 模板 类 及 其 对 象,并 通过 这 个 对 象调用 成 员

函数 来实现 顺序 表 的 功能。例如,设计以下主函数:

int main()

{

char eiint i;

SqList< char> s(10);

// 定 义 一个大小 为 10 的 字符 顺序 表 对象 s

.ListInsert(1,,'a');

S

.ListInsert(2, "b");

S

.ListInsert(3,'c));

S

.ListInsert(4,"d);

S

S

.DispList() ;

.GetElem(2,e);

S

cout<< "第 2 个 结 点 值 :" << e << endl;
i一s.LoacteElem('d');
cout<< "数据 值为 d 的 结 点序号为"<< i << endl;
cout<< "删除第 2 个 结 点"<< endl;
Ss.ListDelete(2,e);

Ss.DispList() ;
cout << "删除第 3 个 结 点"<< endl;
Ss.ListDelete(3,e);

Ss.DispList() ;

[第人131章)

采用 面向对 象 的 方法描述 算法

cout << "插入 e 作 为第 1 个 结 点" << endl;

Ss.ListInsert(1, 'e');

s.DispList() ;
cout << "插入 工作 为第3 个结点"<< endl;
Ss.ListJnsert(3,'f) ;

s.DispList() ;

return 1;

)》

其 执行 结果 如 下 :

顺序表:abcd

第 2 个 结点值: b
数据 值为 d 的 结 点 的序号为4

删除第 2 个 结点

顺序表:acd

删除第 3 个 结点

顺序表:ac

插和人 e 作 为 第 1 个 结点

顺序表:eac

插和人工作 为 第 3 个 结点

顺序表:eafc

上 述 主 函 数 中 定义 的 是 字符 顺序 表 , 如 果 需 要 使用实数 顺序 表 sl, 也 可以 直接 从

SqlList<T> 中 产生 ,例如 :

SqList< double> s1(20);

// 定 义 一个大小为20 的 实数顺序 表 对 象 s1

1332 链 栈 类模板

有 关 栈 的 基本 运算 算法 参见第 3 章 , 这 里 不再介绍。在设

计链 栈 类时 只 有 一 个私有 数据 成员 lhead, 它作为链栈对 应 的
LiStackt
单链表的头结 点指针,单链表 结 点 的类 型为NodeType(其定 上 Es
义 见以 下 代码) 。另 外 ,将初内化链 栈 的功能 用 构造丽数 实现 上

”ph | me

(创建一个头结点,其 next 域 为NULL,并由1lhead 指向这个头

op
Gerrgp

结点) ,释放链 栈 的功能 用 析 构 函数 实现 (释放 链 栈 对 应 的单链

表 的所有 结 点 空间) 。 栈 的其他 基本 运算 由 该类中 的 其他 成 员
函数 实现。链 栈类 LiStack 如图 13.4 所 示 。

图 13.4 Listack类

为 了 通用 ,设计链栈类模板 LiStack< 工 >如下 :

template < typename 工 >

struct NodeType

{

Tadata;

NodeType * next;

// 单链表 结 点的类 型

// 数 据 域

// 指 针 域

441

数据结构教程 SEASAR

)}

;

template < typename 工 >

class LiStack

{

// 链 栈 类 模板

NodeType<T> * lhead;

// 单链表 的头结 点 指针

public:

LiStack()

// 构 造函数 ,初始化栈

1lhead一new NodeType<T>();

lhead -> next王NULL;

{

}

一 LiStack()

// 析 构 函 数 ,销毁栈

{

, NodeType<T> * p 一]head 一> next;

while (p!=NULL)

delete lhead;

lhead 一 p;

p一pb 一 next;

{

】}

delete lhead;

// 释 放 头 结 点空间

》}

intStackEmpty()

// 判 断栈是 否 为 空

{

}

return(lhead -> next 一一NULL);

void PushCT e)

// 进 栈

{

NodeType<T> *p;

p王new NodeType< 工 >();

p 一> data一e;

p 一> next 一]head 一> next;

// 插入p 结 点 作为 第 一个数据 结点

1lhead 一 > next一p;

}

bool Pop(CT &e)

// 出 栈

{

NodeType<T> *p;

寺 (lhead -> next王二NULL)

// 栈 空的情况

Teturn false;

p 王]head 一 > next;

//p 指向 第 一个数据 结 点

e一pD 一> data;

1head 一 > next一p 一> nexti

delete p;

Teturn true;

}
boolGetTop(T &e)

// 取 栈 顶 元 素

{ ,庄 (lhead 一 next一一NULL)

// 栈 空的情况

Teturn false;

e一lhead 一> next 一 > datai;

Teturn true;

peeee

[第人131章)

采用 面向对 象 的 方法描述 算法

使用STL 设计数据结构 算法 光

STL 最早由 惠普 实验 室 开发 完成,它 是以 C 中 的 模板 语法 为 基础 建立起 来 的一套 包含

基础 数据 结构和 算法 的代码 库 。STL 的 特点 是 实现了 * 类 型参数 化”",即 STL 的代码中可

处 理任意 自 定义 类 型的对 象 。

STL 中 提供 的 容器 用 来 保存 数据 ,涵盖 了许多 数据 结构 ,例如 前 面 章节 中 介绍 的 链表 、

栈和队列等。在 实际的开发 过 程中可 以 直接 使用,不 仅 简化了许多 重复 乏味 的 工作 ,而 且

提高 了 软件 开发的效率 。

容器 部 分 主要 由 头 文件< vector >.< list >.< deque >、< set > < map >、

< stack > 和< queue >组成。表 13.1 列出了 STL 提供 的 数据 结构和 相应头

文件的对 应 关系 (其 中 ,用 # 标识 的以hash_开头的4 个 容器 必须 存在 一 个

键 值的哈 希 函数 ,它们 不是 C++标准 库 的 部 分 ) 。

为此,在使用STL 时 必须 将以 下 语句 插入 到 源 代 码 文件开头 :

using namespace std;

这 样 直接 把 程序代码定位 到 std 命名空间 中 。

表 13.1 数据 结构和 相应 头 文件的对 应 关系

数据 结构

说

明

实现头文件

向 量 (vector)

连续 存储 元 素 。底 层 数 据 结构 为 数组,支持 快速随机 访问

去 Vector>

链表 (list)

届 Cuab

队列 Cqueue)

双 队 列 (Cdeque)

由 结 点 组 成的双向 链表 ,每个结 点 包含 着 一 个 元 素。底 层 数据

结构 为双向 链表 ,支持 快速增删

。
< list>

后 进 先出的 序列。底 层 一 般 用 list 或 deque 实现 ,封闭头 部即 |
可 ,不 用 veetor 的 原因 应 该 是 容量 大小有限制,扩容 耗 时 站

先进先出的序列。底 层一般 用 list

或 deque 实现 ,封闭头部即

可 ,不 用 vector 的原因 应 该是容量大小 有 限制 ,扩容耗时

queue>

连续 存储 的 指向 不同元 素的指针 所 组 成的数组。底层数据结
构 为 一个中 央 控 制器和 多 个 缓冲区 ,支持首尾 (中 间 不 能 ) 快速| < deque>

增删 ,也 支持 随机 访问

元 素 的 次 序 是由作用 于 所 存储 的 值上的 某 种 谓词决定 的 一 种

优先队列 (priority_queue) |队列。底 层 数据 结构 一 般 为 vector 作为底层 容器 ,堆 heap 作 | <二 queue>

为处理 规则 来管理底层 容器 实现

CT

集合 (set)

以 某种作用 于 元 素 对 的 谓词排列 ,没有两 个不同 的 元 素 能够拥

去 set>

由 结 点 组 成的红 黑 树 ,每 个 结 点都包含 着一个 元 素 , 结 点 之 间

有相同的次序。底 层 数据 结构 为红黑 树,有 序 , 不 重复

多 重 集 合(multiseb

人允许 存在 两个次序相等 的 元 素 的 集合。底层数据 结构 为 红 黑
树 , 有 序 , 可 重复

忌 set>

数据 结构教程

[第! 5版

数据 结构

了 映射

map)

说

明

续表

实现头文件

由 (关键 字 , 值)对 组 成 的集合 ,以 某种作用 于 关键字上 的 谓词
排列。底 层 数据结构为红 黑 树,有 序 ,不 重复

本
_
0

多 重 映射(multimap)

允许 关键字相 等的次 序的映射 。底 层 数据结构 为红黑 树,有 map

序 , 可 重复

hash_set xx

类 似 于 集合 ,底层 数据结构 为 哈希表 , 无序,不重复

hash_multiset *
hash_mapx
hash_multimap *

类 似 于 多 集合 ,底层数据结构 为 哈希表 , 无 序,可 重复
类 似 于 映射,底层 数据 结构为哈 希 表 ,无 序,不重复
类 似 于 多 映射,底层 数据 结构为哈 希 表 , 无 序,可 重复

所 hash_set >

去 hash_set >
二 hash_map>

去 hash_map >

下 面 介绍 几 种常用 的 容器 。

它 是 一 个向量 类 模板。向 量 容器 相当 于 数组 , 它 存 储具有 相同 数据 类

型的一 组 元 素 ,可以 从 后 面 快速地插入 与 删除元 素 ,快速地随机访问元素 ,

但 是 在 序列 中 间 插 入 、 删除元 素 较 慢 , 因 为需要 移动插入 或 删除 处 后 面的所

视频讲解

有 元 素。而 且 如 果 一 开始 分 配 的 空间 不够,重新分配更大的空间时 需要 进行大量 的 元 素 复

制 ,从 而 增加 了 性 能 开销 。

以 下 语句 定义 一 个整数 向量对 象 test;

vector< int > test;

这 样 只 定义 一 个空的 容器 ,其 中 没有任何 数据 , vector 提供 了 一 系列 的 成员函 数,可以

使用 它们 对定义的 test 容器 进行 操作 。vector 主要 的 成员函 数如 下 。

。 max_size(): 容器 中 能 保存 的最大 元素数 量 。

。 size(): 当前 容器 中 的 实际元 素 个 数 。

。 push_back() : 在 vector 的 尾部 添加 了 一 个元素。

。 insert(): 将元 素 插 入 到指定 元 素 之 前 。

。 empty():

判断 vector 是 否 为空。

。 front(): 取得 vector 的 第 一 个 元 素 。

。 back(): 取得 vector 的 最 后 一 个 元 素 。

。 erase(): 去 掉 某个区间 指 定 的 元 素 。

。 clear(): 删除所有元素。

。 begin(): 引用容器中的第一个 元 素 。

"end():引用容器中最后一个 元 素 后 面 的一个位 置 。

【例 13.5】 分 析以 下 程序 的 执行结果 。

井 include < iostream >
井 include < vector>
#include < algorithm >

using namespace std;

int main()

[第人131章)

采用 面向对 象 的 方法描述 算法

{

vector<int> v(3);

// 定 义初始长度为 3 的整数 容器

v[0] 一 5
v[ 匡 一 2;

v.push_back(7);

// 下 标 0 处 放置元素 5
// 下 标 1 处放置元素 2

// 在尾部插人元素7

vector< int>: :iterator first一 v.begin();

//让 first 指向 开头 元 素

vector<int>::iterator last一 vend();

//让 last 指向 尾部 元 素

while (first!一last)

// 循 环 输出所有 元 素

cout << 关 firstt+ <<

”";

cout << endl;

return 1;

】}

在 上 述 程序中 初始 定义了 一 个 长 度为3 的整数向量 w( 所 有 元 素默认为0) 。 在 前 两

个 下标 放 置两个整数,再 在 末尾插入 一 个 整数 7 ,长度增加 1 ,最后输出所有 整数。程序的 执

行结果 如 下 :

5 207

它 是 一个双 端 队列 类 模板。双 端 队列 容器 可以 从 前 面 或后面 快速 地插入 与删除 元 素 ,

并 可 以 快速地 随机 访问 元 素 ,但 删除元素 较 慢 ,空间 的重新分配要比 vector 快,重新分配空

间 后原有 的 元 素 不 需要 复制 。若 要 对 deque进行排序操作,可将 deque 先 复制 到 vector,排

序后再复制回deque。

deque 的主要成员函数如下 。

。 empty(): 判断队列 是 否 为空队 。

。 size(): 返回队列 中 元 素的 个 数 。

。 push_front(): 在 队 头插入元素。

。 push_back(): 在队尾 插入 元素 。

。 pop_front(): 删除 队 头 的 一 个 元 素 。

。 pop_back(): 删除队尾 的 一 个 元 素 。

。 clear(): 删除所有的 元 素 。

。 begin(): 引用 容器 中 的 第 一 个 元 素 。

。end(): 引用 容器中最后一个 元 素 后 面的一 个位 置 。

【例 13.6】 分 析以 下 程序 的 执行结果 。

#include < iostream >

井 include < deque>

#include < algorithm >

using namespace std;

void disp(deque<int> &dq) ;

int main()

{1

deque<int>dq;

// 建 立 一个双 端 队列 dq

数据 结构教程

[第! 5版

// 队 头插入 1

// 队 尾插入 2
// 队 头插入 3

// 队 尾 插入 4

// 删除队 头 元 素

// 删除队 尾 元 素

dq.push_front(1);

dq.push_back(2);
dq.push_front(3);

dq.push_back(4);

disp(dq);
dq.pop_front();

dq.pop_back();

disp(dq);

Teturn 1 ;

}

void disp(deque<int> 术 dq)

{

deque< int>::iterator iter;

for (iter一dq.begin() ;iter!一dq.end() ;iter 十十)

cout<< *iter<< "”";

cout << endl;

)}

在 上 述 程序中 定义了 字符 串 双 端 队列 dq, 利 用 搬入和 删除成员 函 数 进行操作。程

序 的执行结果如下 :

3124

12

3 人 天产类了

它 是 一 个 双 链 表 类 模板 ,可以 从任何 地 方 快速地搬 和人与 删除。它 的 每 个元素 间 用 指针

相连 ,不 能 随机访问 元 素 , 为了访问 表 容器中 特定 的 元 素 , 必 须 从 第 1 个 位 置(表 头)开 始 , 随

着 指针 从 一 个 元 素 到 下 一 个 元 素 , 直 到 找到 要 找 的 元 素。插和元素比 vector 快,对 每 个 元

素 分 别 分 配 空间, 所以 不 存在 空间 不 够重新 分 配 的 情况 。

list 的主要成员函 数如下 。

。 size(): 返回表 中 实际 元 素的 个 数 。

。 empty():判断表是否为空 。

。 push_back(): 在 表尾部插入元素。

。 pop_back(): 删除 最 后 一 个 元 素 。

。 remove ():

删除所有 指定 值的 元 素 。

。 erase: 从 容器中 删除 一 个或 几 个 元 素 。

ee

。 clear(): 删除所有 的 元 素 。
。 insert(pos,elem) : 在 pos 处插入 elem 元素并 返回 该元 素的位 置 。
。 begin(): 引用容器中的第一个 元 素 。

。end(): 引用容器中最后一个 元 素 后 面 的 一 个位置。

【例 13.7】〗

分 析以 下 程序的 执行结果 。

井 include < iostream>

#include < list>

[第人131章)

采用 面向对 象 的 方法描述 算法

using namespace std;

int main()

{

list< int> lst;

list< int >: :iterator i, start,end;

1st. push_back(5) ;lst.push_back(2) ;lst.push_back(4) ;

1st. push_back(1) ;lst.push_back(3) ;lst.push_back(8) ;

jst. push_back(6) ;lst.push_back(7);

cout << "lst: ";

for (i一1st.begin() ;il一lst.end(O);i十十)

cout<< *i<<”";

cout << endl;

i 一 lst.begin();

start一十十lst. begin() ;

end一一一lst.end();

lst.insert(i, start,end) ;

cout << "lst.insert(i, start,end)”<< endl;

cout<< "lst: ";

for (ji一lst.begin() ;il一lst.end(O);i十十)

cout<< *i<<”";

cout << endl;

return 1;

在 上 述 程序中 建立了 一 个 整数表 对 象 lst,向其中添加 8 个 元素,: 指向 元 素 5,start

指向 元素2,end 指向 元 素 6 ,执行“lst. insert(i,start,end);

”语句时将2.4、1.3、.8,.6 搬入到

最 前 端 。程序的 执行结果 如 下 :

扫--扫

lst:52413867

lst.insert(i, start,end)

lst:24138652413867

它 是 一 个栈类 模板。栈具有后进先出的特点。栈 容器 必须 结合其他 容器 使用,其默认

Ni

的 内 部容器是deque。 它先进后 出 ,只有一个出口 ,不允许 遍历 。

stack 的主要成员函 数如下 。

。 empty(): 容器中没有 元 素时 返回 true,和否则返回 false。

扫-扫

。 size(): 返回 容器 中 当前 元 素 的 个 数 。

。top(0): 返回栈项元素。

。 push():元素进栈。

。 pop(): 元 素 出栈 。

【例 13.8〗】 分 析以 下 程序 的 执行结果 。

#include < iostream >

#include < stack>

447

数据 结构教程

[第! 5版

using namespace std;

int main()

{

stack< int> sti;

st.push(1) ;st.push(2);st.push(3);

cout<< st.top() << "”";

st.pop() ;cout<< st.top() <<"";

st.pop();st.top() 一 7;

st.push(4);st.push(5);

st. pop();
while (1st.empty())

cout<<st.top() <<

"";

st.pop() ;

{

}

cout << endl;

return 1;

)》

// 栈 不 空时输出 栈 顶 元 素 并 退 栈

在 上 述 程序中 建立了 一 个 整数栈对 象 st, 进 栈 、 退 栈 若干 元素,最 后 使用while 循环

语句 在 栈 不空时 输出栈顶 元 素 并 退 栈。程序的 执行结果 如 下 :

3247

它 是 一个队列 类 模板。队 列具有先进先出的特点,队列 容器 是受限 制的deque,内部容

器一般使用 list 较 简单 。它先进先出 ,不 允许 遍历 。

deque 的主要成员函数如下 。

。 empty(): 容器中没有 元 素时 返回 true,和否则返回 false。

。 size(): 返回 容器 中当前元素的个数。
于

。 front(): 返回队头元素。

。 back(): 返回队尾元素。

。 push(): 元 素进队 。

。 pop(): 元 素 出 队 。

【例 13. 9 分析以 下 程序 的 执行结果 。

#include < iostream>

井 include < queue>

using namespace std;

int main()

{

queue<int> q;

q.push(1);q.push(2);q.push(3);

cout << q.front() <<

"";

q.pop() ;cout<< q.front() <<

"”"; q.pop();

q.push(4);q.push(5);

q.pop();

[第人131章)

采用 面向对 象 的 方法描述 算法

while (1q.empty())

// 队 不 空时出 队

cout<<q.front() << "”";

q.pop();

{

}

cout << endl;

return 1;

)》

在 上 述 程序中 建立了 一 个 整数队 对 象 9, 进 队 、 出 队若干元素, 最 后 使用 while 循环

语句 在 队 不空时 输出 队 头元素 并出队 。 程 序的执行结果 如 下 :

1245

449

附录 A 实验报告格式

每 次 实验 要 求 提交 完整 的实验 报告 。实 验 报告的基本 格式如下 ,

一、设计人 员 相 关 信 息

1. 设计 者 姓名、 学号和 班 号 。

2. 设计 日期。

3. 上 机环境。

二 、 程 序 设计 相关 信息

实验项目的 目的。

实验 项 目的 程序结构 (程序中 的 函数调用 关系 图 ) 。

实验 项目包含的各 个 文件中 的 函数 的 功能 描述 。

算法描述或流程图。

中

三、实验提交内容

实验 报告 实验 源 程序 清单和可 执行 文件 。

附录 了B 引用 型 参数 和 指针 引用 型

参数的说明

在 算法 设计 中 大 量 使 用 引用 型 参数,引用 型参数 是通过 C++的引用符

“中 "实现 的,在 Turbo C 2. 0 版本中 不 支持 引用 类 型,本 书 中 带 引用 的 程序

只 能 在 Visual C++ 6.0 和 Dev C++ 等编译器中 运行 。 使 用 引用型参数的目

的 是 为了将 函数 的 形 参 回 传 给 实 参。一 般情况 下 , 当 算法 中 的 形 参 作为 输
1 型参数时总 是 采用 引用 型参数 。

训帮

本 书 和 大 多 数同类 教材 的 一 个 不 同 之 处 是 顺序 表 、 顺 序 栈和顺序 队列 的 相关 算法 都 使

用 指针引用型参数。为 什么 使用 指针 类 型 呢? 这 是 因为 这 些 表 都 有 销毁 运算 ,其 功能是释

放 它 们 的存储空间。

C/VC++有一个原则: 由 系统 自动 分配 的 存储空间 在不再 需要 时 由 系统 自动释放,而使

用 malloc() 函数 手工 分 配 的 存储空间 在不再 需要 时 必须 使用 free()

函数手工释放。本 书使

用 指针 类 型参数 ,在 初始 化时 通过 malloc() 分 配 顺序 表 、 顺 序 栈和顺序 队列的存储空间 ,在

不 再需要时使用 free() 函 数 释放 它们 的 存储 空间 。

以 顺序 表 为例 ,在 顺序 表 的 基本 运算 设计 好 之 后 设计以 下 主 函 数 :

void main()
{

SqList * si

ElemType e;
JInitList(s) ;
ListInsert(s,a' ,1);

ListInsert(s, 'b',2);

ListInsert(s,'c' ,3);

ListInsert(s, "d' ,4);
ListDeleteCs,3,e)
printf("
printf("s:");DispList(s) ;

DestroyList(s) ;

)}

// 定 义 顺序 表 的 指针 s

// 初 始 化s所指向的顺序表
// 插入'a' 作 为 第 1 个 元 素

// 插入"中 "作为第 2 个 元 素

// 插入'c" 作 为 第 3 个 元 素

// 插 入 "d' 作 为第4 个 元 素
// 删 除第 3 个删除

// 输 出:s:abd

// 销 毁 s 所指的 顺序 表

删除的元素是%ce\n",e); // 输 出 :删除的元素是 c

在执行时先为* 分配 一 个 地 址 空间,由 于 是指针 类 型,所以仅分配 4 个字 节 的 地 址 空

间 ( 由 于 没有初始 化 ,其 中 的 地 址 值 是 无 效 的 )。执行InitList(s)语句,通过 malloc 函数分

配 一 个 顺序 表 的 空间,并 让 指向 其开始 位 置,这 样*指向 了 一 个 有 效 的 顺序 表 , 再 执行 插

入.删除等运算 ,最后调用DestroyList(s)将该顺序表释放 。

如 果 不 用 指针 型参数 ,同样可以设计对应的算法。以 顺序 表 为例,相关 运算 算法 可以设

计 如 下 :

void InitList(SqList &L)
{

L.length一0;

// 由 于 工 的 空间由 系统 分 配 ,不 需要 使用malloc 函数手工 分 配其存储空间

}

数据 结构教程

[第! 5版

int ListInsert(SqList &L,int i,ElemType e)

intj;
if(i<1l | i>L.length十1)

Teturn0;

i一一;
for (j王 L.length;jj>i5j 一 一)

L.data[和 =王L.dataD 一 可;

L.data[ 癌一e;

L.length十十;

return 1;

{

)》

// 参 数 1 错误 ,返回0
// 将 顺序 表 罗 辑 位 序 转化 为 物理 位 序
//将data[ 及 后 面 的 元 素后移 一 个位置

//插和人元素 e
// 顺 序 表 的长度 增 1

void DispList(SqList L)

{

inti

for (i王0;i<L.length;i十十)

printf("%c",L.data[癌);

printfC"\n") ;

)》
int ListDelete(SqList &L,int i,ElemType &e)

intj;
it(i<1l 1 i>L->length)

Teturn 0;

i一一;
e 一 L.data[i;
for (Gj=一ij<L.length一1;j 十十)

L.data[]

王L.dataD十] ;

L.length 一一;

return 1;

{

}

这 样可以设计如下主函数:

int main()
{

, SqList s;

ElemType e;
InitList(s);

ListInsert(s,'a' ,1);
ListInsert(s, 'b',2);

ListInsert(Cs,c' 3) ;

// 将顺序 表 逻 辑 位 序 转 化 为 物理 位 序

//将data[品之后的 元 素 前 移 一 个位置

// 顺 序 表 的长度减1

// 定 义顺序表 s

// 初始化顺序表 s
// 插入'a' 作 为 第 1 个 元 素
// 揪 入中"作为第 2 个 元 素
// 插入 'c' 作 为第 3 个 元 素
// 插 入 "d' 作 为第 4 个 元 素
// 删除第 3 个删除

ListInsert(s,"d' ,4);
ListDelete(s,3,e)
printf("
printf("s:");DispList(s) ;

删除的元素是%ce\n",e); // 输 出 :删除的元素是c

// 输 出:s:abd

return 1;

)》

在执行时先为* 分 配 一 个 顺序 表 的 空间 (由 系统 自动 分配 sizeof(SqList)个字 节 的空

间 ,该空间 的 名 称为*)。执行InitList(s)语名,将s 的 length 成员设 置为 0 表示是空表,再

执行插入\删除等运算。当 主 函数 执行 完毕,由 系统 自动释放 * 占用的存储空间。由 于 在 这

种 方式下 不 需要 编程释放 存储空间,也就无法编写DestroyList(s)算法了 。

所以,本 书 是 为了保证 顺序 表 、 顺 序栈和 顺序 队列等数据结构 算法 实现 的 完整性才 使 用

指针型参数的。两 者 在 本质上 没有 差别 ,读者 只 需要 了 解 顺序 表指针和 顺序 表 在 使用上 的

语法 差别即可 。

452

附录C 算法 索

知识 点 或例题编号

算法 功能

对 应 源 程序 名 章号

【例 1.5】
【例 1.9]

顺序 表

单 链 表

双 链 表
循环单 链 表

循环双 链 表

【例2.3】

【例2.4】

求 一 元 二 次 方程的根
分 析 递 归 算 法 的时间 复 杂 度

顺序 表 的 基本 运算 算法

单 链表 的 基本 运算 算法

双 链 表 的 基本 运算 算法
循环 单 链表 的 基本 运算 算法

循环 双 链 表 的 基本 运算 算法

algorithm1-5. cpp
algorithm1-9. cpp

sqlist. cpp

linklist, cpp

dlinklist. cpp
clinklist. cpp

cdlinklist. cpp

在 顺序 表 工 中删除所有值为zx 的 元 素

algorithm2-3. cpp

将整数 顺序 表 工 以 第 一 个 元 素 为 分界线 (基准)

algorithm2-4. cpp

进行 划分

【例2.5】

将 整数 顺序 表 工 中 的所有 奇数移动 到 偶数的 algorithm2-5. cpp

【例2.6】

【例2.7】
【例2.83
【例2.9]

【例2. 101

【例2. 111

【例2.12

前面

单链表 工 拆 分 成 两 个单链表

中 最 大 元 素 的 结点

删除单链表 工
单链表 递增 排序
双 链 表 的所有 结 点 逆 置

双 链 表 递 增 排序

algorithm2-6. cpp

algorithm2-7. cpp
algorithm2-8. cpp
algorithm2-9. cpp

algorithm2-10. cpp

统计 循环 单链表工 中 值为zx 的 结 点个数

algorithm2-11. cpp

在 循环双链 表工 中 删除 第 一 个 值为z 的 结点

algorithm2-12. cpp

【例2.13】
【例 2. 14] 二路归并: 采用 顺序 表 实 现
【例2. 14 二路归并: 采用单链表实现

判断 循环双 链 表工 中 的 数据 结 点 是 否 对 称

【例2. 15】
【例2. 16
【例2. 17】
线性 表 的 应 用

顺序 栈

链 栈

栈 的 应 用
栈 的 应 用

环形 队列

非环形 队列
队列 的 应 用

队列 的 应 用
【例3. 4
【例3.5
【例3.7】

求 3 个有序单链表 的 公共 结点
高 效 删 除有序 单 链表 的 值 重复 结点
求 两个等 长的有 序 顺 序 表 的 中 位 数
两个表 的 简单 自然 连接 的 算法

顺序 栈 的 基本运算 算法

链 栈 的 基本 运算 算法

用 栈 求 简单 表达 式 的 值
用 栈 求解迷宫 问题

顺序 队列 (环形 队列 ) 的 基本 运算 算法

顺序 队列 (非环形 队列 ) 的 基本 运算 算法
用 队列 求解报 数 问题

用 队列 求解 迷宫 问题
判断 一 个 字符 串 是 否 为对称 串
判断表达 式 中 的 括号 是 否 配对
用 队 中 元 素个数 代替 队 尾 指针 的 环形 队列

algorithm2-13. cpp
algorithm2-14-1. cpp
algorithm2-14-2. cpp

algorithm2-15. cpp
algorithm2-16. cpp
algorithm2-17. cpp
tablelink. cpp

sqstack. cpp

listack. cp

expvalue. cpp
mgpath. cpp

sqqueue. cpp

sqqueuel. cpp
number. cpp

mgpath1. cpp
algorithm3-4. cpp
algorithm3-5. cpp
algorithm3-7. cpp

1
1

2

2

2
2

2

2

2

2

2

2
2
2

2

2

2

2
2
2

2
2
2
2

3

3

3
3

3

3
3

3
3
3
3

数据结构教程 NEA5AR

知识 点 或例题编号

算法 功能

对 应 源 程序 名 章号

续表

【例3.81

【例 3. 10】

顺序 串

链 串

串 模 式匹配
串 模 式匹配

串 模 式匹配

用 只 有 尾 结 点 指针 rear 的循环 单 链表 作为链队 。 algorithm3-8. cpp

双 端 队列 算法

顺序 串 的 基本 运算 算法

链 串 的 基本运算 算法

BF 算法
KMP 算法

改进的KMP 算法

algorithm3-10. cpp

sqstring. cpp

listring. cpp

bf. cpp
kmp. cpp

kmpl. cpp

【例4.1】 按字典顺序 比较 两 个串* 和上+上 的 大小

algorithm 4-1. cpp

【例4.2】

求串* 中 第 一 个 最 长 的连续相同 字符 构成的 algorithm 4-2. cpp

平台

3

3

4

4

4
4

4

4

4

【例4.3】

把串 * 中 最 先 出现的 子串“ap?"改 为“zyz”

algorithm 4-3. cpp

人4

Hanoi 问题求解

求解 Hanoi 问题 的 递归和 非递归 算法

hanoi. cpp

【例5.1】

【例 5. 2

【例5.31

【例5. 4

【例 5.5】

稀 朴 矩阵
稀 朴 矩阵

广义 表
【例6.1】

【例6.31

二 叉 树

二 叉 树

二 又 树

层次 遍历

构造 二 又 树

线索 二 又 树
哈 夫 曼 树
并 查 集

【例7.3】

aa

【例7.4】

求 24! 的递归 算法

algorithm 5-1. cpp

求实数数组 A[0..” 一 菇 中 最 小 值 的递归 算法

algorithm 5-2. cpp

求 一 个 顺序 表 中 最 大 元 素 的递归 算法

algorithm 5-3. cpp

释放 一 个 不 带头结 点 的 单 链表工 中所有 结 点的 。 algorithm5-4. cpp

递归 算法

用 递归算法求解从人口 到 出 口 的所有迷宫路径 algorithm5-5. cpp

稀 朴 矩阵三元 组 表示 的 基本 算法
稀 朴 矩阵十字 链 表 表 示 的 基本 运算

广义 表 的 基本 运算 算法
利用 数组求解约瑟夫问题

求 广 义 表 g 的原子个数

二 叉 树 的 基本 运算 算法

二 又 树 的 3 种递归 遍历 算法

tuples. cpp
orthogonal. cpp

glist. cpp
algorithm6-1. cpp

algorithm6-3. cpp

btree. cpp

Tecuorder. cpp

二 叉 树 的 3 种非递归遍历算法

nonrecuorder. cpp

二 叉 树 的层次 遍历 算法

构造 二 又 树 的 算法

中 序线索二又树和中 序非递归 遍历 算法
创建哈夫 曼树和 哈 夫 曼 编码 的 算法
亲戚 关系例子 对 应 的 并 查 集 求解算法

levelorder. cpp
createbt. cpp

thread. cpp
huffman. cpp
unionfindset. cpp

孩子链存储 结构 下 树的基本 运算 算法和 求树 上: 。 algorithm7-3. cpp

的 高 度
孩子兄弟 链存储 结构 下 树 的 基本 运算 算法和求 algorithm7-4. cpp

【例7.11]

【例7.121

【例7.131
【例7.14]
【例7.15】

树 上 的 高 度
计算 一 桔 给 定 二 又 树 的所有 结 点 个 数

输出 一 棵 给 定 二 叉 树 的所有 叶子 结点

求 二 又 树 中 指定 结 点 的 层次
求 二 又 树 中 指定 层次 的 结 点个数
判断 两棵二 又 树 是否相 似

algorithm7-11. cpp

algorithm7-12. cpp

algorithm7-13. cpp
algorithm7-14. cpp
algorithm7-15. cpp

【例7.16 输出二又树中值为 x

的 结 点 的所有 祖先

algorithm7-16. cpp

454

5

5

5

5

5

5

6
6

6
6

6

7

7

7

7
7

7
7
7

7

7

7

7

7
7
7

7

算法索引 |
CNABRACF

续表

知识 点 或例题编号

算法 功能

对 应 源 程序 名 章号

【例7.171

采用 后 序 遍 历非递归 算法 输出从根结点到 每个 algorithm7-17. cpp

叶子 结 点 的 路 径道序列

【例7.18

采用 层次 遍历 方法 输出从根 结 点 到 每 个叶子结 algorithm7-18. cpp

点 的 路 径 逆 序列

【例7. 19】

将 二 又 树的顺序存储 结构 转换 成二又 链存储 。 algorithm7-19. cpp

图

图 遍历

图 遍历
求 最 小 生成 树

求 最小 生成 树
求 最小 生成 树
求 最 短路 径
求 最 短路 径

拓扑 排序

关键 路 径
【例83. 2

【例8. 3

【例 85. 4

【例8.5】

【例3. 6

【例83.7】

【例83.8

【例8.9】

结构

图 的 基本 运算 算法

DFS 算法

BFS 算法
普 里姆算法

克 鲁 斯 卡尔 算法
改进 的 克 鲁 斯卡尔 算法
狄 克 斯特拉 算 法
弗 洛 伊德算法

拓扑排序 算法

求 AOE 网 的关键路径
邻接 矩阵和邻接表 的 相互 转换

判断无向图 G是否连通

graph. cpp

dfs. cpp

bfs. cpp
prim. cpp

Kruskal. cpp
Kruskall. cpp
dijkstra. cpp
floyd. cpp

topsort cpp

Keypath. cpp
algorithm8-2. cpp

algorithm8-3. cpp

判断图G 中 从 顶点 wx 到 v 是 否 存在 简单 路 径

algorithm8-4. cpp

输出 图 G 中 从 顶点 v 到v 的 一 条简单路径

algorithm8-5. cpp

输出图G 中 从 顶点 v 到 的所有简单路径

algorithm8-6. cpp

输出图G 中 从 顶点 wx 到 v 的 长 度为! 的所有简 algorithm8-7. cpp

单路径

输出一个有向图 中 通过 某 个 顶点 的所有 回路

algorithm 8-8. cpp

求 不带权 无向连通 图 G 中 从 顶点 wx 到 v 的 一 条

algorithm 8-9. cpp

最 短路 径

【例 8. 10

求不带 权 无 向连通 图 G 中 距离 顶点 v 的 最 远的 algorithm 8-10. cpp

线性 表 查 找

线性 表 查 找

线性 表 查 找

树 表 查 找
树 表 查 找

一 个 顶点

顺序 查找 算法

折 半 查找 算法

分 块 查找 算法

二 叉 排 序 树 的 基本 运算 算法
二 叉 平衡树的 基本 运算 算法

B- 树 的 基本运算算法 ”B- 树 的 基本 运算 算法

哈 希 表
哈 希 表

【例9. 4

插 和 排序

插入 排序

插 和 排序

交换 排序

哈 希 表 ( 开 放 定 址 法 ) 的 基本 运算 算法
哈 希 表 ( 拉 链法) 的 基本 运算 算法

求 二 叉排序树中 妨 结 点 的 左 子树中 的 最 大结点 algorithm9-4. cpp

和右子树中的 最 小 结点
直接 插 和人排序 算法

折 半 插入 排序 算法

希 尔 排序 算法

冒 泡 排序 算法

Insertsort, cpp

JInsertsortl. cpp

Shellsort. cpp

Bubblesort, cpp

sqsearch. cpp

binsearch. cpp

idxsearch. cpp

bst. cpp
avl. cpp

btree. cpp

hash-open. cpp
hash-chain. cpp

7

7

7

8

8

8
8

8
8
8
8

8

8
8

8

8

8

8

8

8

8

8

9

9

9

9
9

9

9
9

9

10

10

10

10

数据 结构教程

[第! 5人版

知识 点 或例题编号

算法 功能

对 应 源 程序 名 章号

续表

交换 排序

交换 排序
选择 排序

选择 排序
归并 排序

归并 排序

基数 排序

快速 排序 算法

改进 的 快速 排序 算法
简单选择排序 算法

堆 排 序 算法
自 底向上 的 二 路 归并 排序

自 顶 向 下 的 二 路 归并 排序

基数 排序 算法

面向 对 象 设计

顺序 表 类 模板

面向 对 象 设计 链栈类模板 LiStack

Quicksort. cpp

Quicksortl. cpp
Selectsort, cpp

Heapsort. cpp
Mergesort. cpp

Mergesort1. cpp

Radixsort. cpp

sqlist. cpp

listack. cpp

10

10
10

10
10

10

10

13

13

456

附录D 名 词 索 引

字母

AOE 网 (Cactivity on edge network) ,303

AOV 网 (activity on vertex newtork) ,301

AVL 树,333

B_树(B tree) ,339

B十树(B十 tree) ,345

BF 算法,134

Dijkstra 算法 ,290

Floyd 算法 ,296

ISAM 文件 ,418

KMP 算法 ,136

Kruskal 算法 ,285

m 次 树(mr-tree) ,191

Prim 算法 ,281

VSAM 文件,421

人A

凹人表示 法 (concave representation) ,191

单 链表 (singly linked list) ,44

队列Cqueue) ,97

队尾(Crear) ,97

队 头或队 首 (front) ,97

递归 (recursion) ,147

递归 出 口 (recursive exit) ,150

递归体(recursive body) ,150

对 称 和矩阵(symmetric matrix) ,168

对 角 抢 阵(diagonal matrix) ,171

带 权 路 径 长 度(weighted path length, WPL) ,237

端点 (endpoint) ,254

顶点 的 度Cdegree) ,254

带 权 图(weighted graph) ,256

动态查找表(dynamic search table) ,315

堆排序(heap sort) ,382

多 关键 字 文件(multiple key file) ,423

多 重 表 文 件(multilist file) ,423

倒 排 文件(inverted file) ,424

B

下

饥历(traversal) ,194
并 查 集 (disjoint-set) ,241
败者树(tree of loser) ,404

C

存储 结构 (storage structure) ,2
存储 密度(storage density) ,45
抽象 数据 类 型(abstract data type,ADT) ,13
串 (Cstring) ,122

层次 遍历 (level traversal) ,195,211

层 序 编号(level coding) ,198

稠密 图(dense graph) ,255

查找 (search) ,315

磁盘 排序Cdisk sort) ,400

磁带 排序(tape sort) ,410

次关键字(secondary key) ,415

D

二 叉 树(binary tree) ,198

二 叉 链 (binary linked list) ,206

二 叉 排 序 树(binary search tree,BST) ,324

二 路 归并 排序(2-way merge sort) ,386

二 路 平衡归并 (2-way balanced merge) ,404

下

分 支 结 点(branch) ,192
分 块查找(block search) ,321

G

共享栈(share stack) ,83

广义

表 (generalized table) ,177

优先 遍历(Breadth First Search,BFS) ,264

广度
广度优先生成树(BFS tree) ,280

关键路径(Ccritical path) ,303

关键 活动(key activity) ,303

多项式时间复 杂 度 (polynomial time complexity) ,20

归并 排序(merge sort) ,386

数据 结构教程

(第15 上

再

工

后 继 元 素 (successor) ,4
后 进 先出表 (last in first out,LIFO) ,79

逻辑结构(logical structure) ,2
链 式 存储 结构 (linked storage structure) ,7

后 级表达式(postfix expression) ,87
后 根 遍 历(postorder traversal) ,194 链栈(linked stack) ,84
环形队列(circular queue) ,100
孩子 结 点(children) ,192
孩子链存储 结构 (child chain storage structure),

链表 (linked lisb ,43

链队(linked queue) ,104
路径Cpath) ,192,255
路 径 长 度(path length) ,192,255
邻接点(adjacent) ,254

195

孩子兄弟链存储结构(child brother chain storage 连通图(connected graph),255

structure) ,197

后 序 遍 历(postorder traversal) ,211
回路或环(cycle) ,255
汇 点(converge) ,303
哈 夫 曼 树(Huffman tree) ,237
哈 夫 曼 编码(Huffman coding) ,239
哈 希 ( 或 散 列 ) 存储结构(hashed storage structure ,8
哈希表(hash table) ,347

险 希 函数(hash function) ,347

哈 希 地 址(hash address) ,347

哈 希 冲突Chash collisions) ,347
哈 希 文件(hashed file) ,422

可

进栈Cpusb) ,79

进 队 (Cenqueue) ,97

连通 分 量(connected component) ,255
邻接矩阵(adjacency matrix) ,256
邻接表(adjacency list) ,258
邻接多 重 表 (adjacency multirlist) ,263
内 查找(Internal search) ,315
拉链法(chaining) ,351
内 排序(internal sorD ,366
M

目标 串 (target string) ,134
模式 串(pattern string) ,134
模式匹配(pattern matching) ,134

满 mm次树(full mr-tree) ,193

满 二 又 树 (full binary tree) ,198
冒 泡 排序(bubble sorb ,374

N

假溢出 (false overflow) ,100
间接递归(indirect recursion) ,147
结 点 的 度Cdegree of node) ,191
平均 查找 长 度(Average Search Length,ASL) ,315
结 点层次level) ,192
平衡二又树(balanced binary tree) ,333
结点深度 Cdepth) ,192
平衡因子(balance factor,bD ,333
简单路径(simple path) ,255
简单 回路 或 简单 环(simple cycle) ,255 平方探测法(square probing) ,351
静态 查找 表 (static search table) ,315

逆 邻接表 (inverse adjacency
人
P

判定树Cdecision tree) ,318

list) ,259

PE

简单选择排序(simple selection sort) ,380
基数排序(radix sorb ,389

排序Csorb) ,366

开

开始元素(first element) ,4

Q

前 驱 元 素(predecessor) ,4

前 缀表达式(prefix expression) ,87

空间复杂度(space complexity) ,23

出 队 Cdequeue) ,97

括号表示法(bracket representation) ,191

出 度Coutdegree) ,254

开放定址法(open addressing) ,350

强 连 通 图 (strongly connected graph) ,255

快速排序(quick sorb ,376

强 连 通 分 量(strongly connected component) ,255

458

HRADA 名词来引 |

人 度 (indegree) ,254

及

S

数据(data) ,2
数据元素(data element) ,2
数据 项(data item) ,2
数据对象(data objecb ,2
数据 结构(data structure) ,2
数组(array) ,164

数据类型(data type) ,9

工

头 指针 (head pointer) ,44

退栈C(pop),79

图 (Cgraph) ,253

拓扑 序列(topological sequence) ,301

拓扑排序(topological sort) ,301

同义词 (synonym) ,347

桶 (bucketb) ,422

WV

尾 指针 (tail pointer) ,44

顺序 存储 结构(sequential storage structure) ,6

尾递归 (tail recursion) ,147

顺序表(sequential list) ,33
顺序栈(sequential stack) ,80

顺序

队 (sequential queue) ,98

顺串Cruns) ,401

顺序查找(sequential search) ,316
算法 (algorithm) ,14

时 间 复 杂 度 (time complexity) ,19

双 链 表 (doubly linked lisb) ,44

首 指针 (first pointer) ,44

双 端 队列Cdeques) ,113

上 三 角 和 矩阵Cupper triangular matrix) ,170

三 元组表 (list of 3-tuples) ,172

十 字 链 表 (orthogonal list) ,175 ,262
树 (tree) ,190
树 形表示法(tree representation) ,190
树 的 度Cdegree of tree) ,191

树 的 高 度Cheight of tree) ,192
树 的 深度(depth of tree) ,192
树表(tree table) ,324

森林 (forest) ,192

双亲 结 点 (parents) ,192

双亲 存储 结构(parent storage structure) ,195

深度 优先 遍历(Depth First Search,DFS) ,264
生成树(spanning tree) ,279
深度优先生成树(DFS tree) ,280
生成森林(spanning forest) ,280
索引 存储 结构 (indexed storage structure) ,8,321
顺序 文件(sequential file) ,416
索引表(index table) ,8,417

索引 文件(indexed file) ,417

索引 顺序 文件(indexed sequential file) ,417

索引非顺序 文 件(indexed non-sequential file) ,417

文氏图 表示 法 (venn diagram representation) ,190
无 序 树Cunordered tree) ,192

无序区 (disordered region) ,368

无 向 图(undirgraph) ,253

完全 二 又 树(complete binary tree) ,199

完全图(completed graph) ,254

网Cnet) ,256

外 查找 (external search) ,315

外 排序(external sort) ,366

稳定的(stable) ,366

文件(file) ,415

和

线性表(linear table) ,31

循环链表(circular linked list) ,59

先进 先出表 (first in first out,FIFO) ,97

下 三 角 和矩阵(lower triangular matrix) ,170

稀 玻 矩阵(sparse matrix) ,171

稀 下 图(sparse graph) ,255
兄弟 结 点Csibling),192
先 根 遍历(preorder traversal) ,194
先 序 遍 历(preorder traversal) ,211

线索 (thread) ,233

线索二又树(threaded binary-tree) ,233

线性 探测法(linear probing) ,350

希 尔排 序C(shell sort) ,371

虚段(dummy run) ,408

Y立

运算 Coperation) ,2

有 序 表 (ordered list) ,65
有 序 树(ordered tree) ,192

459

数据 结构教程

[第! 5 【版

有 序 区 (ordered region) ,368

子 串(substring) ,122

有 向 图 (digraph) ,253

子表(sub generalized table) ,178

有 向无环图 (directed acycline graph,DAG) ,303

子树(subtree) ,190

原子Catom) ,178

叶子结点(leaf) ,192

源 点(source) ,303

也

子孙 结 点(descendant) ,192

子 图(subgraph) ,255

祖先 结 点 (ancestor),192

中 序 遍 历 (inorder traversal) ,211

最小 生成 树(Minimal spanning tree) ,280

终端 元素(terminal element) ,4

最短路径(shortest path) ,290

指数 时 间 复 杂 度(exponential time complexity) ,20

最低位优先(least significant digit first,LSD) ,390

栈 Cstack) ,79

栈顶(top) ,79
栈 底Cbottom) ,79
栈帧(stack frame) ,152
中 组表达式(infix expression) ,87

直接递归 (direct recursion) ,147

直接 插入 排序(Cstraight insertion sort) ,368

最 高位优先(most significant digit first,MSD) ,390

最佳归并 树 (optimal merge tree) ,408

装填 因子(load factor) ,348

折 半 查找 (binary search) ,317
折 半 插入 排序(binary insertion sort) ,370

主关键字(primary key) ,415

附录 刁 全 国计 算机 专业 数据 结构

2018 年联考 大 纲

【考查目标 】

1. 掌握数据结构的 基本 概念 、 基 本 原理和 基本 方法 。

2. 掌握 数据 的迎辑结构 存储结构 及 基本 操作 的 实现 ,能 够对 算法 进行 基本 的时间 复

杂度与 空间 复杂 度 的 分 析 。

3. 能 够 运用 数据结构 的 基本 原理和 方法 进行 问题 的分析 与 求解,具备 采用 C 或 C++语

言设计 与 实现算法的能力。

一、线性表

1. 线性 表 的 定义和 基本 操作 。

2. 线性表的实现。

(1) 顺序 存储 。

(2) 链 式 存储 。

(3) 线性表的应用。

二、栈.队列和数组

栈 和 队列 的 基本 概念 。

栈 和 队列 的 顺序 存储结构 。

栈 和 队列 的链式 存储结构 。

栈 和队列的应用。

1.

2.

3.

44

.

5

三、树与二叉树

1.

树 的 基本 概念 。

2. 二 又 树 。

(1) 二 叉 树 的定义 及 其主要特征 。

(2) 二 叉 树 的 顺序 存储结构和 链 式 存储结构 。

(3) 二 又 树 的遍历。

(4) 线索 二 又 树 的 基本 概念和构造 。

(1) 树 的 存储结构 。

(2) 森林 与 二 又 树 的 转换 。

(3)

树 和森林的遍历。

4. 树 与 二 又 树 的 应 用 。

(1) 二 叉 排序树。

(2) 平衡二又树 。

树和哈夫曼编码。
(3) 哈 夫 曼(Huffman)

视频讲解

2016 年考研题讲解

2017 年考研题讲解

数据 结构 教程

[第! 5 【版

四、

1. 图 的 基本 概念 。

2. 图 的 存储 及 基本 操作 。

(1) 邻接矩阵 法 。

(2) 邻接表法。

(3) 邻接 多 重 表 、 十 字 链 表 。

3. 图的遍历。

(1) 深度 优先 搜索 。

(2) 广度 优先 搜索 。

4. 图 的基本应用。

(1) 最 小 (代价)生成树 。

(2) 最短路径 。

(3) 拓扑 排序 。

(4) 关键路径。

五、查找

oo站宦思oo

查找的基本概念。

顺序 查找 法 。

分块查找法 。

折 半查找法 。

B- 树 及 其基本操作、B 十树的 基本 概念 。

散列(Hash)表。

字符 串模式 匹配。

查找 算法 的分析 及 应 用 。

六、排序

1. 排序的基本概念。

2. 插入 排序。

(1) 直接 插入 排序 。

(2) 折 半搬入排序。

3. 起 泡排序(Bubble sort)。

4. 简单选择 排序 。

5. 希 尔 排序CShell sort)。
6. 快速 排序。

7

. 扒 排 序 。

8

. 二 路 归并 排序(Merge sort)。

9

.基数 排序。

10. 外 部 排序。

11. 各 种 排序算法 的比较 。

12. 排序 算法 的 应 用 。

462

Pa

参考 文献

严 蔚 敏 ,吴 伟 民 . 数据 结构 (C 语言 版 ). 北京: 清华 大 学 出 版 社,1997.

李 春 葆,等. 数据结构 教程. 4 版. 北京: 清华 大 学 出 版社,2013.

李 春葆,等. 数据结构 教程(C++ 语言 描述 ). 北京: 清华 大 学 出 版 社,2014.

李 春 葆,等. 数据结构 教程(C# 语言 描述). 北京: 清华大 学 出 版 社,2013.

李 春 葆 ,等. 数据 结构 联 考辅导 教程 (2013 版). 北京: 清华 大 学 出 版 社,2012.

李 春 葆. 新编数据 结构 习题 与解析 . 北京: 清华 大 学 出 版 社,2013.

Thomas H. Cormen,Charles ELeiserson,Ronald L. Rivest, Clifford Stein. 算法 导论 . 潘 金 贵,顾 铁

成 , 李 成 法 ,等译. 北京: 机 械工业 出 版 社,2009.

萨特吉 。 萨 尼 (Sartaj Sahni). 数据 结构 .算法 与 应 用(C++ 语言 描述 ).王立柱,刘志红,,译 .北京: 机械

工业出版社,2015.

R.L. Krusevet al, Data Structure and Program Design in C. 2nd Ed,Prenice Hall,1997.

R. Sedgewick, Algorithms in C, ADDISON-WESLEY,1998.

E. Horowitz,S. Sahni,S. Anderson-Freed. 数据 结构 基础 (C 语言版). 朱 仲 涛 ,译 . 2 版.北京: 清华大

学 出 版 社,2009.

陈 国 良 . 计算思维 导论 . 北京: 高 等 教育 出 版社,2012.

唐培和 , 徐 变 奕 . 计算思维 -计算 学 科 导 论 . 北京: 电子工业 出 版 社,2015.

王红梅,胡明 ,王涛.数据结构(C++版). 2 版.北京: 清华 大 学 出 版 社,2011.

张铭,等. 数据 结构 与 算法. 北京: 高 等 教育出 版 社 ,2008.
翁惠玉,等.数据结构 : 思想与实现. 北京: 高 等 教育 出 版 社 ,2009.

邓 俊 辉.数据 结构(C++ 语言 版).

3 版 .北京: 清华 大 学 出 版 社,2013.

左 程 云. 程序员 代码 面试指南-IT 名 企 算法 与 数据结构 题目最优化. 北京: 电子工业 出 版 社,2015.

Alsuwaiyel M. 五. 算法设计 技巧 与分析. 吴 伟 外 ,等 译 .北京: 电子工业 出 版社 ,2004.
黄 扬 铬 . 数据结构. 北京:科学出版社,2001.

急人昆,等.数据 结构 (用 面向对 象 方法与 C++ 描述). 北京: 清华大 学 出 版 社,1999.

和谍人 昆.数据 结构 习题精析 与 考研辅导 . 北京: 机 械 工业出 版 社,2011.

王晓东. 计算 机 算法 设计 与分析 . 北京: 电子工业 出 版社 ,2012.

黄 刘 生 . 数据结构 .北京: 经济科学 出 版 社 ,2000.

朱 战 立 . 数据结构 一 一 使用 C++ 语言. 西安: 西安电子 科技 大 学 出 版 社,2001.

赵 文 静 . 数据 结构 一一C++ 语言 描述. 西安: 西安交通 大 学 出 版社,1999.

陈 文博, 朱 青 . 数据 结构 与 算法 . 北京: 机 械工业 出 版 社,1996.
苏 光 奎 , 李 春 葆. 数据 结构 导 学 . 北京 : 清华 大 学 出 版 社,2002.
李 春 葆,等. 数据结构 程序设计 题典. 北京: 清华 大 学 出 版 社,2002.

李 春 葆,李 三 铁. 数据结构 考点 精 要 与 解 题指导 . 北 京 : 人 民 邮 电 出 版 社,2002.

图 书 资 源 支 持

感谢您一直以 来 对清华版 图书 的 支持和爱护 。 为 了 配合本世 的使用,本

提供 配套 的资源,有需求 的读者请扫描 下 方 的" 书 圈 " 微信 公众 号

二维码 ,在

书 专区 下 载,也 可以拨打 电话 或 发 送电子 邮件 咨询 。

果您在使用本 书的过程 中 遇 到 了什么问题 ,或 者有相关

世出版计划 ,

也请您发 邮件 告诉 我 们 ,以 便 我们 更好地 为 您 服务 。

我们 的联系方式:

也 址: 北京 海淀区 双清 路 学研大厦A 座 707

[ 编 : 100084

电 话: 010 一 62770175一4604

资源 下 载: http://www.tup.com.cn

电子 邮件: weijj@tup.tsinghua. edu. cn

QQ: 883604( 请 写明您 的 单位和 姓名 )

用微信扫一扫 右 边的 二维码 , 即可 关注 清华大 学 出 版 社公众 号 <“ 书鸭"”

平台 功能 介绍

十

如 果您 是 教师 ,您可以

如 果您 是 学 生,您可以

管理课程

建立课和

发表i王

提出问是

管理题库 加 入 课 和 SS 下 载 课 各 商科

发布二郑

和布填作 业 所

生理

激活 序列 号

F一

如 何加 入课程

找到 教材 封底“数字 课程 入 口”

1

Li 副 开 涂 层获取 二 维 码,扫 码进入 课程

范 | azwaxa
例

钢
息
次
银

范

名 有蔷

省 口 相
一 二
间

获取 更 多 详尽平台 使用指导 可 输入 网 址
http://www.wqketang.com/course/550

| 0 如 有 疑问 ,可联系微信客服:DESTUP

一江 全

局 移

俊文 泉 课堂 斌 弟 大 学 出 版社
出 品 的 在 线 学 习 平台

Www.WaKETANG.COW

